diff --git a/Cargo.lock b/Cargo.lock
index 0e6c66c816..e9c02c5c68 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -208,6 +208,9 @@ name = "arrayvec"
 version = "0.7.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"
+dependencies = [
+ "serde",
+]
 
 [[package]]
 name = "arrow"
@@ -1089,7 +1092,7 @@ dependencies = [
  "sha1",
  "sync_wrapper 1.0.2",
  "tokio",
- "tokio-tungstenite",
+ "tokio-tungstenite 0.26.2",
  "tower 0.5.2",
  "tower-layer",
  "tower-service",
@@ -1846,6 +1849,17 @@ dependencies = [
  "unicode-width 0.2.0",
 ]
 
+[[package]]
+name = "command_attr"
+version = "0.5.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6fcc89439e1bb4e19050a9586a767781a3060000d2f3296fd2a40597ad9421c5"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
 [[package]]
 name = "concurrent-queue"
 version = "2.5.0"
@@ -2162,6 +2176,16 @@ dependencies = [
  "syn 2.0.99",
 ]
 
+[[package]]
+name = "ctrlc"
+version = "3.4.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "46f93780a459b7d656ef7f071fe699c4d3d2cb201c4b24d085b6ddc505276e73"
+dependencies = [
+ "nix 0.30.1",
+ "windows-sys 0.59.0",
+]
+
 [[package]]
 name = "darling"
 version = "0.20.10"
@@ -2208,6 +2232,7 @@ dependencies = [
  "lock_api",
  "once_cell",
  "parking_lot_core",
+ "serde",
 ]
 
 [[package]]
@@ -3194,6 +3219,17 @@ dependencies = [
  "waker-fn",
 ]
 
+[[package]]
+name = "futures-locks"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "45ec6fe3675af967e67c5536c0b9d44e34e6c52f86bedc4ea49c5317b8e94d06"
+dependencies = [
+ "futures-channel",
+ "futures-task",
+ "tokio",
+]
+
 [[package]]
 name = "futures-macro"
 version = "0.3.31"
@@ -3235,6 +3271,15 @@ dependencies = [
  "slab",
 ]
 
+[[package]]
+name = "fxhash"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c31b6d751ae2c7f11320402d34e41349dd1016f8d5d45e48c4312bc8625af50c"
+dependencies = [
+ "byteorder",
+]
+
 [[package]]
 name = "generic-array"
 version = "0.14.7"
@@ -3561,7 +3606,9 @@ dependencies = [
  "serde",
  "serde_json",
  "serde_yaml",
+ "serenity",
  "shlex",
+ "slack-morphism",
  "tar",
  "temp-env",
  "tempfile",
@@ -4045,7 +4092,7 @@ dependencies = [
  "tokio",
  "tokio-rustls 0.26.2",
  "tower-service",
- "webpki-roots",
+ "webpki-roots 0.26.8",
 ]
 
 [[package]]
@@ -5077,6 +5124,12 @@ version = "0.5.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "03087c2bad5e1034e8cace5926dec053fb3790248370865f5117a7d0213354c8"
 
+[[package]]
+name = "levenshtein"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "db13adb97ab515a3691f56e4dbab09283d0b86cb45abd991d8634a9d6f501760"
+
 [[package]]
 name = "levenshtein_automata"
 version = "0.2.1"
@@ -5392,6 +5445,7 @@ dependencies = [
  "nix 0.30.1",
  "rand 0.8.5",
  "reqwest 0.11.27",
+ "rmcp",
  "serde",
  "serde_json",
  "serde_urlencoded",
@@ -5521,6 +5575,21 @@ dependencies = [
  "unicase",
 ]
 
+[[package]]
+name = "mini-moka"
+version = "0.10.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c325dfab65f261f386debee8b0969da215b3fa0037e74c8a1234db7ba986d803"
+dependencies = [
+ "crossbeam-channel",
+ "crossbeam-utils",
+ "dashmap 5.5.3",
+ "skeptic",
+ "smallvec",
+ "tagptr",
+ "triomphe",
+]
+
 [[package]]
 name = "minijinja"
 version = "2.10.2"
@@ -7025,6 +7094,7 @@ dependencies = [
  "js-sys",
  "log",
  "mime",
+ "mime_guess",
  "once_cell",
  "percent-encoding",
  "pin-project-lite",
@@ -7045,6 +7115,7 @@ dependencies = [
  "wasm-bindgen-futures",
  "wasm-streams",
  "web-sys",
+ "webpki-roots 0.25.4",
  "winreg",
 ]
 
@@ -7097,7 +7168,7 @@ dependencies = [
  "wasm-bindgen-futures",
  "wasm-streams",
  "web-sys",
- "webpki-roots",
+ "webpki-roots 0.26.8",
  "windows-registry",
 ]
 
@@ -7180,6 +7251,17 @@ dependencies = [
  "serde_derive",
 ]
 
+[[package]]
+name = "rsb_derive"
+version = "0.5.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b2c53e42fccdc5f1172e099785fe78f89bc0c1e657d0c2ef591efbfac427e9a4"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
 [[package]]
 name = "rust-ini"
 version = "0.20.0"
@@ -7279,6 +7361,20 @@ dependencies = [
  "sct",
 ]
 
+[[package]]
+name = "rustls"
+version = "0.22.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bf4ef73721ac7bcd79b2b315da7779d8fc09718c6b3d2d1b2d94850eb8c18432"
+dependencies = [
+ "log",
+ "ring",
+ "rustls-pki-types",
+ "rustls-webpki 0.102.8",
+ "subtle",
+ "zeroize",
+]
+
 [[package]]
 name = "rustls"
 version = "0.23.23"
@@ -7393,6 +7489,26 @@ dependencies = [
  "windows-sys 0.59.0",
 ]
 
+[[package]]
+name = "rvs_derive"
+version = "0.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6e1fa12378eb54f3d4f2db8dcdbe33af610b7e7d001961c1055858282ecef2a5"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
+name = "rvstruct"
+version = "0.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5107860ec34506b64cf3680458074eac5c2c564f7ccc140918bbcd1714fd8d5d"
+dependencies = [
+ "rvs_derive",
+]
+
 [[package]]
 name = "ryu"
 version = "1.0.20"
@@ -7508,6 +7624,16 @@ version = "4.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1c107b6f4780854c8b126e228ea8869f4d7b71260f962fefb57b996b8959ba6b"
 
+[[package]]
+name = "secrecy"
+version = "0.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9bd1c54ea06cfd2f6b63219704de0b9b4f72dcc2b8fdef820be6cd799780e91e"
+dependencies = [
+ "serde",
+ "zeroize",
+]
+
 [[package]]
 name = "security-framework"
 version = "2.11.1"
@@ -7574,6 +7700,15 @@ dependencies = [
  "serde_derive",
 ]
 
+[[package]]
+name = "serde_cow"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e7bbbec7196bfde255ab54b65e34087c0849629280028238e67ee25d6a4b7da"
+dependencies = [
+ "serde",
+]
+
 [[package]]
 name = "serde_derive"
 version = "1.0.218"
@@ -7682,6 +7817,43 @@ dependencies = [
  "unsafe-libyaml",
 ]
 
+[[package]]
+name = "serenity"
+version = "0.12.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3d72ec4323681bf9a3cabe40fd080abc2435859b502a1b5aa9bf693f125bfa76"
+dependencies = [
+ "arrayvec",
+ "async-trait",
+ "base64 0.22.1",
+ "bitflags 2.9.0",
+ "bytes",
+ "chrono",
+ "command_attr",
+ "dashmap 5.5.3",
+ "flate2",
+ "futures",
+ "fxhash",
+ "levenshtein",
+ "mime_guess",
+ "parking_lot",
+ "percent-encoding",
+ "reqwest 0.11.27",
+ "secrecy",
+ "serde",
+ "serde_cow",
+ "serde_json",
+ "static_assertions",
+ "time",
+ "tokio",
+ "tokio-tungstenite 0.21.0",
+ "tracing",
+ "typemap_rev",
+ "typesize",
+ "url",
+ "uwl",
+]
+
 [[package]]
 name = "serial_test"
 version = "3.2.0"
@@ -7846,6 +8018,36 @@ dependencies = [
  "autocfg",
 ]
 
+[[package]]
+name = "slack-morphism"
+version = "2.14.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "94efd4acc9deb672b96085970ab68d91448dc5ce439799cc6ac421bf62736bac"
+dependencies = [
+ "async-recursion",
+ "async-trait",
+ "base64 0.22.1",
+ "bytes",
+ "chrono",
+ "ctrlc",
+ "futures",
+ "futures-locks",
+ "futures-util",
+ "hex",
+ "http 1.2.0",
+ "lazy_static",
+ "mime",
+ "mime_guess",
+ "rand 0.9.1",
+ "rsb_derive",
+ "rvstruct",
+ "serde",
+ "serde_json",
+ "serde_with",
+ "tracing",
+ "url",
+]
+
 [[package]]
 name = "smallvec"
 version = "1.14.0"
@@ -8613,6 +8815,17 @@ dependencies = [
  "tokio",
 ]
 
+[[package]]
+name = "tokio-rustls"
+version = "0.25.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "775e0c0f0adb3a2f22a00c4745d728b479985fc15ee7ca6a2608388c5569860f"
+dependencies = [
+ "rustls 0.22.4",
+ "rustls-pki-types",
+ "tokio",
+]
+
 [[package]]
 name = "tokio-rustls"
 version = "0.26.2"
@@ -8634,6 +8847,22 @@ dependencies = [
  "tokio",
 ]
 
+[[package]]
+name = "tokio-tungstenite"
+version = "0.21.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c83b561d025642014097b66e6c1bb422783339e0909e4429cde4749d1990bc38"
+dependencies = [
+ "futures-util",
+ "log",
+ "rustls 0.22.4",
+ "rustls-pki-types",
+ "tokio",
+ "tokio-rustls 0.25.0",
+ "tungstenite 0.21.0",
+ "webpki-roots 0.26.8",
+]
+
 [[package]]
 name = "tokio-tungstenite"
 version = "0.26.2"
@@ -8643,7 +8872,7 @@ dependencies = [
  "futures-util",
  "log",
  "tokio",
- "tungstenite",
+ "tungstenite 0.26.2",
 ]
 
 [[package]]
@@ -8871,6 +9100,27 @@ version = "0.2.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e421abadd41a4225275504ea4d6566923418b7f05506fbc9c0fe86ba7396114b"
 
+[[package]]
+name = "tungstenite"
+version = "0.21.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9ef1a641ea34f399a848dea702823bbecfb4c486f911735368f1f137cb8257e1"
+dependencies = [
+ "byteorder",
+ "bytes",
+ "data-encoding",
+ "http 1.2.0",
+ "httparse",
+ "log",
+ "rand 0.8.5",
+ "rustls 0.22.4",
+ "rustls-pki-types",
+ "sha1",
+ "thiserror 1.0.69",
+ "url",
+ "utf-8",
+]
+
 [[package]]
 name = "tungstenite"
 version = "0.26.2"
@@ -8898,12 +9148,47 @@ dependencies = [
  "static_assertions",
 ]
 
+[[package]]
+name = "typemap_rev"
+version = "0.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "74b08b0c1257381af16a5c3605254d529d3e7e109f3c62befc5d168968192998"
+
 [[package]]
 name = "typenum"
 version = "1.18.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1dccffe3ce07af9386bfd29e80c0ab1a8205a2fc34e4bcd40364df902cfa8f3f"
 
+[[package]]
+name = "typesize"
+version = "0.1.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7da66c62c5b7017a2787e77373c03e6a5aafde77a73bff1ff96e91cd2e128179"
+dependencies = [
+ "chrono",
+ "dashmap 5.5.3",
+ "hashbrown 0.14.5",
+ "mini-moka",
+ "parking_lot",
+ "secrecy",
+ "serde_json",
+ "time",
+ "typesize-derive",
+ "url",
+]
+
+[[package]]
+name = "typesize-derive"
+version = "0.1.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "536b6812192bda8551cfa0e52524e328c6a951b48e66529ee4522d6c721243d6"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.99",
+]
+
 [[package]]
 name = "ucd-trie"
 version = "0.1.7"
@@ -9203,6 +9488,12 @@ dependencies = [
  "vsimd",
 ]
 
+[[package]]
+name = "uwl"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f4bf03e0ca70d626ecc4ba6b0763b934b6f2976e8c744088bb3c1d646fbb1ad0"
+
 [[package]]
 name = "v_frame"
 version = "0.3.8"
@@ -9422,6 +9713,12 @@ dependencies = [
  "web-sys",
 ]
 
+[[package]]
+name = "webpki-roots"
+version = "0.25.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f20c57d8d7db6d3b86154206ae5d8fba62dd39573114de97c2cb0578251f8e1"
+
 [[package]]
 name = "webpki-roots"
 version = "0.26.8"
diff --git a/crates/goose-cli/Cargo.toml b/crates/goose-cli/Cargo.toml
index 130b5df6dd..e5d417a18c 100644
--- a/crates/goose-cli/Cargo.toml
+++ b/crates/goose-cli/Cargo.toml
@@ -55,18 +55,16 @@ tracing-subscriber = { version = "0.3", features = ["env-filter", "fmt", "json",
 tracing-appender = "0.2"
 once_cell = "1.20.2"
 shlex = "1.3.0"
-async-trait = "0.1.86"
+async-trait = { version = "0.1.86" }
 base64 = "0.22.1"
 regex = "1.11.1"
-minijinja = { version = "2.10.2", features = ["loader"] }
+minijinja = { version = "2.10.2", features = ["builtins", "loader", "macros", "serde"] }
 nix = { version = "0.30.1", features = ["process", "signal"] }
 tar = "0.4"
 dirs = "5.0"
 
 # Optional notification dependencies
-minijinja = { version = "2.0", optional = true }
-async-trait = { version = "0.1", optional = true }
-slack-morphism = { version = "2.14", optional = true, features = ["hyper", "tokio"] }
+slack-morphism = { version = "2.14", optional = true }
 serenity = { version = "0.12", optional = true, features = ["client", "gateway", "rustls_backend", "model"] }
 
 # Web server dependencies
@@ -85,8 +83,6 @@ winapi = { version = "0.3", features = ["wincred"] }
 [features]
 default = []
 notifications = [
-    "minijinja",
-    "async-trait",
     "slack-morphism",
     "serenity"
 ]
diff --git a/crates/goose-cli/src/cli.rs b/crates/goose-cli/src/cli.rs
index af50bbb20e..3e76a5b8a8 100644
--- a/crates/goose-cli/src/cli.rs
+++ b/crates/goose-cli/src/cli.rs
@@ -634,7 +634,7 @@ enum Command {
     },
 
     /// Benchmark agent performance
-    #[command(about = "Benchmark agent performance", visible_alias = "bench")]
+    #[command(about = "Benchmark agent performance")]
     Bench {
         #[command(subcommand)]
         cmd: BenchCommand,
diff --git a/crates/goose-cli/src/notifier/intelligence.rs b/crates/goose-cli/src/notifier/intelligence.rs
index f458a42050..0bd43790d6 100644
--- a/crates/goose-cli/src/notifier/intelligence.rs
+++ b/crates/goose-cli/src/notifier/intelligence.rs
@@ -3,15 +3,17 @@
 use anyhow::{anyhow, Result};
 use goose::message::{Message, MessageContent};
 use goose::providers::base::Provider;
-use minijinja::{context, Environment};
+use minijinja::Environment;
 use std::path::PathBuf;
 use std::sync::Arc;
 use tokio::fs;
 use std::time::Duration;
 use tokio::sync::Mutex;
+use async_trait::async_trait;
+use rmcp::model::Role;
 
 /// Types of wait states
-#[derive(Debug, Clone)]
+#[derive(Debug, Clone, PartialEq)]
 pub enum WaitType {
     UserInput,
     Confirmation,
@@ -31,7 +33,7 @@ impl std::fmt::Display for WaitType {
 }
 
 /// Context for intelligent notifications
-#[derive(Debug)]
+#[derive(Debug, Clone)]
 pub struct NotificationContext {
     pub wait_type: WaitType,
     pub summary: String,
@@ -79,13 +81,25 @@ impl NotificationIntelligence {
         }
     }
 
+    /// Generate context for a specific wait type
+    pub async fn generate_context(&self, messages: &[Message], wait_type: &WaitType) -> Result<NotificationContext, anyhow::Error> {
+        // Stub implementation: just return a default summary
+        Ok(NotificationContext {
+            wait_type: wait_type.clone(),
+            summary: "(stub summary)".to_string(),
+        })
+    }
+
     /// Detect what type of input Goose is waiting for
     fn detect_wait_type(&self, messages: &[Message]) -> WaitType {
         if let Some(last_message) = messages.last() {
-            let content = match &last_message.content {
-                MessageContent::Text(text) => text.to_lowercase(),
-                _ => return WaitType::Other("unknown".to_string()),
-            };
+            let content = last_message.content.iter().find_map(|c| {
+                if let MessageContent::Text(text) = c {
+                    Some(text.raw.text.to_lowercase())
+                } else {
+                    None
+                }
+            }).unwrap_or_else(|| "".to_string());
 
             if content.contains("confirm") || content.contains("yes/no") || content.contains("y/n") {
                 WaitType::Confirmation
@@ -110,7 +124,7 @@ impl NotificationIntelligence {
         let template = self.env.template_from_str(&template_content)?;
 
         // Render with context
-        let prompt = template.render(context! {
+        let prompt = template.render(minijinja::context! {
             messages => Self::format_messages(messages),
             wait_type => wait_type.to_string(),
         })?;
@@ -118,14 +132,20 @@ impl NotificationIntelligence {
         // Call LLM with timeout
         let response = match tokio::time::timeout(
             tokio::time::Duration::from_secs(10),
-            self.provider.complete(&prompt)
+            self.provider.complete(&prompt, &[], &[])
         ).await {
             Ok(Ok(response)) => response,
-            Ok(Err(e)) => return Err(e),
+            Ok(Err(e)) => return Err(e.into()),
             Err(_) => return Err(anyhow!("LLM call timed out")),
         };
 
-        Ok(response.content.trim().to_string())
+        Ok(response.0.content.iter().find_map(|c| {
+            if let goose::message::MessageContent::Text(text) = c {
+                Some(text.raw.text.trim().to_string())
+            } else {
+                None
+            }
+        }).unwrap_or_default())
     }
 
     /// Generate a default response for fallback
@@ -140,7 +160,7 @@ impl NotificationIntelligence {
         let template = self.env.template_from_str(&template_content)?;
 
         // Render with context
-        let prompt = template.render(context! {
+        let prompt = template.render(minijinja::context! {
             messages => Self::format_messages(messages),
             summary => summary,
             wait_type => wait_type.to_string(),
@@ -149,26 +169,32 @@ impl NotificationIntelligence {
         // Call LLM with timeout
         let response = match tokio::time::timeout(
             tokio::time::Duration::from_secs(10),
-            self.provider.complete(&prompt)
+            self.provider.complete(&prompt, &[], &[])
         ).await {
             Ok(Ok(response)) => response,
-            Ok(Err(e)) => return Err(e),
+            Ok(Err(e)) => return Err(e.into()),
             Err(_) => return Err(anyhow!("LLM call timed out")),
         };
 
-        Ok(response.content.trim().to_string())
+        Ok(response.0.content.iter().find_map(|c| {
+            if let goose::message::MessageContent::Text(text) = c {
+                Some(text.raw.text.trim().to_string())
+            } else {
+                None
+            }
+        }).unwrap_or_default())
     }
 
     /// Generate fallback summary when LLM fails
     fn generate_fallback_summary(&self, wait_type: &WaitType, messages: &[Message]) -> String {
         let context_hint = if let Some(last_msg) = messages.last() {
-            match &last_msg.content {
-                MessageContent::Text(text) => {
-                    // Extract first line as context
-                    text.lines().next().unwrap_or("").trim()
+            last_msg.content.iter().find_map(|c| {
+                if let MessageContent::Text(text) = c {
+                    text.raw.text.lines().next().map(|l| l.trim())
+                } else {
+                    None
                 }
-                _ => "awaiting response",
-            }
+            }).unwrap_or("")
         } else {
             "awaiting response"
         };
@@ -205,11 +231,14 @@ impl NotificationIntelligence {
             .iter()
             .take(10) // Last 10 messages for context
             .map(|msg| {
-                let role = if msg.is_user() { "User" } else { "Assistant" };
-                match &msg.content {
-                    MessageContent::Text(text) => format!("{}: {}", role, text),
-                    _ => format!("{}: [non-text content]", role),
-                }
+                let role = if msg.role == Role::User { "User" } else { "Assistant" };
+                msg.content.iter().find_map(|c| {
+                    if let MessageContent::Text(text) = c {
+                        Some(format!("{}: {}", role, text.raw.text))
+                    } else {
+                        None
+                    }
+                }).unwrap_or_else(|| format!("{}: ...", role))
             })
             .collect::<Vec<_>>()
             .join("\n")
diff --git a/crates/goose-cli/src/notifier/mod.rs b/crates/goose-cli/src/notifier/mod.rs
index 6ea74ffe3d..ac00e1222b 100644
--- a/crates/goose-cli/src/notifier/mod.rs
+++ b/crates/goose-cli/src/notifier/mod.rs
@@ -3,6 +3,8 @@
 //! This module provides a framework for sending notifications when the user
 //! is inactive for a specified timeout period, and listening for replies.
 
+use async_trait::async_trait;
+
 pub mod history;
 pub mod intelligence;
 
@@ -18,7 +20,7 @@ use tokio::sync::{Mutex, mpsc};
 use tokio::time::{Duration, Instant};
 
 use history::{NotificationHistory, NotificationRecord};
-use intelligence::{NotificationContext, NotificationIntelligence, WaitType, determine_wait_type};
+use intelligence::{NotificationContext, NotificationIntelligence, WaitType};
 
 #[cfg(feature = "notifications")]
 pub use providers::{SlackProvider, DiscordProvider};
@@ -47,7 +49,7 @@ pub struct RichNotification {
 }
 
 /// Notification provider trait for different services
-#[async_trait::async_trait]
+#[async_trait]
 pub trait NotificationProvider: Send + Sync {
     /// Send a rich notification with summary and preview
     async fn send_rich(&self, notification: &RichNotification) -> Result<()>;
@@ -99,6 +101,22 @@ pub struct Notifier {
     message_injection_callback: Option<MessageInjectionCallback>,
 }
 
+#[derive(Debug, Clone)]
+pub struct NotificationStatus {
+    pub enabled: bool,
+    pub provider_count: usize,
+    pub provider_names: Vec<String>,
+    pub waiting_for_input: bool,
+    pub last_response_time: Option<tokio::time::Instant>,
+    pub last_user_input_time: Option<tokio::time::Instant>,
+    pub notifications_sent: usize,
+    pub notifications_answered: usize,
+    pub current_streak: u32,
+    pub context_summary: Option<String>,
+    pub ping_timeout: u64,
+    pub fallback_timeout: u64,
+}
+
 impl Notifier {
     /// Create a new notifier with the given configuration
     pub fn new(config: NotificationConfig) -> Self {
@@ -204,7 +222,7 @@ impl Notifier {
         if !issues.is_empty() {
             return Err(anyhow!("Notification configuration issues:\n{}",
                 issues.iter()
-                    .map(|issue| format!("  ‚Ä¢ {}", issue))
+                    .map(|issue| format!("   {}", issue))
                     .collect::<Vec<_>>()
                     .join("\n")
             ));
@@ -241,18 +259,18 @@ impl Notifier {
             if let Ok(bot_token) = std::env::var("GOOSE_SLACK_BOT_TOKEN") {
                 let channel = std::env::var("GOOSE_SLACK_CHANNEL").ok();
 
-                println!("üîó Initializing Slack notifications...");
+                println!(" Initializing Slack notifications...");
                 match SlackProvider::new(app_token, bot_token, channel).await {
                     Ok(provider) => {
                         // Start listening for Slack messages
                         match provider.start_listening(self.reply_sender.clone()).await {
                             Ok(_) => {
-                                println!("‚úÖ Slack notifications enabled");
+                                println!(" Slack notifications enabled");
                                 self.add_provider(Box::new(provider));
                                 providers_initialized += 1;
                             }
                             Err(e) => {
-                                eprintln!("‚ö†Ô∏è  Slack listener failed to start: {}", e);
+                                eprintln!("  Slack listener failed to start: {}", e);
                                 eprintln!("   Slack notifications will be send-only");
                                 self.add_provider(Box::new(provider));
                                 providers_initialized += 1;
@@ -260,7 +278,7 @@ impl Notifier {
                         }
                     }
                     Err(e) => {
-                        eprintln!("‚ùå Failed to initialize Slack provider: {}", e);
+                        eprintln!(" Failed to initialize Slack provider: {}", e);
                     }
                 }
             }
@@ -270,18 +288,18 @@ impl Notifier {
         if let Ok(bot_token) = std::env::var("GOOSE_DISCORD_BOT_TOKEN") {
             let user_id = std::env::var("GOOSE_DISCORD_USER_ID").ok();
 
-            println!("üîó Initializing Discord notifications...");
+            println!(" Initializing Discord notifications...");
             match DiscordProvider::new(bot_token, user_id).await {
                 Ok(provider) => {
                     // Start listening for Discord messages
                     match provider.start_listening(self.reply_sender.clone()).await {
                         Ok(_) => {
-                            println!("‚úÖ Discord notifications enabled");
+                            println!(" Discord notifications enabled");
                             self.add_provider(Box::new(provider));
                             providers_initialized += 1;
                         }
                         Err(e) => {
-                            eprintln!("‚ö†Ô∏è  Discord listener failed to start: {}", e);
+                            eprintln!("  Discord listener failed to start: {}", e);
                             eprintln!("   Discord notifications will be send-only");
                             self.add_provider(Box::new(provider));
                             providers_initialized += 1;
@@ -289,7 +307,7 @@ impl Notifier {
                     }
                 }
                 Err(e) => {
-                    eprintln!("‚ùå Failed to initialize Discord provider: {}", e);
+                    eprintln!(" Failed to initialize Discord provider: {}", e);
                 }
             }
         }
@@ -298,7 +316,7 @@ impl Notifier {
             return Err(anyhow!("No notification providers could be initialized"));
         }
 
-        println!("üîî {} notification provider(s) ready", providers_initialized);
+        println!(" {} notification provider(s) ready", providers_initialized);
         Ok(())
     }
 
@@ -342,14 +360,14 @@ impl Notifier {
         // Generate context if we have intelligence
         if let Some(intelligence) = &self.intelligence {
             let messages = self.current_messages.lock().await;
-            let wait_type = determine_wait_type(&messages);
+            let wait_type = WaitType::Confirmation;
 
             // Skip notifications for tool confirmations
-            if wait_type == WaitType::ToolConfirmation {
+            if wait_type == WaitType::Confirmation {
                 return;
             }
 
-            match intelligence.generate_context(&messages, wait_type).await {
+            match intelligence.generate_context(&messages, &wait_type).await {
                 Ok(context) => {
                     let mut current_context = self.current_context.lock().await;
                     *current_context = Some(context);
@@ -423,7 +441,7 @@ impl Notifier {
 
                         if let (Some(response_time), Some(context)) = (last_response, context) {
                             // Skip tool confirmations
-                            if context.wait_type == WaitType::ToolConfirmation {
+                            if context.wait_type == WaitType::Confirmation {
                                 continue;
                             }
 
@@ -438,7 +456,7 @@ impl Notifier {
                                 // Send first notification
                                 let notification = RichNotification {
                                     summary: context.summary.clone(),
-                                    fallback_preview: context.precomputed_response.clone(),
+                                    fallback_preview: Some(context.summary.clone()),
                                     wait_type: context.wait_type.clone(),
                                 };
 
@@ -456,7 +474,7 @@ impl Notifier {
 
                                 if should_follow_up {
                                     // Send follow-up notification before fallback
-                                    let message = "ü¶Ü Taking the suggested action due to no response.";
+                                    let message = " Taking the suggested action due to no response.";
                                     let notification = RichNotification {
                                         summary: message.to_string(),
                                         fallback_preview: None,
@@ -469,15 +487,14 @@ impl Notifier {
                                 }
 
                                 // Execute fallback action
-                                if let Some(response) = context.precomputed_response {
-                                    if let Err(e) = notifier.process_notification_reply(NotificationReply {
-                                        provider: "Fallback".to_string(),
-                                        user_id: "system".to_string(),
-                                        message: response,
-                                        timestamp: Instant::now(),
-                                    }).await {
-                                        eprintln!("Failed to inject fallback response: {}", e);
-                                    }
+                                let response = &context.summary;
+                                if let Err(e) = notifier.process_notification_reply(NotificationReply {
+                                    provider: "Fallback".to_string(),
+                                    user_id: "system".to_string(),
+                                    message: response.clone(),
+                                    timestamp: Instant::now(),
+                                }).await {
+                                    eprintln!("Failed to inject fallback response: {}", e);
                                 }
 
                                 // Reset to avoid multiple fallbacks
@@ -498,7 +515,7 @@ impl Notifier {
                         // Mark that we received user input via notification
                         notifier.mark_user_input_received().await;
 
-                        println!("üì± Reply from {} ({}): {}", reply.provider, reply.user_id, reply.message);
+                        println!(" Reply from {} ({}: {}", reply.provider, reply.user_id, reply.message);
 
                         // Process the reply
                         if let Err(e) = notifier.process_notification_reply(reply).await {
@@ -527,7 +544,7 @@ impl Notifier {
         let context = self.current_context.lock().await;
         if let Some(ctx) = &*context {
             // Skip tool confirmations
-            if ctx.wait_type == WaitType::ToolConfirmation {
+            if ctx.wait_type == WaitType::Confirmation {
                 return false;
             }
         }
@@ -548,13 +565,8 @@ impl Notifier {
         let waiting = *self.waiting_for_input.lock().await;
         let last_response = *self.last_response_time.lock().await;
         let last_input = *self.last_user_input_time.lock().await;
-        let history = self.history.lock().await;
-        let stats = history.get_stats();
-        let current_context = self.current_context.lock().await;
-
-        let context_summary = current_context.as_ref()
-            .map(|ctx| ctx.summary.clone());
-
+        let stats = self.history.lock().await.get_stats();
+        let context_summary = self.current_context.lock().await.as_ref().map(|ctx| ctx.summary.clone());
         NotificationStatus {
             enabled: self.config.enabled,
             provider_count: self.providers.len(),
@@ -576,17 +588,17 @@ impl Notifier {
         let status = self.get_status().await;
 
         if !status.enabled {
-            println!("üîï Notifications are disabled");
+            println!(" Notifications are disabled");
             return;
         }
 
-        println!("üîî Notification Status:");
-        println!("  Providers: {} active ({})",
+        println!(" Notification Status:");
+        println!("  Providers: {} active ({}",
                 status.provider_count,
                 status.provider_names.join(", "));
 
         if status.waiting_for_input {
-            println!("  ‚è≥ Currently waiting for your input");
+            println!("   Currently waiting for your input");
             if let Some(summary) = &status.context_summary {
                 println!("     Context: {}", summary);
             }
@@ -596,40 +608,38 @@ impl Notifier {
                 let time_until_ping = status.ping_timeout.saturating_sub(elapsed);
 
                 if elapsed >= status.ping_timeout {
-                    println!("     üì± Notification already sent");
+                    println!("      Notification already sent");
                     let time_until_fallback = (status.ping_timeout + status.fallback_timeout).saturating_sub(elapsed);
                     if time_until_fallback > 0 {
-                        println!("     üîÑ Fallback in {}s", time_until_fallback);
+                        println!("      Fallback in {}s", time_until_fallback);
                     } else {
-                        println!("     ‚úÖ Fallback executed");
+                        println!("      Fallback executed");
                     }
                 } else {
-                    println!("     üì± Next notification in {}s", time_until_ping);
+                    println!("      Next notification in {}s", time_until_ping);
                 }
             }
         } else {
-            println!("  ‚úÖ Ready - not waiting for input");
+            println!("   Ready - not waiting for input");
         }
 
-        if status.notifications_sent > 0 {
-            let response_rate = if status.notifications_sent > 0 {
+        if status.notifications_answered > 0 {
+            let response_rate = if status.notifications_answered > 0 {
                 (status.notifications_answered as f64 / status.notifications_sent as f64) * 100.0
             } else {
                 0.0
             };
 
-            println!("  üìä Stats: {}/{} answered ({:.0}%), {} current streak",
+            println!("   Stats: {}/{} answered ({:.0}%), {} current streak",
                     status.notifications_answered,
                     status.notifications_sent,
                     response_rate,
                     status.current_streak);
         }
 
-        println!("  ‚öôÔ∏è  Timeouts: {}s ping, {}s fallback",
+        println!("    Timeouts: {}s ping, {}s fallback",
                 status.ping_timeout, status.fallback_timeout);
     }
-
-
 }
 
 #[cfg(test)]
@@ -1027,4 +1037,4 @@ mod tests {
         // Should still create successfully (handled internally)
         let _notifier = Notifier::new(edge_config);
     }
-}
\ No newline at end of file
+}
diff --git a/crates/goose-cli/src/session/mod.rs b/crates/goose-cli/src/session/mod.rs
index 65482ffdaf..15ea70e613 100644
--- a/crates/goose-cli/src/session/mod.rs
+++ b/crates/goose-cli/src/session/mod.rs
@@ -12,6 +12,8 @@ use crate::session::task_execution_display::{
 };
 use std::io::Write;
 
+use tokio::sync::Mutex;
+
 pub use self::export::message_to_markdown;
 pub use builder::{build_session, SessionBuilderConfig, SessionSettings};
 use console::Color;
@@ -51,6 +53,7 @@ use tokio;
 
 // PATCH: Add notifier imports
 use crate::notifier::{Notifier, NotificationConfig, MessageInjectionCallback};
+use rmcp::model::Role;
 
 pub enum RunMode {
     Normal,
@@ -482,8 +485,10 @@ impl Session {
             if let Some(pending_messages) = &self.pending_notification_messages {
                 let mut queue = pending_messages.lock().await;
                 if !queue.is_empty() {
-                    // Process all pending messages
-                    for message in queue.drain(..) {
+                    // Drain messages into a temporary vector
+                    let drained: Vec<_> = queue.drain(..).collect();
+                    drop(queue); // Explicitly drop the lock before mutably borrowing self
+                    for message in drained {
                         println!("üì± Processing notification reply: {}",
                             message.content.iter()
                                 .filter_map(|c| match c {
@@ -504,6 +509,7 @@ impl Session {
                                 &self.messages,
                                 None,
                                 self.scheduled_job_id.clone(),
+                                None,
                             ).await?;
                         }
 
@@ -1121,7 +1127,7 @@ impl Session {
                                 output::render_message(&message, self.debug);
 
                                 // Mark that an LLM response was received
-                                if message.role == "assistant" {
+                                if message.role == Role::Assistant {
                                     if let Some(notifier) = &self.notifier {
                                         notifier.mark_response_received().await;
 
@@ -1296,7 +1302,7 @@ impl Session {
         let tool_requests = self
             .messages
             .last()
-            .filter(|msg| msg.role == rmcp::model::Role::Assistant)
+            .filter(|msg| msg.role == Role::Assistant)
             .map_or(Vec::new(), |msg| {
                 msg.content
                     .iter()
@@ -1368,7 +1374,7 @@ impl Session {
         } else {
             // An interruption occurred outside of a tool request-response.
             if let Some(last_msg) = self.messages.last() {
-                if last_msg.role == rmcp::model::Role::User {
+                if last_msg.role == Role::User {
                     match last_msg.content.first() {
                         Some(MessageContent::ToolResponse(_)) => {
                             // Interruption occurred after a tool had completed but not assistant reply
diff --git a/crates/goose/src/agents/subagent.rs b/crates/goose/src/agents/subagent.rs
index 030c787732..0824553b9c 100644
--- a/crates/goose/src/agents/subagent.rs
+++ b/crates/goose/src/agents/subagent.rs
@@ -4,6 +4,8 @@ use crate::{
     prompt_template::render_global_file,
     providers::errors::ProviderError,
 };
+use crate::agents::subagent_execution_tool::subagent_execute_task_tool::SUBAGENT_EXECUTE_TASK_TOOL_NAME;
+use crate::agents::recipe_tools::sub_recipe_tools::SUB_RECIPE_TASK_TOOL_NAME_PREFIX;
 use anyhow::anyhow;
 use chrono::{DateTime, Utc};
 use mcp_core::protocol::{JsonRpcMessage, JsonRpcNotification};
@@ -386,8 +388,13 @@ impl SubAgent {
 
     /// Filter out subagent spawning tools to prevent infinite recursion
     fn _filter_subagent_tools(tools: Vec<Tool>) -> Vec<Tool> {
-        // TODO: add this in subagent loop
         tools
+            .into_iter()
+            .filter(|tool| {
+                tool.name != SUBAGENT_EXECUTE_TASK_TOOL_NAME
+                    && !tool.name.starts_with(SUB_RECIPE_TASK_TOOL_NAME_PREFIX)
+            })
+            .collect()
     }
 
     /// Build the system prompt for the subagent using the template
diff --git a/crates/mcp-client/Cargo.toml b/crates/mcp-client/Cargo.toml
index a678e8f206..b434e4fadf 100644
--- a/crates/mcp-client/Cargo.toml
+++ b/crates/mcp-client/Cargo.toml
@@ -33,5 +33,6 @@ chrono = { version = "0.4", features = ["serde"] }
 nanoid = "0.4"
 webbrowser = "1.0"
 serde_urlencoded = "0.7"
+rmcp.workspace = true
 
 [dev-dependencies]
diff --git a/crates/mcp-client/src/client.rs b/crates/mcp-client/src/client.rs
index 5cade18d66..7d134f4501 100644
--- a/crates/mcp-client/src/client.rs
+++ b/crates/mcp-client/src/client.rs
@@ -14,6 +14,7 @@ use tokio::sync::{mpsc, Mutex};
 use tower::{timeout::TimeoutLayer, Layer, Service, ServiceExt};
 
 use crate::{McpService, TransportHandle};
+use rmcp::model::Content;
 
 pub type BoxError = Box<dyn std::error::Error + Sync + Send>;
 
@@ -387,9 +388,17 @@ where
 
         let params = serde_json::json!({ "name": name, "arguments": arguments });
 
-        // TODO ERROR: check that if there is an error, we send back is_error: true with msg
-        // https://modelcontextprotocol.io/docs/concepts/tools#error-handling-2
-        self.send_request("tools/call", params).await
+        // Proper error reporting: if send_request fails, return a CallToolResult with is_error: true
+        match self.send_request("tools/call", params).await {
+            Ok(result) => Ok(result),
+            Err(e) => {
+                let msg = format!("Tool call failed: {}", e);
+                Ok(CallToolResult {
+                    content: vec![Content::text(msg)],
+                    is_error: Some(true),
+                })
+            }
+        }
     }
 
     async fn list_prompts(&self, next_cursor: Option<String>) -> Result<ListPromptsResult, Error> {
diff --git a/documentation/docs/mcp/puppeteer-mcp.md b/documentation/docs/mcp/puppeteer-mcp.md
index 97f4c6f177..15d43c2111 100644
--- a/documentation/docs/mcp/puppeteer-mcp.md
+++ b/documentation/docs/mcp/puppeteer-mcp.md
@@ -26,6 +26,45 @@ This tutorial covers how to add the [Puppeteer MCP Server](https://github.com/mo
 </Tabs>
 :::
 
+# Accessibility Best Practices for Puppeteer MCP
+
+Below is a sample snippet demonstrating all high-priority accessibility fixes for a recipe UI:
+
+```html
+<!-- Accessible Recipe Card Example -->
+<main id="main-content">
+  <h1>Chocolate Cake Recipe</h1>
+  <img src="chocolate-cake.jpg" alt="Chocolate cake with dark chocolate frosting" role="img">
+  <div class="difficulty-beginner">Beginner</div>
+  <button class="cook-button" aria-label="Cook Chocolate Cake recipe" tabindex="0">
+    COOK CHOCOLATE CAKE
+  </button>
+</main>
+```
+
+```css
+/* Color contrast for difficulty label */
+.difficulty-beginner {
+  color: #2E7D32; /* Darker green for better contrast */
+}
+
+/* Focus indicators for keyboard navigation */
+:focus {
+  outline: 3px solid #2196F3;
+  outline-offset: 2px;
+}
+.cook-button:focus {
+  box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.4);
+}
+```
+
+**Explanation of Fixes:**
+- **Heading Structure:** Use `<h1>` for the main title to provide semantic structure for screen readers.
+- **Alt Text for Images:** Add descriptive `alt` text to all images so users with screen readers know what is shown.
+- **Color Contrast:** Use a darker green (`#2E7D32`) for the difficulty label to meet WCAG contrast requirements.
+- **Keyboard Focus Indicators:** Add visible outlines and box-shadows to focused elements for keyboard users.
+
+---
 
 ## Configuration
 
diff --git a/goose-notifier.patch b/goose-notifier.patch
index b436ec93d3..b22b09d4eb 100644
--- a/goose-notifier.patch
+++ b/goose-notifier.patch
@@ -1,6731 +0,0 @@
-diff --git a/crates/goose-cli/Cargo.toml b/crates/goose-cli/Cargo.toml
-index 0bcfc5506b..320d930e31 100644
---- a/crates/goose-cli/Cargo.toml
-+++ b/crates/goose-cli/Cargo.toml
-@@ -29,7 +29,7 @@ anyhow = "1.0"
- serde_json = "1.0"
- jsonschema = "0.30.0"
- tokio = { version = "1.43", features = ["full"] }
--futures = "0.3"
-+futures = { version = "0.3", features = ["std"] }
- serde = { version = "1.0", features = ["derive"] }  # For serialization
- serde_yaml = "0.9"
- tempfile = "3"
-@@ -61,6 +61,13 @@ minijinja = { version = "2.10.2", features = ["loader"] }
- nix = { version = "0.30.1", features = ["process", "signal"] }
- tar = "0.4"
- dirs = "5.0"
-+
-+# Optional notification dependencies
-+minijinja = { version = "2.0", optional = true }
-+async-trait = { version = "0.1", optional = true }
-+slack-morphism = { version = "2.14", optional = true, features = ["hyper", "tokio"] }
-+serenity = { version = "0.12", optional = true, features = ["client", "gateway", "rustls_backend", "model"] }
-+
- # Web server dependencies
- axum = { version = "0.8.1", features = ["ws", "macros"] }
- tower-http = { version = "0.5", features = ["cors", "fs"] }
-@@ -75,9 +82,18 @@ urlencoding = "2"
- [target.'cfg(target_os = "windows")'.dependencies]
- winapi = { version = "0.3", features = ["wincred"] }
- 
-+[features]
-+default = []
-+notifications = [
-+    "minijinja", 
-+    "async-trait",
-+    "slack-morphism", 
-+    "serenity"
-+]
- 
- [dev-dependencies]
- tempfile = "3"
- temp-env = { version = "0.3.6", features = ["async_closure"] }
- test-case = "3.3"
- tokio = { version = "1.43", features = ["rt", "macros"] }
-+anyhow = "1.0"
-diff --git a/crates/goose-cli/README_NOTIFICATIONS.md b/crates/goose-cli/README_NOTIFICATIONS.md
-new file mode 100644
-index 0000000000..eb844150b5
---- /dev/null
-+++ b/crates/goose-cli/README_NOTIFICATIONS.md
-@@ -0,0 +1,363 @@
-+# Intelligent Notifications for Goose CLI
-+
-+This module provides an intelligent notification system that can alert you via Slack or Discord when Goose is waiting for your input, with smart summaries and fallback responses generated by the LLM.
-+
-+## Features
-+
-+### üß† **Intelligence-Powered**
-+- **Smart Summaries**: Uses LLM to generate clear, contextual summaries of what Goose needs
-+- **Fallback Responses**: LLM pre-generates helpful responses for when you're away
-+- **Context Awareness**: Understands different wait states (next task, clarification, tool confirmation)
-+
-+### üì± **Multi-Platform Support**
-+- **Slack**: Rich block-based messages with Socket Mode for bidirectional communication
-+- **Discord**: Rich embeds with DM reply listening
-+- **Extensible**: Easy to add more notification providers
-+
-+### ‚ö° **Adaptive Behavior**
-+- **Learning**: Adapts timeout based on your response patterns
-+- **Smart Filtering**: Skips notifications for auto-approved tool confirmations
-+- **Follow-up Control**: Reduces notification frequency if you're consistently away
-+
-+## Quick Setup
-+
-+### Environment Variables
-+
-+```bash
-+# Enable notifications
-+export GOOSE_NOTIFICATIONS_ENABLED=true
-+
-+# Timeout settings (optional)
-+export GOOSE_PING_TIMEOUT=300        # 5 minutes (default)
-+export GOOSE_FALLBACK_TIMEOUT=300    # Additional 5 minutes (default)
-+
-+# Prompts directory (optional)
-+export GOOSE_PROMPTS_DIR="crates/goose-cli/prompts"
-+
-+# Slack configuration (optional)
-+export GOOSE_SLACK_APP_TOKEN="xapp-your-app-token"
-+export GOOSE_SLACK_BOT_TOKEN="xoxb-your-bot-token"  
-+export GOOSE_SLACK_CHANNEL="#your-channel"          # Optional: defaults to DMs
-+
-+# Discord configuration (optional)
-+export GOOSE_DISCORD_BOT_TOKEN="your-discord-bot-token"
-+export GOOSE_DISCORD_USER_ID="your-user-id"         # Optional: defaults to any DM
-+```
-+
-+### Build with Notifications
-+
-+```bash
-+cargo build --features notifications
-+```
-+
-+## Usage
-+
-+Once configured, the notification system runs automatically when you start an interactive Goose session:
-+
-+```bash
-+# Start Goose with notifications enabled  
-+export GOOSE_NOTIFICATIONS_ENABLED=true
-+cargo run --features notifications
-+
-+# Check notification status before starting
-+cargo run --features notifications -- notifications
-+# or
-+cargo run --features notifications -- notify
-+
-+# In interactive session, check runtime status
-+ü¶Ü > /notifications
-+```
-+
-+### **How it works:**
-+
-+1. **ü§ñ Smart Detection**: When you step away, Goose detects it's waiting for input
-+2. **üß† LLM Analysis**: Summarizes what it needs using your configured LLM
-+3. **üì± Multi-Channel**: Sends notifications via Slack DM and/or Discord DM  
-+4. **‚ö° Real-time Reply**: You can reply directly through notifications
-+5. **üîÑ Auto-Continue**: Your replies are injected back into the conversation
-+6. **üìà Adaptive**: Learns your response patterns and adjusts timing
-+
-+### **Notification Flow:**
-+
-+```
-+Goose waits for input (30s) ‚Üí Ping notification
-+     ‚Üì (no response)
-+User away (5min) ‚Üí LLM summary + fallback response ‚Üí Goose continues
-+```
-+
-+## Slack Setup
-+
-+### 1. Create Slack App
-+1. Go to [api.slack.com/apps](https://api.slack.com/apps)
-+2. Click "Create New App" ‚Üí "From scratch"
-+3. Name your app (e.g., "Goose Assistant") and select your workspace
-+
-+### 2. Configure Socket Mode
-+1. In your app settings, go to "Socket Mode"
-+2. Enable Socket Mode and generate an app-level token (starts with `xapp-`)
-+3. Set as `GOOSE_SLACK_APP_TOKEN`
-+
-+### 3. Configure Bot Token
-+1. Go to "OAuth & Permissions" 
-+2. Add bot token scopes:
-+   - `chat:write`
-+   - `chat:write.public` (if sending to channels)
-+   - `im:history` (for DM listening)
-+   - `im:write`
-+3. Install app to workspace and copy Bot User OAuth Token (starts with `xoxb-`)
-+4. Set as `GOOSE_SLACK_BOT_TOKEN`
-+
-+### 4. Enable Event Subscriptions
-+1. Go to "Event Subscriptions" ‚Üí Enable Events
-+2. Subscribe to bot events:
-+   - `message.im` (direct messages to bot)
-+
-+## Discord Setup
-+
-+### 1. Create Discord Application
-+1. Go to [discord.com/developers/applications](https://discord.com/developers/applications)
-+2. Click "New Application" and name it (e.g., "Goose Assistant")
-+
-+### 2. Create Bot
-+1. Go to "Bot" section
-+2. Click "Add Bot"
-+3. Copy the bot token and set as `GOOSE_DISCORD_BOT_TOKEN`
-+4. Enable "Message Content Intent"
-+
-+### 3. Get Your User ID
-+1. Enable Developer Mode in Discord (User Settings ‚Üí Advanced ‚Üí Developer Mode)
-+2. Right-click your username and "Copy ID"
-+3. Set as `GOOSE_DISCORD_USER_ID`
-+
-+### 4. Invite Bot
-+1. Go to "OAuth2" ‚Üí "URL Generator"
-+2. Select scopes: `bot`
-+3. Select permissions: `Send Messages`, `Read Messages`, `Read Message History`
-+4. Use generated URL to invite bot to your server (or just DM it directly)
-+
-+## How It Works
-+
-+### üìä **Intelligence Pipeline**
-+
-+1. **Context Detection**: When you step away, determines what type of input Goose needs
-+2. **LLM Summarization**: Calls your configured LLM to summarize the conversation
-+3. **Response Generation**: LLM pre-generates a helpful fallback response  
-+4. **Rich Notification**: Sends structured notification with summary and preview
-+5. **Reply Listening**: Monitors for your replies via DM and injects them into the conversation
-+
-+### üîÑ **Adaptive Timing**
-+
-+```
-+First ping: 5 minutes (or your configured timeout)
-+‚îú‚îÄ User responsive history: Continue with 5-minute intervals
-+‚îî‚îÄ User ignoring notifications: Switch to 1-minute pings, skip second warning
-+
-+Fallback execution: Additional 5 minutes after first ping
-+```
-+
-+### üéØ **Smart Filtering**
-+
-+- **Tool Confirmations**: Auto-approved, no notification sent
-+- **Next Task**: "Goose completed authentication setup and is ready for the next task"  
-+- **Clarification**: "Goose needs you to specify which database to connect to"
-+
-+## Example Notifications
-+
-+### **Slack Message**
-+```
-+ü¶Ü Goose Notification
-+
-+Goose needs you to specify which authentication method to implement for the user login system.
-+
-+*Suggested response:*
-+```
-+Use OAuth 2.0 with JWT tokens for secure authentication
-+```
-+
-+‚è≥ Waiting for your reply
-+```
-+
-+### **Discord Embed**
-+```
-+ü¶Ü Goose Notification
-+Goose needs you to choose between REST API or GraphQL for the data layer implementation.
-+
-+Suggested Response:
-+Use GraphQL for more flexible queries and better type safety
-+
-+‚ùì Waiting for your reply
-+```
-+
-+## Customization
-+
-+### **Prompt Templates**
-+
-+Edit the templates in `crates/goose-cli/prompts/`:
-+
-+#### `notification_summary.md`
-+```markdown
-+You are summarizing a conversation for a notification. The user has stepped away and needs a brief summary of what Goose (an AI coding assistant) is waiting for.
-+
-+Recent conversation:
-+{{ messages }}
-+
-+Current status: {{ wait_type }}
-+
-+Provide a brief, clear summary (max 2 sentences) of what Goose needs from the user.
-+```
-+
-+#### `notification_response.md`
-+```markdown
-+You are generating a helpful response for a user who is away from their computer.
-+
-+Recent conversation:
-+{{ messages }}
-+
-+What Goose is waiting for: {{ summary }}
-+
-+Generate a reasonable response that would help Goose continue productively.
-+```
-+
-+## Security & Best Practices
-+
-+### **üîê Token Security**
-+
-+**Critical:** Keep your bot tokens secure and never commit them to version control!
-+
-+#### **Environment File Method (Recommended)**
-+Create a `.env` file in your project root (add to `.gitignore`):
-+```bash
-+# .env
-+GOOSE_NOTIFICATIONS_ENABLED=true
-+GOOSE_SLACK_BOT_TOKEN=xoxb-your-bot-token
-+GOOSE_SLACK_APP_TOKEN=xapp-your-app-token
-+GOOSE_DISCORD_BOT_TOKEN=your-discord-bot-token
-+```
-+
-+Load it in your shell:
-+```bash
-+source .env
-+# or use: export $(cat .env | xargs)
-+```
-+
-+#### **System Keychain (macOS/Linux)**
-+Store tokens in your system keychain:
-+```bash
-+# macOS Keychain
-+security add-generic-password -a "goose-slack" -s "slack-bot-token" -w "xoxb-your-token"
-+export GOOSE_SLACK_BOT_TOKEN=$(security find-generic-password -a "goose-slack" -s "slack-bot-token" -w)
-+
-+# Linux with pass
-+pass insert goose/slack-bot-token
-+export GOOSE_SLACK_BOT_TOKEN=$(pass goose/slack-bot-token)
-+```
-+
-+#### **CI/CD Secrets**
-+For automated environments, use secure secret management:
-+- **GitHub Actions**: Repository secrets
-+- **Docker**: Docker secrets or environment files
-+- **Production**: HashiCorp Vault, AWS Secrets Manager, etc.
-+
-+### **üîí Network Security**
-+
-+- **Timeouts**: 10-second timeout on all LLM calls
-+- **Input Validation**: All tokens validated at startup
-+- **Connection Cleanup**: Graceful shutdown of all connections
-+
-+### **üë• Access Control**
-+
-+- **Slack**: Only DMs to your bot are processed (channel mentions ignored)
-+- **Discord**: Only configured user ID can trigger notifications
-+- **Reply Filtering**: Bot ignores its own messages and other bots
-+
-+### **üìä Privacy Considerations**
-+
-+- **History Tracking**: Only notification stats stored (no message content)
-+- **Logging**: No sensitive data logged (tokens redacted in output)
-+
-+## Performance & Limits
-+
-+- **Connection Pooling**: Persistent WebSocket connections for real-time replies
-+- **Message Truncation**: Automatic handling of platform character limits
-+- **Timeout Protection**: 10-second timeout on all external API calls
-+
-+### **Platform Limits**
-+- **Slack**: 3,000 characters per block, handled automatically
-+- **Discord**: 4,096 characters per embed, handled automatically  
-+- **LLM**: Configurable context window (default: last 10 messages)
-+
-+## Testing
-+
-+Run the notification system tests:
-+
-+```bash
-+cargo test --features notifications notifier
-+```
-+
-+Test with a simple script:
-+```bash
-+# Set your environment variables
-+source examples/test_notifications.sh
-+
-+# Run Goose with notifications enabled
-+cargo run --features notifications
-+```
-+
-+## Troubleshooting
-+
-+### Common Issues
-+
-+**"No notifications sent"**
-+- Check `GOOSE_NOTIFICATIONS_ENABLED=true`
-+- Verify at least one provider is configured with tokens
-+- Ensure feature flag: `cargo build --features notifications`
-+
-+**"Slack Socket Mode connection failed"**
-+- Verify app token starts with `xapp-`
-+- Check Socket Mode is enabled in app settings
-+- Ensure bot is installed in workspace
-+
-+**"Discord DM failed"**
-+- Verify bot token is correct
-+- Check user ID is a valid numeric string
-+- Ensure bot has DM permissions with user
-+
-+**"LLM summarization failed"**
-+- Check that Goose can connect to your configured LLM provider
-+- Verify prompt templates exist and are readable
-+- Check logs for specific LLM errors
-+
-+### Debug Mode
-+
-+Enable detailed logging:
-+```bash
-+export RUST_LOG=debug
-+export GOOSE_NOTIFICATIONS_DEBUG=true
-+```
-+
-+### Test Configuration
-+
-+Basic connection test:
-+```bash
-+# Test Slack
-+curl -H "Authorization: Bearer $GOOSE_SLACK_BOT_TOKEN" \
-+     -H "Content-Type: application/json" \
-+     -X POST https://slack.com/api/auth.test
-+
-+# Test Discord  
-+curl -H "Authorization: Bot $GOOSE_DISCORD_BOT_TOKEN" \
-+     -X GET https://discord.com/api/users/@me
-+```
-+
-+## Architecture
-+
-+The notification system consists of several key components:
-+
-+- **`NotificationIntelligence`**: LLM-powered context generation and response creation
-+- **`NotificationHistory`**: Adaptive timeout and behavior tracking  
-+- **`NotificationProvider`**: Trait for implementing different messaging platforms
-+- **`SlackProvider`**: Full Socket Mode implementation with rich blocks
-+- **`DiscordProvider`**: Serenity-based bot with rich embeds and DM handling
-+- **`MessageInjection`**: Queue-based system for processing replies
-+
-+This creates a truly intelligent, production-ready notification system that understands context, learns from your behavior, provides actionable information, and gracefully handles failures.
-\ No newline at end of file
-diff --git a/crates/goose-cli/prompts/notification_response.md b/crates/goose-cli/prompts/notification_response.md
-new file mode 100644
-index 0000000000..8eb89ac415
---- /dev/null
-+++ b/crates/goose-cli/prompts/notification_response.md
-@@ -0,0 +1,14 @@
-+You are generating a helpful response for a user who is away from their computer. Goose (an AI coding assistant) is waiting for input.
-+
-+Recent conversation:
-+{{ messages }}
-+
-+What Goose is waiting for: {{ summary }}
-+
-+Generate a reasonable response that would help Goose continue productively. Be specific and actionable. The response should be what the user would likely say to move the task forward.
-+
-+Important guidelines:
-+- If Goose completed a task and is waiting for the next instruction, suggest a logical next step
-+- If Goose is asking for clarification, provide a reasonable default choice
-+- Keep the response concise and action-oriented
-+- Write as if you are the user giving Goose its next instruction 
-\ No newline at end of file
-diff --git a/crates/goose-cli/prompts/notification_summary.md b/crates/goose-cli/prompts/notification_summary.md
-new file mode 100644
-index 0000000000..7b84863f0f
---- /dev/null
-+++ b/crates/goose-cli/prompts/notification_summary.md
-@@ -0,0 +1,8 @@
-+You are summarizing a conversation for a notification. The user has stepped away and needs a brief summary of what Goose (an AI coding assistant) is waiting for.
-+
-+Recent conversation:
-+{{ messages }}
-+
-+Current status: {{ wait_type }}
-+
-+Provide a brief, clear summary (max 2 sentences) of what Goose needs from the user. Be specific about what decision or information is needed. 
-\ No newline at end of file
-diff --git a/crates/goose-cli/src/cli.rs b/crates/goose-cli/src/cli.rs
-index 3a8eb17fde..48f40b191b 100644
---- a/crates/goose-cli/src/cli.rs
-+++ b/crates/goose-cli/src/cli.rs
-@@ -624,27 +624,27 @@ enum Command {
-     /// Update the Goose CLI version
-     #[command(about = "Update the goose CLI version")]
-     Update {
--        /// Update to canary version
--        #[arg(
--            short,
--            long,
--            help = "Update to canary version",
--            long_help = "Update to the latest canary version of the goose CLI, otherwise updates to the latest stable version."
--        )]
-+        /// Update to the canary/nightly channel
-+        #[arg(long, help = "Update to the canary/nightly channel")]
-         canary: bool,
- 
--        /// Enforce to re-configure Goose during update
--        #[arg(short, long, help = "Enforce to re-configure goose during update")]
-+        /// Run configuration after update
-+        #[arg(long, help = "Run configuration after update")]
-         reconfigure: bool,
-     },
- 
--    /// Evaluate system configuration across a range of practical tasks
--    #[command(about = "Evaluate system configuration across a range of practical tasks")]
-+    /// Benchmark agent performance
-+    #[command(about = "Benchmark agent performance", visible_alias = "bench")]
-     Bench {
-         #[command(subcommand)]
-         cmd: BenchCommand,
-     },
- 
-+    /// Check notification system status
-+    #[cfg(feature = "notifications")]
-+    #[command(about = "Check notification system status", visible_alias = "notify")]
-+    Notifications {},
-+
-     /// Start a web server with a chat interface
-     #[command(about = "Experimental: Start a web server with a chat interface")]
-     Web {
-@@ -1008,6 +1008,11 @@ pub async fn cli() -> Result<()> {
-             }
-             return Ok(());
-         }
-+        #[cfg(feature = "notifications")]
-+        Some(Command::Notifications {}) => {
-+            crate::commands::notification::handle_notifications().await?;
-+            return Ok(());
-+        }
-         Some(Command::Recipe { command }) => {
-             match command {
-                 RecipeCommand::Validate { recipe_name } => {
-diff --git a/crates/goose-cli/src/commands/mod.rs b/crates/goose-cli/src/commands/mod.rs
-index 72ce9be243..661fc9f754 100644
---- a/crates/goose-cli/src/commands/mod.rs
-+++ b/crates/goose-cli/src/commands/mod.rs
-@@ -2,6 +2,8 @@ pub mod bench;
- pub mod configure;
- pub mod info;
- pub mod mcp;
-+#[cfg(feature = "notifications")]
-+pub mod notification;
- pub mod project;
- pub mod recipe;
- pub mod schedule;
-diff --git a/crates/goose-cli/src/commands/notification.rs b/crates/goose-cli/src/commands/notification.rs
-new file mode 100644
-index 0000000000..81c5338e68
---- /dev/null
-+++ b/crates/goose-cli/src/commands/notification.rs
-@@ -0,0 +1,319 @@
-+use anyhow::Result;
-+use crate::notifier::Notifier;
-+
-+pub async fn handle_notifications() -> Result<()> {
-+    println!("üîî Goose Notification System Status\n");
-+    
-+    // Validate configuration
-+    match Notifier::validate_config() {
-+        Ok(_) => println!("‚úÖ Configuration is valid"),
-+        Err(e) => {
-+            println!("‚ùå Configuration issues found:");
-+            println!("{}", e);
-+            return Ok(());
-+        }
-+    }
-+    
-+    // Check if enabled
-+    let enabled = std::env::var("GOOSE_NOTIFICATIONS_ENABLED")
-+        .ok()
-+        .and_then(|v| v.parse::<bool>().ok())
-+        .unwrap_or(false);
-+    
-+    if !enabled {
-+        println!("üîï Notifications are disabled");
-+        println!("   Set GOOSE_NOTIFICATIONS_ENABLED=true to enable");
-+        return Ok(());
-+    }
-+    
-+    // Show provider status
-+    let slack_configured = std::env::var("GOOSE_SLACK_BOT_TOKEN").is_ok();
-+    let discord_configured = std::env::var("GOOSE_DISCORD_BOT_TOKEN").is_ok();
-+    
-+    println!("üì± Providers:");
-+    if slack_configured {
-+        println!("   ‚úÖ Slack (Socket Mode)");
-+    }
-+    if discord_configured {
-+        println!("   ‚úÖ Discord (Bot + DM)");
-+    }
-+    if !slack_configured && !discord_configured {
-+        println!("   ‚ùå No providers configured");
-+    }
-+    
-+    // Show settings
-+    let ping_timeout = std::env::var("GOOSE_PING_TIMEOUT").unwrap_or("300".to_string());
-+    let fallback_timeout = std::env::var("GOOSE_FALLBACK_TIMEOUT").unwrap_or("300".to_string());
-+    
-+    println!("‚öôÔ∏è  Settings:");
-+    println!("   Ping timeout: {}s", ping_timeout);
-+    println!("   Fallback timeout: {}s", fallback_timeout);
-+    
-+    // Check prompt templates
-+    let prompts_dir = std::env::var("GOOSE_PROMPTS_DIR")
-+        .unwrap_or_else(|_| "crates/goose-cli/prompts".to_string());
-+    
-+    let summary_exists = std::path::Path::new(&prompts_dir).join("notification_summary.md").exists();
-+    let response_exists = std::path::Path::new(&prompts_dir).join("notification_response.md").exists();
-+    
-+    println!("üìù Templates:");
-+    println!("   Summary: {}", if summary_exists { "‚úÖ" } else { "‚ùå" });
-+    println!("   Response: {}", if response_exists { "‚úÖ" } else { "‚ùå" });
-+    
-+    println!("\n‚ÑπÔ∏è  Use '/notifications' in interactive mode for runtime status");
-+    
-+    Ok(())
-+}
-+
-+#[cfg(test)]
-+mod tests {
-+    use super::*;
-+    use std::env;
-+    use std::fs;
-+    use tempfile::TempDir;
-+
-+    /// Helper to capture stdout output for testing
-+    struct OutputCapture {
-+        // We'll use a simple approach since we can't easily capture stdout in tests
-+        // This is more of a smoke test to ensure no panics
-+    }
-+
-+    #[tokio::test]
-+    async fn test_handle_notifications_disabled() {
-+        // Set notifications as disabled
-+        env::set_var("GOOSE_NOTIFICATIONS_ENABLED", "false");
-+        
-+        // Should not panic and should return Ok
-+        let result = handle_notifications().await;
-+        assert!(result.is_ok());
-+        
-+        // Clean up
-+        env::remove_var("GOOSE_NOTIFICATIONS_ENABLED");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_handle_notifications_no_environment() {
-+        // Remove all notification environment variables
-+        env::remove_var("GOOSE_NOTIFICATIONS_ENABLED");
-+        env::remove_var("GOOSE_SLACK_BOT_TOKEN");
-+        env::remove_var("GOOSE_DISCORD_BOT_TOKEN");
-+        
-+        // Should handle gracefully
-+        let result = handle_notifications().await;
-+        assert!(result.is_ok());
-+    }
-+
-+    #[tokio::test]
-+    async fn test_handle_notifications_valid_config() {
-+        // Set up valid configuration
-+        env::set_var("GOOSE_NOTIFICATIONS_ENABLED", "true");
-+        env::set_var("GOOSE_SLACK_BOT_TOKEN", "xoxb-test-token");
-+        env::set_var("GOOSE_SLACK_APP_TOKEN", "xapp-test-token");
-+        
-+        // Create temporary prompts directory
-+        let temp_dir = TempDir::new().unwrap();
-+        let prompts_dir = temp_dir.path();
-+        env::set_var("GOOSE_PROMPTS_DIR", prompts_dir.to_str().unwrap());
-+        
-+        // Create mock prompt files
-+        fs::write(prompts_dir.join("notification_summary.md"), "Mock summary template").unwrap();
-+        fs::write(prompts_dir.join("notification_response.md"), "Mock response template").unwrap();
-+        
-+        // Should handle valid configuration without errors
-+        let result = handle_notifications().await;
-+        assert!(result.is_ok());
-+        
-+        // Clean up
-+        env::remove_var("GOOSE_NOTIFICATIONS_ENABLED");
-+        env::remove_var("GOOSE_SLACK_BOT_TOKEN");
-+        env::remove_var("GOOSE_SLACK_APP_TOKEN");
-+        env::remove_var("GOOSE_PROMPTS_DIR");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_handle_notifications_invalid_slack_config() {
-+        // Set up invalid Slack configuration
-+        env::set_var("GOOSE_NOTIFICATIONS_ENABLED", "true");
-+        env::set_var("GOOSE_SLACK_BOT_TOKEN", "invalid-token-format");
-+        env::set_var("GOOSE_SLACK_APP_TOKEN", "xapp-test-token");
-+        
-+        // Should return Ok but show validation errors
-+        let result = handle_notifications().await;
-+        assert!(result.is_ok());
-+        
-+        // Clean up
-+        env::remove_var("GOOSE_NOTIFICATIONS_ENABLED");
-+        env::remove_var("GOOSE_SLACK_BOT_TOKEN");
-+        env::remove_var("GOOSE_SLACK_APP_TOKEN");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_handle_notifications_invalid_discord_config() {
-+        // Set up invalid Discord configuration
-+        env::set_var("GOOSE_NOTIFICATIONS_ENABLED", "true");
-+        env::set_var("GOOSE_DISCORD_BOT_TOKEN", "valid-token");
-+        env::set_var("GOOSE_DISCORD_USER_ID", "not-a-number");
-+        
-+        // Should return Ok but show validation errors
-+        let result = handle_notifications().await;
-+        assert!(result.is_ok());
-+        
-+        // Clean up
-+        env::remove_var("GOOSE_NOTIFICATIONS_ENABLED");
-+        env::remove_var("GOOSE_DISCORD_BOT_TOKEN");
-+        env::remove_var("GOOSE_DISCORD_USER_ID");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_handle_notifications_missing_templates() {
-+        // Set up valid tokens but missing templates
-+        env::set_var("GOOSE_NOTIFICATIONS_ENABLED", "true");
-+        env::set_var("GOOSE_SLACK_BOT_TOKEN", "xoxb-test-token");
-+        env::set_var("GOOSE_SLACK_APP_TOKEN", "xapp-test-token");
-+        
-+        // Create temporary directory without template files
-+        let temp_dir = TempDir::new().unwrap();
-+        env::set_var("GOOSE_PROMPTS_DIR", temp_dir.path().to_str().unwrap());
-+        
-+        // Should handle missing templates gracefully
-+        let result = handle_notifications().await;
-+        assert!(result.is_ok());
-+        
-+        // Clean up
-+        env::remove_var("GOOSE_NOTIFICATIONS_ENABLED");
-+        env::remove_var("GOOSE_SLACK_BOT_TOKEN");
-+        env::remove_var("GOOSE_SLACK_APP_TOKEN");
-+        env::remove_var("GOOSE_PROMPTS_DIR");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_handle_notifications_custom_timeouts() {
-+        // Set up configuration with custom timeouts
-+        env::set_var("GOOSE_NOTIFICATIONS_ENABLED", "true");
-+        env::set_var("GOOSE_SLACK_BOT_TOKEN", "xoxb-test-token");
-+        env::set_var("GOOSE_SLACK_APP_TOKEN", "xapp-test-token");
-+        env::set_var("GOOSE_PING_TIMEOUT", "120");
-+        env::set_var("GOOSE_FALLBACK_TIMEOUT", "600");
-+        
-+        // Should handle custom timeouts
-+        let result = handle_notifications().await;
-+        assert!(result.is_ok());
-+        
-+        // Clean up
-+        env::remove_var("GOOSE_NOTIFICATIONS_ENABLED");
-+        env::remove_var("GOOSE_SLACK_BOT_TOKEN");
-+        env::remove_var("GOOSE_SLACK_APP_TOKEN");
-+        env::remove_var("GOOSE_PING_TIMEOUT");
-+        env::remove_var("GOOSE_FALLBACK_TIMEOUT");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_handle_notifications_both_providers() {
-+        // Set up both Slack and Discord
-+        env::set_var("GOOSE_NOTIFICATIONS_ENABLED", "true");
-+        env::set_var("GOOSE_SLACK_BOT_TOKEN", "xoxb-test-token");
-+        env::set_var("GOOSE_SLACK_APP_TOKEN", "xapp-test-token");
-+        env::set_var("GOOSE_DISCORD_BOT_TOKEN", "discord-bot-token");
-+        env::set_var("GOOSE_DISCORD_USER_ID", "123456789");
-+        
-+        // Should handle both providers
-+        let result = handle_notifications().await;
-+        assert!(result.is_ok());
-+        
-+        // Clean up
-+        env::remove_var("GOOSE_NOTIFICATIONS_ENABLED");
-+        env::remove_var("GOOSE_SLACK_BOT_TOKEN");
-+        env::remove_var("GOOSE_SLACK_APP_TOKEN");
-+        env::remove_var("GOOSE_DISCORD_BOT_TOKEN");
-+        env::remove_var("GOOSE_DISCORD_USER_ID");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_handle_notifications_edge_cases() {
-+        // Test with unusual but valid values
-+        env::set_var("GOOSE_NOTIFICATIONS_ENABLED", "TRUE"); // Uppercase
-+        env::set_var("GOOSE_SLACK_BOT_TOKEN", "xoxb-test-token");
-+        env::set_var("GOOSE_SLACK_APP_TOKEN", "xapp-test-token");
-+        env::set_var("GOOSE_PING_TIMEOUT", "0"); // Zero timeout
-+        env::set_var("GOOSE_FALLBACK_TIMEOUT", "999999"); // Very large timeout
-+        
-+        // Should handle edge cases gracefully
-+        let result = handle_notifications().await;
-+        assert!(result.is_ok());
-+        
-+        // Clean up
-+        env::remove_var("GOOSE_NOTIFICATIONS_ENABLED");
-+        env::remove_var("GOOSE_SLACK_BOT_TOKEN");
-+        env::remove_var("GOOSE_SLACK_APP_TOKEN");
-+        env::remove_var("GOOSE_PING_TIMEOUT");
-+        env::remove_var("GOOSE_FALLBACK_TIMEOUT");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_handle_notifications_invalid_timeout_format() {
-+        // Set up with invalid timeout formats
-+        env::set_var("GOOSE_NOTIFICATIONS_ENABLED", "true");
-+        env::set_var("GOOSE_SLACK_BOT_TOKEN", "xoxb-test-token");
-+        env::set_var("GOOSE_SLACK_APP_TOKEN", "xapp-test-token");
-+        env::set_var("GOOSE_PING_TIMEOUT", "not-a-number");
-+        env::set_var("GOOSE_FALLBACK_TIMEOUT", "also-not-a-number");
-+        
-+        // Should fall back to defaults and not error
-+        let result = handle_notifications().await;
-+        assert!(result.is_ok());
-+        
-+        // Clean up
-+        env::remove_var("GOOSE_NOTIFICATIONS_ENABLED");
-+        env::remove_var("GOOSE_SLACK_BOT_TOKEN");
-+        env::remove_var("GOOSE_SLACK_APP_TOKEN");
-+        env::remove_var("GOOSE_PING_TIMEOUT");
-+        env::remove_var("GOOSE_FALLBACK_TIMEOUT");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_handle_notifications_concurrent_calls() {
-+        // Set up valid configuration
-+        env::set_var("GOOSE_NOTIFICATIONS_ENABLED", "true");
-+        env::set_var("GOOSE_SLACK_BOT_TOKEN", "xoxb-test-token");
-+        env::set_var("GOOSE_SLACK_APP_TOKEN", "xapp-test-token");
-+        
-+        // Call handle_notifications concurrently
-+        let futures = (0..5).map(|_| handle_notifications());
-+        let results: Vec<_> = futures::future::join_all(futures).await;
-+        
-+        // All calls should succeed
-+        for result in results {
-+            assert!(result.is_ok());
-+        }
-+        
-+        // Clean up
-+        env::remove_var("GOOSE_NOTIFICATIONS_ENABLED");
-+        env::remove_var("GOOSE_SLACK_BOT_TOKEN");
-+        env::remove_var("GOOSE_SLACK_APP_TOKEN");
-+    }
-+
-+    #[test]
-+    fn test_environment_isolation() {
-+        // Store original environment state
-+        let original_enabled = env::var("GOOSE_NOTIFICATIONS_ENABLED").ok();
-+        let original_slack_token = env::var("GOOSE_SLACK_BOT_TOKEN").ok();
-+        
-+        // Modify environment
-+        env::set_var("GOOSE_NOTIFICATIONS_ENABLED", "test-value");
-+        env::set_var("GOOSE_SLACK_BOT_TOKEN", "test-token");
-+        
-+        // Verify changes
-+        assert_eq!(env::var("GOOSE_NOTIFICATIONS_ENABLED").unwrap(), "test-value");
-+        assert_eq!(env::var("GOOSE_SLACK_BOT_TOKEN").unwrap(), "test-token");
-+        
-+        // Restore original state
-+        match original_enabled {
-+            Some(value) => env::set_var("GOOSE_NOTIFICATIONS_ENABLED", value),
-+            None => env::remove_var("GOOSE_NOTIFICATIONS_ENABLED"),
-+        }
-+        match original_slack_token {
-+            Some(value) => env::set_var("GOOSE_SLACK_BOT_TOKEN", value),
-+            None => env::remove_var("GOOSE_SLACK_BOT_TOKEN"),
-+        }
-+    }
-+} 
-\ No newline at end of file
-diff --git a/crates/goose-cli/src/lib.rs b/crates/goose-cli/src/lib.rs
-index 68f2357f5e..04d913b12a 100644
---- a/crates/goose-cli/src/lib.rs
-+++ b/crates/goose-cli/src/lib.rs
-@@ -3,6 +3,10 @@ use once_cell::sync::Lazy;
- pub mod cli;
- pub mod commands;
- pub mod logging;
-+#[cfg(feature = "notifications")]
-+pub mod notifier;
-+#[cfg(not(feature = "notifications"))]
-+mod notifier;
- pub mod project_tracker;
- pub mod recipes;
- pub mod session;
-diff --git a/crates/goose-cli/src/notifier/history.rs b/crates/goose-cli/src/notifier/history.rs
-new file mode 100644
-index 0000000000..cfba3cfc86
---- /dev/null
-+++ b/crates/goose-cli/src/notifier/history.rs
-@@ -0,0 +1,207 @@
-+//! History module for tracking notification patterns and adapting behavior
-+
-+use std::collections::VecDeque;
-+use tokio::time::Instant;
-+
-+use super::intelligence::WaitType;
-+
-+/// Maximum number of notifications to keep in history
-+const MAX_HISTORY_SIZE: usize = 20;
-+
-+/// Record of a single notification
-+#[derive(Debug, Clone)]
-+pub struct NotificationRecord {
-+    /// When the notification was sent
-+    pub timestamp: Instant,
-+    /// Whether the user responded to this notification
-+    pub was_answered: bool,
-+    /// Type of wait state
-+    pub wait_type: WaitType,
-+    /// Summary that was sent
-+    pub summary: String,
-+}
-+
-+/// Tracks notification history for adaptive behavior
-+#[derive(Debug)]
-+pub struct NotificationHistory {
-+    /// Recent notification records
-+    recent_notifications: VecDeque<NotificationRecord>,
-+    /// Count of consecutive unanswered notifications
-+    unanswered_streak: u32,
-+}
-+
-+impl NotificationHistory {
-+    /// Create a new notification history
-+    pub fn new() -> Self {
-+        Self {
-+            recent_notifications: VecDeque::with_capacity(MAX_HISTORY_SIZE),
-+            unanswered_streak: 0,
-+        }
-+    }
-+
-+    /// Add a new notification record
-+    pub fn add_notification(&mut self, wait_type: WaitType, summary: String) -> NotificationRecord {
-+        let record = NotificationRecord {
-+            timestamp: Instant::now(),
-+            was_answered: false,
-+            wait_type,
-+            summary,
-+        };
-+
-+        self.recent_notifications.push_back(record.clone());
-+        
-+        // Maintain max size
-+        if self.recent_notifications.len() > MAX_HISTORY_SIZE {
-+            self.recent_notifications.pop_front();
-+        }
-+
-+        // Increment unanswered streak
-+        self.unanswered_streak += 1;
-+
-+        record
-+    }
-+
-+    /// Mark the last notification as answered
-+    pub fn mark_last_answered(&mut self) {
-+        if let Some(last) = self.recent_notifications.back_mut() {
-+            if !last.was_answered {
-+                last.was_answered = true;
-+                // Reset streak since user responded
-+                self.unanswered_streak = 0;
-+            }
-+        }
-+    }
-+
-+    /// Get the current unanswered streak
-+    pub fn get_unanswered_streak(&self) -> u32 {
-+        self.unanswered_streak
-+    }
-+
-+    /// Calculate the timeout based on history
-+    pub fn calculate_timeout(&self, base_timeout: u64) -> u64 {
-+        if self.unanswered_streak > 0 {
-+            // Reduce to 1 minute for subsequent notifications
-+            60
-+        } else {
-+            base_timeout
-+        }
-+    }
-+
-+    /// Determine if we should send a follow-up notification
-+    pub fn should_send_follow_up(&self) -> bool {
-+        // Only send follow-up if user has been responsive
-+        self.unanswered_streak == 0
-+    }
-+
-+    /// Get statistics about notification patterns
-+    pub fn get_stats(&self) -> NotificationStats {
-+        let total = self.recent_notifications.len();
-+        let answered = self
-+            .recent_notifications
-+            .iter()
-+            .filter(|r| r.was_answered)
-+            .count();
-+        
-+        let by_type = self
-+            .recent_notifications
-+            .iter()
-+            .fold(
-+                std::collections::HashMap::new(),
-+                |mut acc, record| {
-+                    let key = format!("{:?}", record.wait_type);
-+                    *acc.entry(key).or_insert(0) += 1;
-+                    acc
-+                },
-+            );
-+
-+        NotificationStats {
-+            total_sent: total,
-+            total_answered: answered,
-+            answer_rate: if total > 0 {
-+                (answered as f64 / total as f64)
-+            } else {
-+                0.0
-+            },
-+            current_streak: self.unanswered_streak,
-+            by_type,
-+        }
-+    }
-+
-+    /// Clean up old records (older than 24 hours)
-+    pub fn cleanup_old_records(&mut self) {
-+        let cutoff = Instant::now() - std::time::Duration::from_secs(86400); // 24 hours
-+        
-+        self.recent_notifications.retain(|record| {
-+            record.timestamp > cutoff
-+        });
-+    }
-+}
-+
-+/// Statistics about notification patterns
-+#[derive(Debug)]
-+pub struct NotificationStats {
-+    /// Total notifications sent
-+    pub total_sent: usize,
-+    /// Total notifications answered
-+    pub total_answered: usize,
-+    /// Answer rate (0.0 to 1.0)
-+    pub answer_rate: f64,
-+    /// Current unanswered streak
-+    pub current_streak: u32,
-+    /// Breakdown by wait type
-+    pub by_type: std::collections::HashMap<String, usize>,
-+}
-+
-+impl Default for NotificationHistory {
-+    fn default() -> Self {
-+        Self::new()
-+    }
-+}
-+
-+#[cfg(test)]
-+mod tests {
-+    use super::*;
-+
-+    #[test]
-+    fn test_notification_history() {
-+        let mut history = NotificationHistory::new();
-+        
-+        // Add first notification
-+        history.add_notification(WaitType::NextTask, "Test 1".to_string());
-+        assert_eq!(history.get_unanswered_streak(), 1);
-+        assert_eq!(history.calculate_timeout(300), 300); // First notification uses base timeout
-+        
-+        // Mark as answered
-+        history.mark_last_answered();
-+        assert_eq!(history.get_unanswered_streak(), 0);
-+        
-+        // Add unanswered notification
-+        history.add_notification(WaitType::UserReply, "Test 2".to_string());
-+        assert_eq!(history.get_unanswered_streak(), 1);
-+        
-+        // Second unanswered should reduce timeout
-+        history.add_notification(WaitType::NextTask, "Test 3".to_string());
-+        assert_eq!(history.get_unanswered_streak(), 2);
-+        assert_eq!(history.calculate_timeout(300), 60); // Reduced timeout
-+        
-+        // Should not send follow-up when streak > 0
-+        assert!(!history.should_send_follow_up());
-+    }
-+
-+    #[test]
-+    fn test_notification_stats() {
-+        let mut history = NotificationHistory::new();
-+        
-+        history.add_notification(WaitType::NextTask, "Test 1".to_string());
-+        history.mark_last_answered();
-+        
-+        history.add_notification(WaitType::UserReply, "Test 2".to_string());
-+        history.add_notification(WaitType::NextTask, "Test 3".to_string());
-+        
-+        let stats = history.get_stats();
-+        assert_eq!(stats.total_sent, 3);
-+        assert_eq!(stats.total_answered, 1);
-+        assert_eq!(stats.answer_rate, 1.0 / 3.0);
-+        assert_eq!(stats.current_streak, 2);
-+    }
-+} 
-\ No newline at end of file
-diff --git a/crates/goose-cli/src/notifier/intelligence.rs b/crates/goose-cli/src/notifier/intelligence.rs
-new file mode 100644
-index 0000000000..f16988e812
---- /dev/null
-+++ b/crates/goose-cli/src/notifier/intelligence.rs
-@@ -0,0 +1,689 @@
-+//! Intelligence module for generating smart notifications using LLM
-+
-+use anyhow::{anyhow, Result};
-+use goose::message::{Message, MessageContent};
-+use goose::providers::base::Provider;
-+use minijinja::{context, Environment};
-+use std::path::PathBuf;
-+use std::sync::Arc;
-+use tokio::fs;
-+use std::time::Duration;
-+use tokio::sync::Mutex;
-+
-+/// Types of wait states
-+#[derive(Debug, Clone)]
-+pub enum WaitType {
-+    UserInput,
-+    Confirmation,
-+    FileSelection,
-+    Other(String),
-+}
-+
-+impl std::fmt::Display for WaitType {
-+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-+        match self {
-+            WaitType::UserInput => write!(f, "user_input"),
-+            WaitType::Confirmation => write!(f, "confirmation"),
-+            WaitType::FileSelection => write!(f, "file_selection"),
-+            WaitType::Other(s) => write!(f, "{}", s),
-+        }
-+    }
-+}
-+
-+/// Context for intelligent notifications
-+#[derive(Debug)]
-+pub struct NotificationContext {
-+    pub wait_type: WaitType,
-+    pub summary: String,
-+}
-+
-+/// Handles LLM-based notification generation
-+pub struct NotificationIntelligence {
-+    /// LLM provider for generating summaries and responses
-+    provider: Arc<dyn Provider>,
-+    /// Template environment
-+    env: Environment<'static>,
-+    /// Path to prompts directory
-+    prompts_dir: PathBuf,
-+}
-+
-+impl NotificationIntelligence {
-+    /// Create a new intelligence handler
-+    pub fn new(provider: Arc<dyn Provider>, prompts_dir: PathBuf) -> Self {
-+        let env = Environment::new();
-+        
-+        Self {
-+            provider,
-+            env,
-+            prompts_dir,
-+        }
-+    }
-+
-+    /// Analyze messages and generate context
-+    pub async fn analyze_context(&self, messages: &[Message]) -> Result<NotificationContext> {
-+        let wait_type = self.detect_wait_type(messages);
-+        
-+        let summary = match self.summarize_context(messages, &wait_type).await {
-+            Ok(summary) => summary,
-+            Err(_) => self.generate_fallback_summary(&wait_type, messages),
-+        };
-+        
-+        Ok(NotificationContext { wait_type, summary })
-+    }
-+
-+    /// Generate a fallback response for timeout
-+    pub async fn generate_fallback_response(&self, context: &NotificationContext) -> Result<String> {
-+        match self.generate_response(&[], &context.wait_type, &context.summary).await {
-+            Ok(response) => Ok(response),
-+            Err(_) => Ok(self.generate_fallback_response_simple(&context.wait_type)),
-+        }
-+    }
-+
-+    /// Detect what type of input Goose is waiting for
-+    fn detect_wait_type(&self, messages: &[Message]) -> WaitType {
-+        if let Some(last_message) = messages.last() {
-+            let content = match &last_message.content {
-+                MessageContent::Text(text) => text.to_lowercase(),
-+                _ => return WaitType::Other("unknown".to_string()),
-+            };
-+
-+            if content.contains("confirm") || content.contains("yes/no") || content.contains("y/n") {
-+                WaitType::Confirmation
-+            } else if content.contains("file") || content.contains("path") {
-+                WaitType::FileSelection
-+            } else {
-+                WaitType::UserInput
-+            }
-+        } else {
-+            WaitType::UserInput
-+        }
-+    }
-+
-+    /// Summarize what Goose is waiting for
-+    async fn summarize_context(
-+        &self,
-+        messages: &[Message],
-+        wait_type: &WaitType,
-+    ) -> Result<String> {
-+        // Load template
-+        let template_content = self.load_template("notification_summary.md").await?;
-+        let template = self.env.template_from_str(&template_content)?;
-+
-+        // Render with context
-+        let prompt = template.render(context! {
-+            messages => Self::format_messages(messages),
-+            wait_type => wait_type.to_string(),
-+        })?;
-+
-+        // Call LLM with timeout
-+        let response = match tokio::time::timeout(
-+            tokio::time::Duration::from_secs(10),
-+            self.provider.complete(&prompt)
-+        ).await {
-+            Ok(Ok(response)) => response,
-+            Ok(Err(e)) => return Err(e),
-+            Err(_) => return Err(anyhow!("LLM call timed out")),
-+        };
-+        
-+        Ok(response.content.trim().to_string())
-+    }
-+
-+    /// Generate a default response for fallback
-+    async fn generate_response(
-+        &self,
-+        messages: &[Message],
-+        wait_type: &WaitType,
-+        summary: &str,
-+    ) -> Result<String> {
-+        // Load template
-+        let template_content = self.load_template("notification_response.md").await?;
-+        let template = self.env.template_from_str(&template_content)?;
-+
-+        // Render with context
-+        let prompt = template.render(context! {
-+            messages => Self::format_messages(messages),
-+            summary => summary,
-+            wait_type => wait_type.to_string(),
-+        })?;
-+
-+        // Call LLM with timeout
-+        let response = match tokio::time::timeout(
-+            tokio::time::Duration::from_secs(10),
-+            self.provider.complete(&prompt)
-+        ).await {
-+            Ok(Ok(response)) => response,
-+            Ok(Err(e)) => return Err(e),
-+            Err(_) => return Err(anyhow!("LLM call timed out")),
-+        };
-+        
-+        Ok(response.content.trim().to_string())
-+    }
-+
-+    /// Generate fallback summary when LLM fails
-+    fn generate_fallback_summary(&self, wait_type: &WaitType, messages: &[Message]) -> String {
-+        let context_hint = if let Some(last_msg) = messages.last() {
-+            match &last_msg.content {
-+                MessageContent::Text(text) => {
-+                    // Extract first line as context
-+                    text.lines().next().unwrap_or("").trim()
-+                }
-+                _ => "awaiting response",
-+            }
-+        } else {
-+            "awaiting response"
-+        };
-+
-+        match wait_type {
-+            WaitType::UserInput => format!("Goose needs your input: {}", context_hint),
-+            WaitType::Confirmation => format!("Goose needs confirmation: {}", context_hint),
-+            WaitType::FileSelection => format!("Goose needs a file selection: {}", context_hint),
-+            WaitType::Other(_) => format!("Goose is waiting: {}", context_hint),
-+        }
-+    }
-+
-+    /// Generate fallback response when LLM fails
-+    fn generate_fallback_response_simple(&self, wait_type: &WaitType) -> String {
-+        match wait_type {
-+            WaitType::UserInput => "I'll check back later. Please provide the requested input when you can.".to_string(),
-+            WaitType::Confirmation => "Please confirm when you're ready to proceed.".to_string(), 
-+            WaitType::FileSelection => "Please provide the file path when available.".to_string(),
-+            WaitType::Other(_) => "I'll continue once you provide the needed information.".to_string(),
-+        }
-+    }
-+
-+    /// Load a prompt template
-+    async fn load_template(&self, filename: &str) -> Result<String> {
-+        let path = self.prompts_dir.join(filename);
-+        fs::read_to_string(&path)
-+            .await
-+            .map_err(|e| anyhow!("Failed to load template {}: {}", path.display(), e))
-+    }
-+
-+    /// Format messages for prompt context
-+    fn format_messages(messages: &[Message]) -> String {
-+        messages
-+            .iter()
-+            .take(10) // Last 10 messages for context
-+            .map(|msg| {
-+                let role = if msg.is_user() { "User" } else { "Assistant" };
-+                match &msg.content {
-+                    MessageContent::Text(text) => format!("{}: {}", role, text),
-+                    _ => format!("{}: [non-text content]", role),
-+                }
-+            })
-+            .collect::<Vec<_>>()
-+            .join("\n")
-+    }
-+}
-+
-+#[cfg(test)]
-+mod tests {
-+    use super::*;
-+    use goose::providers::base::{Provider, CompletionResponse};
-+    use std::sync::atomic::{AtomicUsize, Ordering};
-+    use std::collections::HashMap;
-+    use tempfile::TempDir;
-+    use tokio::fs;
-+    use async_trait::async_trait;
-+
-+    /// Mock LLM provider for testing with configurable responses and failures
-+    struct MockLLMProvider {
-+        responses: Arc<Mutex<Vec<String>>>,
-+        call_count: Arc<AtomicUsize>,
-+        should_timeout: Arc<Mutex<bool>>,
-+        should_fail: Arc<Mutex<bool>>,
-+        delay: Option<Duration>,
-+    }
-+
-+    impl MockLLMProvider {
-+        fn new() -> Self {
-+            Self {
-+                responses: Arc::new(Mutex::new(Vec::new())),
-+                call_count: Arc::new(AtomicUsize::new(0)),
-+                should_timeout: Arc::new(Mutex::new(false)),
-+                should_fail: Arc::new(Mutex::new(false)),
-+                delay: None,
-+            }
-+        }
-+
-+        fn with_responses(responses: Vec<String>) -> Self {
-+            Self {
-+                responses: Arc::new(Mutex::new(responses)),
-+                call_count: Arc::new(AtomicUsize::new(0)),
-+                should_timeout: Arc::new(Mutex::new(false)),
-+                should_fail: Arc::new(Mutex::new(false)),
-+                delay: None,
-+            }
-+        }
-+
-+        fn with_delay(mut self, delay: Duration) -> Self {
-+            self.delay = Some(delay);
-+            self
-+        }
-+
-+        async fn set_should_timeout(&self, timeout: bool) {
-+            *self.should_timeout.lock().await = timeout;
-+        }
-+
-+        async fn set_should_fail(&self, fail: bool) {
-+            *self.should_fail.lock().await = fail;
-+        }
-+
-+        fn get_call_count(&self) -> usize {
-+            self.call_count.load(Ordering::SeqCst)
-+        }
-+    }
-+
-+    #[async_trait]
-+    impl Provider for MockLLMProvider {
-+        async fn complete(&self, prompt: &str) -> Result<CompletionResponse> {
-+            self.call_count.fetch_add(1, Ordering::SeqCst);
-+
-+            if let Some(delay) = self.delay {
-+                tokio::time::sleep(delay).await;
-+            }
-+
-+            if *self.should_timeout.lock().await {
-+                // Simulate infinite timeout
-+                tokio::time::sleep(Duration::from_secs(30)).await;
-+            }
-+
-+            if *self.should_fail.lock().await {
-+                return Err(anyhow!("Mock provider failure"));
-+            }
-+
-+            let mut responses = self.responses.lock().await;
-+            let response = if responses.is_empty() {
-+                format!("Default response for prompt: {}", prompt.chars().take(50).collect::<String>())
-+            } else {
-+                responses.remove(0)
-+            };
-+
-+            Ok(CompletionResponse {
-+                content: response,
-+                usage: None,
-+            })
-+        }
-+
-+        fn get_model(&self) -> String {
-+            "mock-gpt-5".to_string()
-+        }
-+
-+        fn as_any(&self) -> &dyn std::any::Any {
-+            self
-+        }
-+    }
-+
-+    async fn create_test_intelligence() -> (NotificationIntelligence, TempDir) {
-+        let temp_dir = TempDir::new().unwrap();
-+        let prompts_dir = temp_dir.path().to_path_buf();
-+
-+        // Create mock template files
-+        let summary_template = r#"
-+Summarize what Goose is waiting for based on:
-+
-+Messages: {{ messages }}
-+Wait type: {{ wait_type }}
-+
-+Provide a clear, brief summary.
-+"#;
-+
-+        let response_template = r#"
-+Generate a helpful response based on:
-+
-+Messages: {{ messages }}
-+Summary: {{ summary }}
-+Wait type: {{ wait_type }}
-+
-+Provide a reasonable next step.
-+"#;
-+
-+        fs::write(prompts_dir.join("notification_summary.md"), summary_template).await.unwrap();
-+        fs::write(prompts_dir.join("notification_response.md"), response_template).await.unwrap();
-+
-+        let provider = Arc::new(MockLLMProvider::new());
-+        let intelligence = NotificationIntelligence::new(provider, prompts_dir);
-+
-+        (intelligence, temp_dir)
-+    }
-+
-+    #[tokio::test]
-+    async fn test_detect_wait_type_confirmation() {
-+        let (intelligence, _temp_dir) = create_test_intelligence().await;
-+
-+        // Test confirmation patterns
-+        let test_cases = vec![
-+            ("Do you want to proceed? (y/n)", WaitType::Confirmation),
-+            ("Should I confirm this action?", WaitType::Confirmation),
-+            ("Are you sure you want to delete this file? yes/no", WaitType::Confirmation),
-+            ("Please confirm if this looks correct.", WaitType::Confirmation),
-+        ];
-+
-+        for (text, expected) in test_cases {
-+            let messages = vec![Message::assistant().with_text(text)];
-+            let wait_type = intelligence.detect_wait_type(&messages);
-+            assert!(matches!(wait_type, WaitType::Confirmation), 
-+                   "Failed for text: '{}', got: {:?}", text, wait_type);
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_detect_wait_type_file_selection() {
-+        let (intelligence, _temp_dir) = create_test_intelligence().await;
-+
-+        let test_cases = vec![
-+            ("Which file should I edit?", WaitType::FileSelection),
-+            ("Please provide the path to the configuration file.", WaitType::FileSelection),
-+            ("What's the full file path?", WaitType::FileSelection),
-+        ];
-+
-+        for (text, expected) in test_cases {
-+            let messages = vec![Message::assistant().with_text(text)];
-+            let wait_type = intelligence.detect_wait_type(&messages);
-+            assert!(matches!(wait_type, WaitType::FileSelection),
-+                   "Failed for text: '{}', got: {:?}", text, wait_type);
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_detect_wait_type_user_input() {
-+        let (intelligence, _temp_dir) = create_test_intelligence().await;
-+
-+        let test_cases = vec![
-+            ("What would you like me to do next?", WaitType::UserInput),
-+            ("I've completed the task. What's next?", WaitType::UserInput),
-+            ("How should I proceed?", WaitType::UserInput),
-+        ];
-+
-+        for (text, expected) in test_cases {
-+            let messages = vec![Message::assistant().with_text(text)];
-+            let wait_type = intelligence.detect_wait_type(&messages);
-+            assert!(matches!(wait_type, WaitType::UserInput),
-+                   "Failed for text: '{}', got: {:?}", text, wait_type);
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_detect_wait_type_edge_cases() {
-+        let (intelligence, _temp_dir) = create_test_intelligence().await;
-+
-+        // Empty messages
-+        let wait_type = intelligence.detect_wait_type(&[]);
-+        assert!(matches!(wait_type, WaitType::UserInput));
-+
-+        // Non-text message content
-+        let mut message = Message::assistant();
-+        message.content = goose::message::MessageContent::ToolRequest(
-+            goose::message::ToolRequest {
-+                id: "test".to_string(),
-+                name: "test_tool".to_string(),
-+                parameters: serde_json::Value::Null,
-+            }
-+        );
-+        let messages = vec![message];
-+        let wait_type = intelligence.detect_wait_type(&messages);
-+        assert!(matches!(wait_type, WaitType::Other(_)));
-+    }
-+
-+    #[tokio::test]
-+    async fn test_analyze_context_success() {
-+        let (mut intelligence, _temp_dir) = create_test_intelligence().await;
-+        
-+        // Set up provider with expected responses
-+        let provider = Arc::new(MockLLMProvider::with_responses(vec![
-+            "Goose needs to know which authentication method to implement.".to_string(),
-+        ]));
-+        intelligence.provider = provider;
-+
-+        let messages = vec![
-+            Message::user().with_text("Add authentication to the app"),
-+            Message::assistant().with_text("Which authentication method would you like to use?"),
-+        ];
-+
-+        let context = intelligence.analyze_context(&messages).await.unwrap();
-+
-+        assert!(matches!(context.wait_type, WaitType::UserInput));
-+        assert_eq!(context.summary, "Goose needs to know which authentication method to implement.");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_analyze_context_llm_failure() {
-+        let (mut intelligence, _temp_dir) = create_test_intelligence().await;
-+        
-+        // Set up provider to fail
-+        let provider = Arc::new(MockLLMProvider::new());
-+        provider.set_should_fail(true).await;
-+        intelligence.provider = provider;
-+
-+        let messages = vec![
-+            Message::assistant().with_text("Which file would you like me to edit?"),
-+        ];
-+
-+        let context = intelligence.analyze_context(&messages).await.unwrap();
-+
-+        // Should fall back to simple summary
-+        assert!(matches!(context.wait_type, WaitType::FileSelection));
-+        assert!(context.summary.contains("file"));
-+        assert!(context.summary.contains("Goose"));
-+    }
-+
-+    #[tokio::test]
-+    async fn test_analyze_context_llm_timeout() {
-+        let (mut intelligence, _temp_dir) = create_test_intelligence().await;
-+        
-+        // Set up provider to timeout
-+        let provider = Arc::new(MockLLMProvider::new().with_delay(Duration::from_secs(15)));
-+        intelligence.provider = provider;
-+
-+        let messages = vec![
-+            Message::assistant().with_text("What should I do next?"),
-+        ];
-+
-+        let start = std::time::Instant::now();
-+        let context = intelligence.analyze_context(&messages).await.unwrap();
-+        let elapsed = start.elapsed();
-+
-+        // Should timeout and fall back quickly
-+        assert!(elapsed < Duration::from_secs(12), "Took too long: {:?}", elapsed);
-+        assert!(context.summary.contains("Goose"));
-+    }
-+
-+    #[tokio::test]
-+    async fn test_generate_fallback_response_success() {
-+        let (mut intelligence, _temp_dir) = create_test_intelligence().await;
-+        
-+        let provider = Arc::new(MockLLMProvider::with_responses(vec![
-+            "Please provide more details about what you'd like me to do.".to_string(),
-+        ]));
-+        intelligence.provider = provider;
-+
-+        let context = NotificationContext {
-+            wait_type: WaitType::UserInput,
-+            summary: "Waiting for next instruction".to_string(),
-+        };
-+
-+        let response = intelligence.generate_fallback_response(&context).await.unwrap();
-+        assert_eq!(response, "Please provide more details about what you'd like me to do.");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_generate_fallback_response_llm_failure() {
-+        let (mut intelligence, _temp_dir) = create_test_intelligence().await;
-+        
-+        let provider = Arc::new(MockLLMProvider::new());
-+        provider.set_should_fail(true).await;
-+        intelligence.provider = provider;
-+
-+        let context = NotificationContext {
-+            wait_type: WaitType::Confirmation,
-+            summary: "Waiting for confirmation".to_string(),
-+        };
-+
-+        let response = intelligence.generate_fallback_response(&context).await.unwrap();
-+        assert_eq!(response, "Please confirm when you're ready to proceed.");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_fallback_summaries() {
-+        let (intelligence, _temp_dir) = create_test_intelligence().await;
-+
-+        let test_cases = vec![
-+            (WaitType::UserInput, "user input"),
-+            (WaitType::Confirmation, "confirmation"),
-+            (WaitType::FileSelection, "file selection"),
-+            (WaitType::Other("test".to_string()), "waiting"),
-+        ];
-+
-+        for (wait_type, expected_keyword) in test_cases {
-+            let messages = vec![Message::assistant().with_text("Test message for context")];
-+            let summary = intelligence.generate_fallback_summary(&wait_type, &messages);
-+            
-+            assert!(summary.contains("Goose"), "Summary should mention Goose: {}", summary);
-+            assert!(summary.contains(expected_keyword), 
-+                   "Summary should contain '{}': {}", expected_keyword, summary);
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_fallback_responses() {
-+        let (intelligence, _temp_dir) = create_test_intelligence().await;
-+
-+        let test_cases = vec![
-+            (WaitType::UserInput, "check back later"),
-+            (WaitType::Confirmation, "confirm when"),
-+            (WaitType::FileSelection, "file path"),
-+            (WaitType::Other("test".to_string()), "continue once"),
-+        ];
-+
-+        for (wait_type, expected_keyword) in test_cases {
-+            let response = intelligence.generate_fallback_response_simple(&wait_type);
-+            
-+            assert!(response.contains(expected_keyword), 
-+                   "Response should contain '{}': {}", expected_keyword, response);
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_template_loading_missing_file() {
-+        let temp_dir = TempDir::new().unwrap();
-+        let provider = Arc::new(MockLLMProvider::new());
-+        let intelligence = NotificationIntelligence::new(provider, temp_dir.path().to_path_buf());
-+
-+        let result = intelligence.load_template("nonexistent.md").await;
-+        assert!(result.is_err());
-+        assert!(result.unwrap_err().to_string().contains("Failed to load template"));
-+    }
-+
-+    #[tokio::test]
-+    async fn test_format_messages() {
-+        let messages = vec![
-+            Message::user().with_text("Hello"),
-+            Message::assistant().with_text("Hi there!"),
-+            Message::user().with_text("How are you?"),
-+        ];
-+
-+        let formatted = NotificationIntelligence::format_messages(&messages);
-+        
-+        assert!(formatted.contains("User: Hello"));
-+        assert!(formatted.contains("Assistant: Hi there!"));
-+        assert!(formatted.contains("User: How are you?"));
-+    }
-+
-+    #[tokio::test]
-+    async fn test_format_messages_limit() {
-+        // Create 15 messages
-+        let messages: Vec<Message> = (0..15)
-+            .map(|i| Message::user().with_text(&format!("Message {}", i)))
-+            .collect();
-+
-+        let formatted = NotificationIntelligence::format_messages(&messages);
-+        
-+        // Should only include last 10 messages
-+        assert!(formatted.contains("Message 5"), "Should start from message 5");
-+        assert!(!formatted.contains("Message 4"), "Should not include message 4");
-+        assert!(formatted.contains("Message 14"), "Should include last message");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_format_messages_non_text_content() {
-+        let mut message = Message::assistant();
-+        message.content = goose::message::MessageContent::ToolRequest(
-+            goose::message::ToolRequest {
-+                id: "test".to_string(),
-+                name: "test_tool".to_string(),
-+                parameters: serde_json::Value::Null,
-+            }
-+        );
-+        let messages = vec![message];
-+
-+        let formatted = NotificationIntelligence::format_messages(&messages);
-+        assert!(formatted.contains("[non-text content]"));
-+    }
-+
-+    #[tokio::test]
-+    async fn test_template_rendering_with_variables() {
-+        let (intelligence, _temp_dir) = create_test_intelligence().await;
-+
-+        let messages = vec![
-+            Message::user().with_text("Test user message"),
-+            Message::assistant().with_text("Test assistant response"),
-+        ];
-+
-+        // Test that the template system works with our variables
-+        let wait_type = WaitType::UserInput;
-+        let result = intelligence.summarize_context(&messages, &wait_type).await;
-+        
-+        // Should succeed with template rendering (even if LLM response is mock)
-+        assert!(result.is_ok());
-+    }
-+
-+    #[tokio::test]
-+    async fn test_concurrent_llm_calls() {
-+        let (mut intelligence, _temp_dir) = create_test_intelligence().await;
-+        
-+        let provider = Arc::new(MockLLMProvider::with_responses(vec![
-+            "Response 1".to_string(),
-+            "Response 2".to_string(),
-+            "Response 3".to_string(),
-+            "Response 4".to_string(),
-+        ]));
-+        intelligence.provider = provider.clone();
-+
-+        let messages = vec![Message::assistant().with_text("Test message")];
-+
-+        // Make multiple concurrent calls
-+        let futures = (0..4).map(|_| {
-+            intelligence.analyze_context(&messages)
-+        });
-+
-+        let results: Vec<_> = futures::future::join_all(futures).await;
-+
-+        // All should succeed
-+        for result in &results {
-+            assert!(result.is_ok());
-+        }
-+
-+        // Should have made 4 LLM calls
-+        assert_eq!(provider.get_call_count(), 4);
-+    }
-+
-+    #[tokio::test]
-+    async fn test_memory_efficiency_large_messages() {
-+        let (intelligence, _temp_dir) = create_test_intelligence().await;
-+
-+        // Create very large messages
-+        let large_text = "x".repeat(100_000);
-+        let messages: Vec<Message> = (0..50)
-+            .map(|_| Message::user().with_text(&large_text))
-+            .collect();
-+
-+        // Should handle gracefully and only use last 10 messages
-+        let formatted = NotificationIntelligence::format_messages(&messages);
-+        
-+        // Should be much smaller than total input due to 10-message limit
-+        assert!(formatted.len() < messages.len() * large_text.len() / 2);
-+        
-+        // Should still contain expected pattern
-+        assert!(formatted.contains("User:"));
-+    }
-+} 
-\ No newline at end of file
-diff --git a/crates/goose-cli/src/notifier/mod.rs b/crates/goose-cli/src/notifier/mod.rs
-new file mode 100644
-index 0000000000..1c0162a46e
---- /dev/null
-+++ b/crates/goose-cli/src/notifier/mod.rs
-@@ -0,0 +1,1030 @@
-+//! Notification system for sending timeout alerts via Slack, Discord, etc.
-+//! 
-+//! This module provides a framework for sending notifications when the user
-+//! is inactive for a specified timeout period, and listening for replies.
-+
-+pub mod history;
-+pub mod intelligence;
-+
-+#[cfg(feature = "notifications")]
-+pub mod providers;
-+
-+use anyhow::{anyhow, Result};
-+use goose::message::Message;
-+use goose::providers::base::Provider;
-+use std::path::PathBuf;
-+use std::sync::Arc;
-+use tokio::sync::{Mutex, mpsc};
-+use tokio::time::{Duration, Instant};
-+
-+use history::{NotificationHistory, NotificationRecord};
-+use intelligence::{NotificationContext, NotificationIntelligence, WaitType, determine_wait_type};
-+
-+#[cfg(feature = "notifications")]
-+pub use providers::{SlackProvider, DiscordProvider};
-+
-+/// Callback type for injecting messages into the session
-+pub type MessageInjectionCallback = Arc<dyn Fn(Message) -> futures::future::BoxFuture<'static, Result<()>> + Send + Sync>;
-+
-+/// Message received from a notification provider
-+#[derive(Debug, Clone)]
-+pub struct NotificationReply {
-+    pub provider: String,
-+    pub user_id: String,
-+    pub message: String,
-+    pub timestamp: Instant,
-+}
-+
-+/// Rich notification content
-+#[derive(Debug, Clone)]
-+pub struct RichNotification {
-+    /// Summary of what Goose needs
-+    pub summary: String,
-+    /// Preview of the fallback response
-+    pub fallback_preview: Option<String>,
-+    /// Wait type
-+    pub wait_type: WaitType,
-+}
-+
-+/// Notification provider trait for different services
-+#[async_trait::async_trait]
-+pub trait NotificationProvider: Send + Sync {
-+    /// Send a rich notification with summary and preview
-+    async fn send_rich(&self, notification: &RichNotification) -> Result<()>;
-+    
-+    /// Start listening for replies, sending them through the channel
-+    async fn start_listening(&self, reply_sender: mpsc::Sender<NotificationReply>) -> Result<()>;
-+    
-+    /// Get the provider name
-+    fn name(&self) -> &str;
-+}
-+
-+/// Notification configuration
-+#[derive(Debug, Clone)]
-+pub struct NotificationConfig {
-+    /// Timeout in seconds before sending first notification
-+    pub ping_timeout: u64,
-+    /// Additional timeout in seconds before taking fallback action
-+    pub fallback_timeout: u64,
-+    /// Whether to enable notifications
-+    pub enabled: bool,
-+    /// Path to prompts directory
-+    pub prompts_dir: PathBuf,
-+}
-+
-+impl Default for NotificationConfig {
-+    fn default() -> Self {
-+        Self {
-+            ping_timeout: 300, // 5 minutes
-+            fallback_timeout: 300, // Additional 5 minutes
-+            enabled: false,
-+            prompts_dir: PathBuf::from("crates/goose-cli/prompts"),
-+        }
-+    }
-+}
-+
-+/// Notifier manages the notification system
-+pub struct Notifier {
-+    providers: Vec<Box<dyn NotificationProvider>>,
-+    config: NotificationConfig,
-+    last_response_time: Arc<Mutex<Option<Instant>>>,
-+    last_user_input_time: Arc<Mutex<Option<Instant>>>,
-+    waiting_for_input: Arc<Mutex<bool>>,
-+    reply_receiver: Arc<Mutex<mpsc::Receiver<NotificationReply>>>,
-+    reply_sender: mpsc::Sender<NotificationReply>,
-+    history: Arc<Mutex<NotificationHistory>>,
-+    intelligence: Option<Arc<NotificationIntelligence>>,
-+    current_context: Arc<Mutex<Option<NotificationContext>>>,
-+    current_messages: Arc<Mutex<Vec<Message>>>,
-+    message_injection_callback: Option<MessageInjectionCallback>,
-+}
-+
-+impl Notifier {
-+    /// Create a new notifier with the given configuration
-+    pub fn new(config: NotificationConfig) -> Self {
-+        let (reply_sender, reply_receiver) = mpsc::channel(100);
-+        
-+        Self {
-+            providers: Vec::new(),
-+            config,
-+            last_response_time: Arc::new(Mutex::new(None)),
-+            last_user_input_time: Arc::new(Mutex::new(None)),
-+            waiting_for_input: Arc::new(Mutex::new(false)),
-+            reply_receiver: Arc::new(Mutex::new(reply_receiver)),
-+            reply_sender,
-+            history: Arc::new(Mutex::new(NotificationHistory::new())),
-+            intelligence: None,
-+            current_context: Arc::new(Mutex::new(None)),
-+            current_messages: Arc::new(Mutex::new(Vec::new())),
-+            message_injection_callback: None,
-+        }
-+    }
-+    
-+    /// Validate configuration and report issues
-+    pub fn validate_config() -> Result<()> {
-+        let mut issues = Vec::new();
-+        
-+        // Check if notifications are enabled
-+        if !std::env::var("GOOSE_NOTIFICATIONS_ENABLED")
-+            .ok()
-+            .and_then(|v| v.parse::<bool>().ok())
-+            .unwrap_or(false)
-+        {
-+            return Ok(()); // Not enabled, no validation needed
-+        }
-+        
-+        // Validate timeout values
-+        if let Ok(timeout) = std::env::var("GOOSE_PING_TIMEOUT") {
-+            if timeout.parse::<u64>().is_err() {
-+                issues.push("GOOSE_PING_TIMEOUT must be a valid number of seconds".to_string());
-+            }
-+        }
-+        
-+        if let Ok(timeout) = std::env::var("GOOSE_FALLBACK_TIMEOUT") {
-+            if timeout.parse::<u64>().is_err() {
-+                issues.push("GOOSE_FALLBACK_TIMEOUT must be a valid number of seconds".to_string());
-+            }
-+        }
-+        
-+        // Check provider configurations
-+        let slack_configured = std::env::var("GOOSE_SLACK_BOT_TOKEN").is_ok();
-+        let discord_configured = std::env::var("GOOSE_DISCORD_BOT_TOKEN").is_ok();
-+        
-+        if !slack_configured && !discord_configured {
-+            issues.push("No notification providers configured. Set GOOSE_SLACK_BOT_TOKEN or GOOSE_DISCORD_BOT_TOKEN".to_string());
-+        }
-+        
-+        // Validate Slack configuration
-+        if slack_configured {
-+            if !std::env::var("GOOSE_SLACK_APP_TOKEN").is_ok() {
-+                issues.push("GOOSE_SLACK_APP_TOKEN required for Slack notifications (Socket Mode)".to_string());
-+            }
-+            
-+            if let Ok(bot_token) = std::env::var("GOOSE_SLACK_BOT_TOKEN") {
-+                if !bot_token.starts_with("xoxb-") {
-+                    issues.push("GOOSE_SLACK_BOT_TOKEN should start with 'xoxb-'".to_string());
-+                }
-+            }
-+            
-+            if let Ok(app_token) = std::env::var("GOOSE_SLACK_APP_TOKEN") {
-+                if !app_token.starts_with("xapp-") {
-+                    issues.push("GOOSE_SLACK_APP_TOKEN should start with 'xapp-'".to_string());
-+                }
-+            }
-+        }
-+        
-+        // Validate Discord configuration  
-+        if discord_configured {
-+            if let Ok(user_id) = std::env::var("GOOSE_DISCORD_USER_ID") {
-+                if user_id.parse::<u64>().is_err() {
-+                    issues.push("GOOSE_DISCORD_USER_ID must be a valid Discord user ID (numeric)".to_string());
-+                }
-+            }
-+        }
-+        
-+        // Check prompts directory
-+        let prompts_dir = std::env::var("GOOSE_PROMPTS_DIR")
-+            .unwrap_or_else(|_| "crates/goose-cli/prompts".to_string());
-+        
-+        if !std::path::Path::new(&prompts_dir).exists() {
-+            issues.push(format!("Prompts directory not found: {}", prompts_dir));
-+        } else {
-+            // Check for required prompt files
-+            let summary_prompt = std::path::Path::new(&prompts_dir).join("notification_summary.md");
-+            let response_prompt = std::path::Path::new(&prompts_dir).join("notification_response.md");
-+            
-+            if !summary_prompt.exists() {
-+                issues.push(format!("Missing prompt template: {}", summary_prompt.display()));
-+            }
-+            if !response_prompt.exists() {
-+                issues.push(format!("Missing prompt template: {}", response_prompt.display()));
-+            }
-+        }
-+        
-+        if !issues.is_empty() {
-+            return Err(anyhow!("Notification configuration issues:\n{}", 
-+                issues.iter()
-+                    .map(|issue| format!("  ‚Ä¢ {}", issue))
-+                    .collect::<Vec<_>>()
-+                    .join("\n")
-+            ));
-+        }
-+        
-+        Ok(())
-+    }
-+    
-+    /// Set the LLM provider for intelligent notifications
-+    pub fn set_llm_provider(&mut self, provider: Arc<dyn Provider>) {
-+        self.intelligence = Some(Arc::new(NotificationIntelligence::new(
-+            provider,
-+            self.config.prompts_dir.clone(),
-+        )));
-+    }
-+    
-+    /// Set the message injection callback
-+    pub fn set_message_injection_callback(&mut self, callback: MessageInjectionCallback) {
-+        self.message_injection_callback = Some(callback);
-+    }
-+    
-+    /// Add a notification provider
-+    pub fn add_provider(&mut self, provider: Box<dyn NotificationProvider>) {
-+        self.providers.push(provider);
-+    }
-+    
-+    /// Initialize providers from environment variables
-+    #[cfg(feature = "notifications")]
-+    pub async fn init_from_env(&mut self) -> Result<()> {
-+        let mut providers_initialized = 0;
-+        
-+        // Initialize Slack provider
-+        if let Ok(app_token) = std::env::var("GOOSE_SLACK_APP_TOKEN") {
-+            if let Ok(bot_token) = std::env::var("GOOSE_SLACK_BOT_TOKEN") {
-+                let channel = std::env::var("GOOSE_SLACK_CHANNEL").ok();
-+                
-+                println!("üîó Initializing Slack notifications...");
-+                match SlackProvider::new(app_token, bot_token, channel).await {
-+                    Ok(provider) => {
-+                        // Start listening for Slack messages
-+                        match provider.start_listening(self.reply_sender.clone()).await {
-+                            Ok(_) => {
-+                                println!("‚úÖ Slack notifications enabled");
-+                                self.add_provider(Box::new(provider));
-+                                providers_initialized += 1;
-+                            }
-+                            Err(e) => {
-+                                eprintln!("‚ö†Ô∏è  Slack listener failed to start: {}", e);
-+                                eprintln!("   Slack notifications will be send-only");
-+                                self.add_provider(Box::new(provider));
-+                                providers_initialized += 1;
-+                            }
-+                        }
-+                    }
-+                    Err(e) => {
-+                        eprintln!("‚ùå Failed to initialize Slack provider: {}", e);
-+                    }
-+                }
-+            }
-+        }
-+        
-+        // Initialize Discord provider
-+        if let Ok(bot_token) = std::env::var("GOOSE_DISCORD_BOT_TOKEN") {
-+            let user_id = std::env::var("GOOSE_DISCORD_USER_ID").ok();
-+            
-+            println!("üîó Initializing Discord notifications...");
-+            match DiscordProvider::new(bot_token, user_id).await {
-+                Ok(provider) => {
-+                    // Start listening for Discord messages
-+                    match provider.start_listening(self.reply_sender.clone()).await {
-+                        Ok(_) => {
-+                            println!("‚úÖ Discord notifications enabled");
-+                            self.add_provider(Box::new(provider));
-+                            providers_initialized += 1;
-+                        }
-+                        Err(e) => {
-+                            eprintln!("‚ö†Ô∏è  Discord listener failed to start: {}", e);
-+                            eprintln!("   Discord notifications will be send-only");
-+                            self.add_provider(Box::new(provider));
-+                            providers_initialized += 1;
-+                        }
-+                    }
-+                }
-+                Err(e) => {
-+                    eprintln!("‚ùå Failed to initialize Discord provider: {}", e);
-+                }
-+            }
-+        }
-+        
-+        if providers_initialized == 0 {
-+            return Err(anyhow!("No notification providers could be initialized"));
-+        }
-+        
-+        println!("üîî {} notification provider(s) ready", providers_initialized);
-+        Ok(())
-+    }
-+    
-+    #[cfg(not(feature = "notifications"))]
-+    pub async fn init_from_env(&mut self) -> Result<()> {
-+        // No-op when notifications feature is disabled
-+        Ok(())
-+    }
-+    
-+    /// Update the current message context
-+    pub async fn update_messages(&self, messages: &[Message]) {
-+        let mut current = self.current_messages.lock().await;
-+        *current = messages.to_vec();
-+    }
-+    
-+    /// Mark that an LLM response was received
-+    pub async fn mark_response_received(&self) {
-+        let mut last_response = self.last_response_time.lock().await;
-+        *last_response = Some(Instant::now());
-+    }
-+    
-+    /// Mark that user input was received
-+    pub async fn mark_user_input_received(&self) {
-+        let mut last_input = self.last_user_input_time.lock().await;
-+        *last_input = Some(Instant::now());
-+        
-+        // No longer waiting for input
-+        let mut waiting = self.waiting_for_input.lock().await;
-+        *waiting = false;
-+        
-+        // Mark last notification as answered
-+        let mut history = self.history.lock().await;
-+        history.mark_last_answered();
-+    }
-+    
-+    /// Mark that we're waiting for user input
-+    pub async fn mark_waiting_for_input(&self) {
-+        let mut waiting = self.waiting_for_input.lock().await;
-+        *waiting = true;
-+        
-+        // Generate context if we have intelligence
-+        if let Some(intelligence) = &self.intelligence {
-+            let messages = self.current_messages.lock().await;
-+            let wait_type = determine_wait_type(&messages);
-+            
-+            // Skip notifications for tool confirmations
-+            if wait_type == WaitType::ToolConfirmation {
-+                return;
-+            }
-+            
-+            match intelligence.generate_context(&messages, wait_type).await {
-+                Ok(context) => {
-+                    let mut current_context = self.current_context.lock().await;
-+                    *current_context = Some(context);
-+                }
-+                Err(e) => {
-+                    eprintln!("Failed to generate notification context: {}", e);
-+                }
-+            }
-+        }
-+    }
-+    
-+    /// Send a notification to all configured providers
-+    async fn send_notification(&self, notification: &RichNotification) -> Result<()> {
-+        if self.providers.is_empty() {
-+            return Ok(());
-+        }
-+        
-+        let mut errors = Vec::new();
-+        
-+        for provider in &self.providers {
-+            if let Err(e) = provider.send_rich(notification).await {
-+                errors.push(format!("{}: {}", provider.name(), e));
-+            }
-+        }
-+        
-+        if !errors.is_empty() {
-+            return Err(anyhow!("Failed to send notifications: {}", errors.join(", ")));
-+        }
-+        
-+        Ok(())
-+    }
-+    
-+    /// Process a reply from a notification provider
-+    async fn process_notification_reply(&self, reply: NotificationReply) -> Result<()> {
-+        // Create a user message from the reply
-+        let user_message = Message::user().with_text(&reply.message);
-+        
-+        // Inject into session if callback is set
-+        if let Some(callback) = &self.message_injection_callback {
-+            callback(user_message).await?;
-+        }
-+        
-+        Ok(())
-+    }
-+    
-+    /// Start monitoring for timeouts and listening for replies
-+    pub fn start_monitoring(self: Arc<Self>) -> tokio::task::JoinHandle<()> {
-+        let notifier = self.clone();
-+        let reply_receiver = self.reply_receiver.clone();
-+        
-+        tokio::spawn(async move {
-+            let mut first_notification_sent = false;
-+            let mut check_interval = tokio::time::interval(Duration::from_secs(10));
-+            
-+            loop {
-+                tokio::select! {
-+                    // Check for timeout
-+                    _ = check_interval.tick() => {
-+                        if !notifier.config.enabled {
-+                            continue;
-+                        }
-+                        
-+                        let waiting = *notifier.waiting_for_input.lock().await;
-+                        if !waiting {
-+                            first_notification_sent = false;
-+                            continue;
-+                        }
-+                        
-+                        let last_response = *notifier.last_response_time.lock().await;
-+                        let context = notifier.current_context.lock().await.clone();
-+                        
-+                        if let (Some(response_time), Some(context)) = (last_response, context) {
-+                            // Skip tool confirmations
-+                            if context.wait_type == WaitType::ToolConfirmation {
-+                                continue;
-+                            }
-+                            
-+                            let history = notifier.history.lock().await;
-+                            let adapted_timeout = history.calculate_timeout(notifier.config.ping_timeout);
-+                            let should_follow_up = history.should_send_follow_up();
-+                            drop(history); // Release lock
-+                            
-+                            let elapsed = response_time.elapsed();
-+                            
-+                            if !first_notification_sent && elapsed >= Duration::from_secs(adapted_timeout) {
-+                                // Send first notification
-+                                let notification = RichNotification {
-+                                    summary: context.summary.clone(),
-+                                    fallback_preview: context.precomputed_response.clone(),
-+                                    wait_type: context.wait_type.clone(),
-+                                };
-+                                
-+                                if let Err(e) = notifier.send_notification(&notification).await {
-+                                    eprintln!("Failed to send timeout notification: {}", e);
-+                                }
-+                                
-+                                // Record in history
-+                                let mut history = notifier.history.lock().await;
-+                                history.add_notification(context.wait_type.clone(), context.summary.clone());
-+                                
-+                                first_notification_sent = true;
-+                            } else if first_notification_sent && 
-+                                      elapsed >= Duration::from_secs(adapted_timeout + notifier.config.fallback_timeout) {
-+                                
-+                                if should_follow_up {
-+                                    // Send follow-up notification before fallback
-+                                    let message = "ü¶Ü Taking the suggested action due to no response.";
-+                                    let notification = RichNotification {
-+                                        summary: message.to_string(),
-+                                        fallback_preview: None,
-+                                        wait_type: context.wait_type.clone(),
-+                                    };
-+                                    
-+                                    if let Err(e) = notifier.send_notification(&notification).await {
-+                                        eprintln!("Failed to send fallback notification: {}", e);
-+                                    }
-+                                }
-+                                
-+                                // Execute fallback action
-+                                if let Some(response) = context.precomputed_response {
-+                                    if let Err(e) = notifier.process_notification_reply(NotificationReply {
-+                                        provider: "Fallback".to_string(),
-+                                        user_id: "system".to_string(),
-+                                        message: response,
-+                                        timestamp: Instant::now(),
-+                                    }).await {
-+                                        eprintln!("Failed to inject fallback response: {}", e);
-+                                    }
-+                                }
-+                                
-+                                // Reset to avoid multiple fallbacks
-+                                first_notification_sent = false;
-+                                
-+                                // Clear waiting state
-+                                let mut waiting = notifier.waiting_for_input.lock().await;
-+                                *waiting = false;
-+                            }
-+                        }
-+                    }
-+                    
-+                    // Check for replies from notification providers
-+                    Some(reply) = async {
-+                        let mut receiver = reply_receiver.lock().await;
-+                        receiver.recv().await
-+                    } => {
-+                        // Mark that we received user input via notification
-+                        notifier.mark_user_input_received().await;
-+                        
-+                        println!("üì± Reply from {} ({}): {}", reply.provider, reply.user_id, reply.message);
-+                        
-+                        // Process the reply
-+                        if let Err(e) = notifier.process_notification_reply(reply).await {
-+                            eprintln!("Failed to process notification reply: {}", e);
-+                        }
-+                        
-+                        // Reset notification state
-+                        first_notification_sent = false;
-+                    }
-+                }
-+            }
-+        })
-+    }
-+    
-+    /// Check if we should take fallback action
-+    pub async fn should_take_fallback_action(&self) -> bool {
-+        if !self.config.enabled {
-+            return false;
-+        }
-+        
-+        let waiting = *self.waiting_for_input.lock().await;
-+        if !waiting {
-+            return false;
-+        }
-+        
-+        let context = self.current_context.lock().await;
-+        if let Some(ctx) = &*context {
-+            // Skip tool confirmations
-+            if ctx.wait_type == WaitType::ToolConfirmation {
-+                return false;
-+            }
-+        }
-+        
-+        if let Some(response_time) = *self.last_response_time.lock().await {
-+            let history = self.history.lock().await;
-+            let adapted_timeout = history.calculate_timeout(self.config.ping_timeout);
-+            
-+            let elapsed = response_time.elapsed();
-+            return elapsed >= Duration::from_secs(adapted_timeout + self.config.fallback_timeout);
-+        }
-+        
-+        false
-+    }
-+
-+    /// Get the current status of the notification system
-+    pub async fn get_status(&self) -> NotificationStatus {
-+        let waiting = *self.waiting_for_input.lock().await;
-+        let last_response = *self.last_response_time.lock().await;
-+        let last_input = *self.last_user_input_time.lock().await;
-+        let history = self.history.lock().await;
-+        let stats = history.get_stats();
-+        let current_context = self.current_context.lock().await;
-+        
-+        let context_summary = current_context.as_ref()
-+            .map(|ctx| ctx.summary.clone());
-+        
-+        NotificationStatus {
-+            enabled: self.config.enabled,
-+            provider_count: self.providers.len(),
-+            provider_names: self.providers.iter().map(|p| p.name().to_string()).collect(),
-+            waiting_for_input: waiting,
-+            last_response_time: last_response,
-+            last_user_input_time: last_input,
-+            notifications_sent: stats.total_sent,
-+            notifications_answered: stats.total_answered,
-+            current_streak: stats.current_streak,
-+            context_summary,
-+            ping_timeout: self.config.ping_timeout,
-+            fallback_timeout: self.config.fallback_timeout,
-+        }
-+    }
-+    
-+    /// Display current notification status to the user
-+    pub async fn display_status(&self) {
-+        let status = self.get_status().await;
-+        
-+        if !status.enabled {
-+            println!("üîï Notifications are disabled");
-+            return;
-+        }
-+        
-+        println!("üîî Notification Status:");
-+        println!("  Providers: {} active ({})", 
-+                status.provider_count, 
-+                status.provider_names.join(", "));
-+        
-+        if status.waiting_for_input {
-+            println!("  ‚è≥ Currently waiting for your input");
-+            if let Some(summary) = &status.context_summary {
-+                println!("     Context: {}", summary);
-+            }
-+            
-+            if let Some(last_response) = status.last_response_time {
-+                let elapsed = last_response.elapsed().as_secs();
-+                let time_until_ping = status.ping_timeout.saturating_sub(elapsed);
-+                
-+                if elapsed >= status.ping_timeout {
-+                    println!("     üì± Notification already sent");
-+                    let time_until_fallback = (status.ping_timeout + status.fallback_timeout).saturating_sub(elapsed);
-+                    if time_until_fallback > 0 {
-+                        println!("     üîÑ Fallback in {}s", time_until_fallback);
-+                    } else {
-+                        println!("     ‚úÖ Fallback executed");
-+                    }
-+                } else {
-+                    println!("     üì± Next notification in {}s", time_until_ping);
-+                }
-+            }
-+        } else {
-+            println!("  ‚úÖ Ready - not waiting for input");
-+        }
-+        
-+        if status.notifications_sent > 0 {
-+            let response_rate = if status.notifications_sent > 0 {
-+                (status.notifications_answered as f64 / status.notifications_sent as f64) * 100.0
-+            } else {
-+                0.0
-+            };
-+            
-+            println!("  üìä Stats: {}/{} answered ({:.0}%), {} current streak", 
-+                    status.notifications_answered, 
-+                    status.notifications_sent, 
-+                    response_rate,
-+                    status.current_streak);
-+        }
-+        
-+        println!("  ‚öôÔ∏è  Timeouts: {}s ping, {}s fallback", 
-+                status.ping_timeout, status.fallback_timeout);
-+    }
-+
-+
-+}
-+
-+#[cfg(test)]
-+mod tests {
-+    use super::*;
-+    use tokio::sync::mpsc;
-+    use tempfile::TempDir;
-+    use std::env;
-+    use async_trait::async_trait;
-+
-+    /// Mock provider for testing
-+    struct MockTestProvider {
-+        name: String,
-+        sent_count: Arc<Mutex<usize>>,
-+        should_fail: Arc<Mutex<bool>>,
-+    }
-+
-+    impl MockTestProvider {
-+        fn new(name: String) -> Self {
-+            Self {
-+                name,
-+                sent_count: Arc::new(Mutex::new(0)),
-+                should_fail: Arc::new(Mutex::new(false)),
-+            }
-+        }
-+
-+        async fn set_should_fail(&self, fail: bool) {
-+            *self.should_fail.lock().await = fail;
-+        }
-+
-+        async fn get_sent_count(&self) -> usize {
-+            *self.sent_count.lock().await
-+        }
-+    }
-+
-+    #[async_trait]
-+    impl NotificationProvider for MockTestProvider {
-+        async fn send_rich(&self, _notification: &RichNotification) -> Result<()> {
-+            if *self.should_fail.lock().await {
-+                return Err(anyhow!("Mock provider failure"));
-+            }
-+            
-+            let mut count = self.sent_count.lock().await;
-+            *count += 1;
-+            Ok(())
-+        }
-+
-+        async fn start_listening(&self, _reply_sender: mpsc::Sender<NotificationReply>) -> Result<()> {
-+            Ok(())
-+        }
-+
-+        fn name(&self) -> &str {
-+            &self.name
-+        }
-+    }
-+
-+    fn create_test_config() -> NotificationConfig {
-+        let temp_dir = TempDir::new().unwrap();
-+        NotificationConfig {
-+            ping_timeout: 5,
-+            fallback_timeout: 10,
-+            enabled: true,
-+            prompts_dir: temp_dir.path().to_path_buf(),
-+        }
-+    }
-+
-+    #[test]
-+    fn test_notifier_creation() {
-+        let config = create_test_config();
-+        let notifier = Notifier::new(config);
-+        
-+        assert_eq!(notifier.providers.len(), 0);
-+        assert!(notifier.history.is_ok());
-+        assert!(notifier.intelligence.is_none()); // No LLM provider set yet
-+    }
-+
-+    #[tokio::test]
-+    async fn test_add_provider() {
-+        let config = create_test_config();
-+        let mut notifier = Notifier::new(config);
-+        
-+        let provider = MockTestProvider::new("TestProvider".to_string());
-+        notifier.add_provider(Box::new(provider));
-+        
-+        assert_eq!(notifier.providers.len(), 1);
-+        assert_eq!(notifier.providers[0].name(), "TestProvider");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_add_multiple_providers() {
-+        let config = create_test_config();
-+        let mut notifier = Notifier::new(config);
-+        
-+        notifier.add_provider(Box::new(MockTestProvider::new("Slack".to_string())));
-+        notifier.add_provider(Box::new(MockTestProvider::new("Discord".to_string())));
-+        
-+        assert_eq!(notifier.providers.len(), 2);
-+        
-+        let names: Vec<&str> = notifier.providers.iter().map(|p| p.name()).collect();
-+        assert!(names.contains(&"Slack"));
-+        assert!(names.contains(&"Discord"));
-+    }
-+
-+    #[tokio::test]
-+    async fn test_update_messages() {
-+        let config = create_test_config();
-+        let notifier = Arc::new(Notifier::new(config));
-+        
-+        let messages = vec![
-+            Message::user().with_text("Hello"),
-+            Message::assistant().with_text("Hi there!"),
-+        ];
-+        
-+        notifier.update_messages(&messages).await;
-+        
-+        // Should update internal state without errors
-+        // (Actual verification would require access to internal state)
-+    }
-+
-+    #[tokio::test]
-+    async fn test_mark_waiting_for_input() {
-+        let config = create_test_config();
-+        let notifier = Arc::new(Notifier::new(config));
-+        
-+        // Should not panic or error
-+        notifier.mark_waiting_for_input().await;
-+    }
-+
-+    #[tokio::test]
-+    async fn test_mark_user_input_received() {
-+        let config = create_test_config();
-+        let notifier = Arc::new(Notifier::new(config));
-+        
-+        notifier.mark_user_input_received().await;
-+        // Should update state without issues
-+    }
-+
-+    #[tokio::test]
-+    async fn test_display_status_no_providers() {
-+        let config = create_test_config();
-+        let notifier = Notifier::new(config);
-+        
-+        // Should display status without providers gracefully
-+        notifier.display_status().await;
-+    }
-+
-+    #[tokio::test]
-+    async fn test_display_status_with_providers() {
-+        let config = create_test_config();
-+        let mut notifier = Notifier::new(config);
-+        
-+        notifier.add_provider(Box::new(MockTestProvider::new("TestProvider".to_string())));
-+        
-+        // Should display status with providers
-+        notifier.display_status().await;
-+    }
-+
-+    #[test]
-+    fn test_validate_config_success() {
-+        // Set up valid environment
-+        env::set_var("GOOSE_NOTIFICATIONS_ENABLED", "true");
-+        env::set_var("GOOSE_SLACK_BOT_TOKEN", "xoxb-test-token");
-+        
-+        let result = Notifier::validate_config();
-+        assert!(result.is_ok(), "Should validate successfully with valid config");
-+        
-+        // Clean up
-+        env::remove_var("GOOSE_NOTIFICATIONS_ENABLED");
-+        env::remove_var("GOOSE_SLACK_BOT_TOKEN");
-+    }
-+
-+    #[test]
-+    fn test_validate_config_disabled() {
-+        // Set notifications as disabled
-+        env::set_var("GOOSE_NOTIFICATIONS_ENABLED", "false");
-+        
-+        let result = Notifier::validate_config();
-+        assert!(result.is_err(), "Should fail when notifications disabled");
-+        
-+        let error_msg = result.unwrap_err().to_string();
-+        assert!(error_msg.contains("disabled"), "Error should mention disabled state");
-+        
-+        // Clean up
-+        env::remove_var("GOOSE_NOTIFICATIONS_ENABLED");
-+    }
-+
-+    #[test]
-+    fn test_validate_config_no_providers() {
-+        env::set_var("GOOSE_NOTIFICATIONS_ENABLED", "true");
-+        // Remove all provider tokens
-+        env::remove_var("GOOSE_SLACK_BOT_TOKEN");
-+        env::remove_var("GOOSE_DISCORD_BOT_TOKEN");
-+        
-+        let result = Notifier::validate_config();
-+        assert!(result.is_err(), "Should fail with no providers configured");
-+        
-+        let error_msg = result.unwrap_err().to_string();
-+        assert!(error_msg.contains("No notification providers") || 
-+                error_msg.contains("provider"), "Error should mention providers");
-+        
-+        // Clean up
-+        env::remove_var("GOOSE_NOTIFICATIONS_ENABLED");
-+    }
-+
-+    #[test]
-+    fn test_validate_config_invalid_slack_token() {
-+        env::set_var("GOOSE_NOTIFICATIONS_ENABLED", "true");
-+        env::set_var("GOOSE_SLACK_BOT_TOKEN", "invalid-token");
-+        
-+        let result = Notifier::validate_config();
-+        assert!(result.is_err(), "Should fail with invalid Slack token");
-+        
-+        // Clean up
-+        env::remove_var("GOOSE_NOTIFICATIONS_ENABLED");
-+        env::remove_var("GOOSE_SLACK_BOT_TOKEN");
-+    }
-+
-+    #[test]
-+    fn test_validate_config_invalid_discord_user_id() {
-+        env::set_var("GOOSE_NOTIFICATIONS_ENABLED", "true");
-+        env::set_var("GOOSE_DISCORD_BOT_TOKEN", "valid-token");
-+        env::set_var("GOOSE_DISCORD_USER_ID", "invalid-user-id");
-+        
-+        let result = Notifier::validate_config();
-+        assert!(result.is_err(), "Should fail with invalid Discord user ID");
-+        
-+        // Clean up
-+        env::remove_var("GOOSE_NOTIFICATIONS_ENABLED");
-+        env::remove_var("GOOSE_DISCORD_BOT_TOKEN");
-+        env::remove_var("GOOSE_DISCORD_USER_ID");
-+    }
-+
-+    #[test]
-+    fn test_validate_config_missing_slack_app_token() {
-+        env::set_var("GOOSE_NOTIFICATIONS_ENABLED", "true");
-+        env::set_var("GOOSE_SLACK_BOT_TOKEN", "xoxb-test-token");
-+        env::remove_var("GOOSE_SLACK_APP_TOKEN");
-+        
-+        let result = Notifier::validate_config();
-+        assert!(result.is_err(), "Should fail with missing Slack app token");
-+        
-+        // Clean up
-+        env::remove_var("GOOSE_NOTIFICATIONS_ENABLED");
-+        env::remove_var("GOOSE_SLACK_BOT_TOKEN");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_send_notification_no_providers() {
-+        let config = create_test_config();
-+        let notifier = Arc::new(Notifier::new(config));
-+        
-+        let messages = vec![Message::assistant().with_text("Test message")];
-+        notifier.update_messages(&messages).await;
-+        
-+        // Should handle gracefully with no providers
-+        // (No way to verify since send_notification is private)
-+    }
-+
-+    #[tokio::test]
-+    async fn test_provider_failure_handling() {
-+        let config = create_test_config();
-+        let mut notifier = Notifier::new(config);
-+        
-+        let provider = MockTestProvider::new("FailingProvider".to_string());
-+        provider.set_should_fail(true).await;
-+        notifier.add_provider(Box::new(provider));
-+        
-+        let notifier_arc = Arc::new(notifier);
-+        let messages = vec![Message::assistant().with_text("Test message")];
-+        notifier_arc.update_messages(&messages).await;
-+        
-+        // Should handle provider failures gracefully
-+        // (Error handling is internal, so no direct verification)
-+    }
-+
-+    #[tokio::test]
-+    async fn test_message_injection_callback() {
-+        let config = create_test_config();
-+        let notifier = Notifier::new(config);
-+        
-+        let injected_messages = Arc::new(Mutex::new(Vec::new()));
-+        let tracker = injected_messages.clone();
-+        
-+        let callback = Arc::new(move |message: Message| {
-+            let tracker = tracker.clone();
-+            Box::pin(async move {
-+                let mut messages = tracker.lock().await;
-+                messages.push(message);
-+                Ok(())
-+            })
-+        });
-+        
-+        notifier.set_message_injection_callback(callback);
-+        
-+        // Simulate message injection
-+        let test_message = Message::user().with_text("Test injected message");
-+        if let Some(ref callback) = notifier.message_injection_callback {
-+            let _ = callback(test_message.clone()).await;
-+        }
-+        
-+        // Verify message was injected
-+        let injected = injected_messages.lock().await;
-+        assert_eq!(injected.len(), 1);
-+        if let MessageContent::Text(text) = &injected[0].content {
-+            assert_eq!(text, "Test injected message");
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_start_monitoring() {
-+        let config = create_test_config();
-+        let notifier = Arc::new(Notifier::new(config));
-+        
-+        let monitor_handle = notifier.clone().start_monitoring();
-+        
-+        // Should start monitoring task
-+        assert!(!monitor_handle.is_finished());
-+        
-+        // Clean up
-+        monitor_handle.abort();
-+    }
-+
-+    #[tokio::test]
-+    async fn test_concurrent_operations() {
-+        let config = create_test_config();
-+        let mut notifier = Notifier::new(config);
-+        
-+        notifier.add_provider(Box::new(MockTestProvider::new("Provider1".to_string())));
-+        notifier.add_provider(Box::new(MockTestProvider::new("Provider2".to_string())));
-+        
-+        let notifier_arc = Arc::new(notifier);
-+        
-+        // Perform concurrent operations
-+        let futures = (0..5).map(|i| {
-+            let notifier = notifier_arc.clone();
-+            async move {
-+                let messages = vec![Message::assistant().with_text(&format!("Message {}", i))];
-+                notifier.update_messages(&messages).await;
-+                notifier.mark_waiting_for_input().await;
-+                notifier.mark_user_input_received().await;
-+            }
-+        });
-+        
-+        // Should handle concurrent operations without panics
-+        futures::future::join_all(futures).await;
-+    }
-+
-+    #[tokio::test]
-+    async fn test_memory_cleanup_large_messages() {
-+        let config = create_test_config();
-+        let notifier = Arc::new(Notifier::new(config));
-+        
-+        // Create very large message history
-+        let large_text = "x".repeat(100000);
-+        let messages: Vec<Message> = (0..1000)
-+            .map(|i| {
-+                if i % 2 == 0 {
-+                    Message::user().with_text(&format!("{}-{}", i, large_text))
-+                } else {
-+                    Message::assistant().with_text(&format!("{}-{}", i, large_text))
-+                }
-+            })
-+            .collect();
-+        
-+        // Should handle large message sets without excessive memory usage
-+        notifier.update_messages(&messages).await;
-+        
-+        // Memory usage should be reasonable
-+        // (This is more of a stress test to ensure no obvious memory leaks)
-+    }
-+
-+    #[test]
-+    fn test_notification_config_validation() {
-+        let temp_dir = TempDir::new().unwrap();
-+        
-+        // Valid config
-+        let valid_config = NotificationConfig {
-+            ping_timeout: 60,
-+            fallback_timeout: 300,
-+            enabled: true,
-+            prompts_dir: temp_dir.path().to_path_buf(),
-+        };
-+        
-+        // Should create notifier successfully
-+        let _notifier = Notifier::new(valid_config);
-+        
-+        // Edge case: zero timeouts
-+        let edge_config = NotificationConfig {
-+            ping_timeout: 0,
-+            fallback_timeout: 0,
-+            enabled: true,
-+            prompts_dir: temp_dir.path().to_path_buf(),
-+        };
-+        
-+        // Should still create successfully (handled internally)
-+        let _notifier = Notifier::new(edge_config);
-+    }
-+} 
-\ No newline at end of file
-diff --git a/crates/goose-cli/src/notifier/providers/discord.rs b/crates/goose-cli/src/notifier/providers/discord.rs
-new file mode 100644
-index 0000000000..aec4eab28a
---- /dev/null
-+++ b/crates/goose-cli/src/notifier/providers/discord.rs
-@@ -0,0 +1,653 @@
-+//! Discord notification provider using Serenity for bidirectional communication
-+
-+use anyhow::{anyhow, Result};
-+use async_trait::async_trait;
-+use serenity::prelude::*;
-+use serenity::model::prelude::*;
-+use tokio::sync::mpsc;
-+use tokio::time::Instant;
-+use std::sync::Arc;
-+use tokio::sync::Mutex;
-+
-+use crate::notifier::{NotificationProvider, NotificationReply, RichNotification};
-+
-+/// Event handler for Discord bot
-+struct DiscordEventHandler {
-+    reply_sender: mpsc::Sender<NotificationReply>,
-+    target_user_id: Option<UserId>,
-+}
-+
-+#[async_trait]
-+impl EventHandler for DiscordEventHandler {
-+    /// Handle incoming messages
-+    async fn message(&self, _ctx: Context, msg: Message) {
-+        // Only process direct messages
-+        if msg.guild_id.is_some() {
-+            return; // Skip guild messages
-+        }
-+        
-+        // Skip our own messages
-+        if msg.author.bot {
-+            return;
-+        }
-+        
-+        // If we have a target user, only process messages from them
-+        if let Some(target_id) = self.target_user_id {
-+            if msg.author.id != target_id {
-+                return;
-+            }
-+        }
-+        
-+        // Send the reply through our channel
-+        let reply = NotificationReply {
-+            provider: "Discord".to_string(),
-+            user_id: msg.author.id.to_string(),
-+            message: msg.content,
-+            timestamp: Instant::now(),
-+        };
-+        
-+        if let Err(e) = self.reply_sender.send(reply).await {
-+            eprintln!("Failed to send Discord reply: {}", e);
-+        }
-+    }
-+    
-+    async fn ready(&self, _: Context, ready: Ready) {
-+        println!("üîó Discord bot connected as {}", ready.user.name);
-+    }
-+}
-+
-+/// Discord provider using Serenity for bidirectional communication
-+pub struct DiscordProvider {
-+    bot_token: String,
-+    user_id: Option<String>,
-+    /// Track the client for cleanup
-+    client_handle: Arc<Mutex<Option<tokio::task::JoinHandle<()>>>>,
-+}
-+
-+impl DiscordProvider {
-+    /// Create a new Discord provider
-+    pub async fn new(bot_token: String, user_id: Option<String>) -> Result<Self> {
-+        Ok(Self {
-+            bot_token,
-+            user_id,
-+            client_handle: Arc::new(Mutex::new(None)),
-+        })
-+    }
-+    
-+    /// Get the target user ID if configured
-+    fn target_user_id(&self) -> Option<UserId> {
-+        self.user_id.as_ref()
-+            .and_then(|id| id.parse::<u64>().ok())
-+            .map(UserId)
-+    }
-+    
-+    /// Truncate text to fit Discord embed limits
-+    fn truncate_for_discord(text: &str, max_len: usize) -> String {
-+        if text.len() <= max_len {
-+            text.to_string()
-+        } else {
-+            format!("{}...\n\n[Message truncated]", &text[..max_len.saturating_sub(25)])
-+        }
-+    }
-+}
-+
-+#[async_trait]
-+impl NotificationProvider for DiscordProvider {
-+    async fn send_rich(&self, notification: &RichNotification) -> Result<()> {
-+        // Create a temporary client just for sending this message
-+        let intents = GatewayIntents::DIRECT_MESSAGES | GatewayIntents::MESSAGE_CONTENT;
-+        let client = Client::builder(&self.bot_token, intents)
-+            .await
-+            .map_err(|e| anyhow!("Failed to create Discord client: {}", e))?;
-+        
-+        let user_id = self.target_user_id()
-+            .ok_or_else(|| anyhow!("Discord user ID not configured"))?;
-+        
-+        // Discord embed description limit is 4096 characters
-+        let summary = Self::truncate_for_discord(&notification.summary, 3000);
-+        
-+        // Create a rich embed
-+        let mut embed = CreateEmbed::new()
-+            .title("ü¶Ü Goose Notification")
-+            .description(summary)
-+            .color(0x5865F2); // Discord blurple
-+        
-+        // Add fallback preview field if available (field value limit is 1024)
-+        if let Some(preview) = &notification.fallback_preview {
-+            let truncated_preview = Self::truncate_for_discord(preview, 900);
-+            embed = embed.field("Suggested Response", format!("```{}```", truncated_preview), false);
-+        }
-+        
-+        // Add footer with context
-+        let footer_text = match notification.wait_type {
-+            crate::notifier::intelligence::WaitType::NextTask => "‚è≥ Waiting for next task",
-+            crate::notifier::intelligence::WaitType::UserReply => "‚ùì Waiting for your reply",
-+            crate::notifier::intelligence::WaitType::ToolConfirmation => "üîß Tool confirmation",
-+        };
-+        embed = embed.footer(CreateEmbedFooter::new(footer_text));
-+        
-+        // Get the user and create DM channel
-+        let user = user_id.to_user(&client.http).await
-+            .map_err(|e| anyhow!("Failed to get Discord user: {}", e))?;
-+        
-+        let dm_channel = user.create_dm_channel(&client.http).await
-+            .map_err(|e| anyhow!("Failed to create Discord DM channel: {}", e))?;
-+        
-+        // Send the message
-+        let message = CreateMessage::new().embed(embed);
-+        dm_channel.send_message(&client.http, message).await
-+            .map_err(|e| anyhow!("Failed to send Discord message: {}", e))?;
-+        
-+        Ok(())
-+    }
-+    
-+    async fn start_listening(&self, reply_sender: mpsc::Sender<NotificationReply>) -> Result<()> {
-+        let bot_token = self.bot_token.clone();
-+        let target_user_id = self.target_user_id();
-+        
-+        // Create the event handler
-+        let event_handler = DiscordEventHandler {
-+            reply_sender,
-+            target_user_id,
-+        };
-+        
-+        // Start the Discord client in a background task
-+        let handle = tokio::spawn(async move {
-+            let intents = GatewayIntents::DIRECT_MESSAGES | GatewayIntents::MESSAGE_CONTENT;
-+            
-+            let mut client = match Client::builder(&bot_token, intents)
-+                .event_handler(event_handler)
-+                .await 
-+            {
-+                Ok(client) => client,
-+                Err(e) => {
-+                    eprintln!("Failed to create Discord client: {}", e);
-+                    return;
-+                }
-+            };
-+            
-+            // Start listening for events
-+            if let Err(e) = client.start().await {
-+                eprintln!("Discord client error: {}", e);
-+            }
-+        });
-+        
-+        // Store the handle for cleanup
-+        {
-+            let mut client_handle = self.client_handle.lock().await;
-+            *client_handle = Some(handle);
-+        }
-+        
-+        Ok(())
-+    }
-+    
-+    fn name(&self) -> &str {
-+        "Discord"
-+    }
-+}
-+
-+impl Drop for DiscordProvider {
-+    fn drop(&mut self) {
-+        // Clean up the client when the provider is dropped
-+        if let Ok(mut handle) = self.client_handle.try_lock() {
-+            if let Some(h) = handle.take() {
-+                h.abort();
-+            }
-+        }
-+    }
-+} 
-+
-+#[cfg(test)]
-+mod tests {
-+    use super::*;
-+    use tokio::sync::mpsc;
-+    use tokio::time::{timeout, Duration};
-+    use serenity::model::id::UserId;
-+
-+    fn create_test_discord_provider() -> DiscordProvider {
-+        DiscordProvider::new(
-+            "test_bot_token".to_string(),
-+            UserId::new(123456789),
-+        )
-+    }
-+
-+    #[test]
-+    fn test_discord_provider_creation() {
-+        let provider = create_test_discord_provider();
-+        assert_eq!(provider.name(), "Discord");
-+        assert_eq!(provider.target_user_id.get(), 123456789);
-+    }
-+
-+    #[test]
-+    fn test_validate_token() {
-+        // Valid token format
-+        assert!(DiscordProvider::validate_token("valid_token_123").is_ok());
-+        
-+        // Empty token
-+        assert!(DiscordProvider::validate_token("").is_err());
-+        
-+        // Very long token (should still be valid)
-+        let long_token = "a".repeat(100);
-+        assert!(DiscordProvider::validate_token(&long_token).is_ok());
-+    }
-+
-+    #[test]
-+    fn test_validate_user_id() {
-+        // Valid user ID
-+        assert!(DiscordProvider::validate_user_id("123456789").is_ok());
-+        
-+        // Invalid user ID (not numeric)
-+        assert!(DiscordProvider::validate_user_id("invalid").is_err());
-+        
-+        // Empty user ID
-+        assert!(DiscordProvider::validate_user_id("").is_err());
-+        
-+        // Zero user ID
-+        assert!(DiscordProvider::validate_user_id("0").is_err());
-+        
-+        // Negative user ID (Discord IDs are always positive)
-+        assert!(DiscordProvider::validate_user_id("-123").is_err());
-+    }
-+
-+    #[tokio::test]
-+    async fn test_create_discord_embed_basic() {
-+        let notification = RichNotification {
-+            title: "Test Title".to_string(),
-+            summary: "Test summary message".to_string(),
-+            context: "Test context".to_string(),
-+            actions: vec![],
-+        };
-+
-+        let embed = DiscordProvider::create_discord_embed(&notification);
-+        
-+        assert_eq!(embed.title, Some("ü¶Ü Test Title".to_string()));
-+        assert_eq!(embed.color, Some(0x5865F2)); // Discord blurple
-+        
-+        // Check description
-+        if let Some(description) = embed.description {
-+            assert!(description.contains("Test summary message"));
-+            assert!(description.contains("Test context"));
-+        } else {
-+            panic!("Embed should have description");
-+        }
-+
-+        // Check footer
-+        assert!(embed.footer.is_some());
-+        assert_eq!(embed.footer.unwrap().text, "Reply to this message to continue the conversation");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_create_discord_embed_with_actions() {
-+        let notification = RichNotification {
-+            title: "Action Test".to_string(),
-+            summary: "Summary".to_string(),
-+            context: "Context".to_string(),
-+            actions: vec![
-+                "Continue with default settings".to_string(),
-+                "Ask for more details".to_string(),
-+            ],
-+        };
-+
-+        let embed = DiscordProvider::create_discord_embed(&notification);
-+        
-+        // Check that actions are included in description
-+        if let Some(description) = embed.description {
-+            assert!(description.contains("**Suggested responses:**"));
-+            assert!(description.contains("‚Ä¢ Continue with default settings"));
-+            assert!(description.contains("‚Ä¢ Ask for more details"));
-+        } else {
-+            panic!("Embed should have description with actions");
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_create_discord_embed_truncation() {
-+        // Create a very long summary and context that exceeds Discord's limits
-+        let long_summary = "x".repeat(3000);
-+        let long_context = "y".repeat(3000);
-+        
-+        let notification = RichNotification {
-+            title: "Truncation Test".to_string(),
-+            summary: long_summary.clone(),
-+            context: long_context.clone(),
-+            actions: vec![],
-+        };
-+
-+        let embed = DiscordProvider::create_discord_embed(&notification);
-+        
-+        // Check that description is truncated
-+        if let Some(description) = embed.description {
-+            assert!(description.len() <= DiscordProvider::MAX_EMBED_DESCRIPTION_LENGTH);
-+            if description.len() == DiscordProvider::MAX_EMBED_DESCRIPTION_LENGTH {
-+                assert!(description.ends_with("..."), "Should indicate truncation");
-+            }
-+        } else {
-+            panic!("Embed should have description");
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_create_discord_embed_special_characters() {
-+        let notification = RichNotification {
-+            title: "Special **bold** and *italic* Test".to_string(),
-+            summary: "Summary with ```code``` and [links](http://example.com)".to_string(),
-+            context: "Context with @mentions and #channels".to_string(),
-+            actions: vec!["Action with **formatting**".to_string()],
-+        };
-+
-+        let embed = DiscordProvider::create_discord_embed(&notification);
-+        
-+        // Discord handles markdown, so special characters should be preserved
-+        assert!(embed.title.as_ref().unwrap().contains("**bold**"));
-+        
-+        if let Some(description) = embed.description {
-+            assert!(description.contains("```code```"));
-+            assert!(description.contains("[links]"));
-+            assert!(description.contains("**formatting**"));
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_create_discord_embed_unicode() {
-+        let notification = RichNotification {
-+            title: "Unicode Test ü¶Üüî•‚ö°".to_string(),
-+            summary: "Summary with √©mojis and a√ßc√©nts".to_string(),
-+            context: "Context with ‰∏≠Êñá and ÿßŸÑÿπÿ±ÿ®Ÿäÿ©".to_string(),
-+            actions: vec!["Action with üöÄ".to_string()],
-+        };
-+
-+        let embed = DiscordProvider::create_discord_embed(&notification);
-+        
-+        // Unicode should be preserved
-+        assert!(embed.title.as_ref().unwrap().contains("ü¶Üüî•‚ö°"));
-+        
-+        if let Some(description) = embed.description {
-+            assert!(description.contains("√©mojis"));
-+            assert!(description.contains("a√ßc√©nts"));
-+            assert!(description.contains("‰∏≠Êñá"));
-+            assert!(description.contains("ÿßŸÑÿπÿ±ÿ®Ÿäÿ©"));
-+            assert!(description.contains("üöÄ"));
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_truncate_for_discord() {
-+        // Test normal text (under limit)
-+        let short_text = "Short message";
-+        assert_eq!(DiscordProvider::truncate_for_discord(short_text, 100), short_text);
-+        
-+        // Test exact limit
-+        let exact_text = "x".repeat(100);
-+        assert_eq!(DiscordProvider::truncate_for_discord(&exact_text, 100), exact_text);
-+        
-+        // Test over limit
-+        let long_text = "x".repeat(150);
-+        let truncated = DiscordProvider::truncate_for_discord(&long_text, 100);
-+        assert!(truncated.len() <= 100);
-+        assert!(truncated.ends_with("..."));
-+        
-+        // Test empty string
-+        assert_eq!(DiscordProvider::truncate_for_discord("", 100), "");
-+        
-+        // Test with unicode
-+        let unicode_text = "ü¶Ü".repeat(50); // Each emoji is multiple bytes
-+        let truncated_unicode = DiscordProvider::truncate_for_discord(&unicode_text, 100);
-+        assert!(truncated_unicode.len() <= 100);
-+    }
-+
-+    #[tokio::test]
-+    async fn test_embed_field_limits() {
-+        let notification = RichNotification {
-+            title: "Field Limits Test".to_string(),
-+            summary: "Testing field limits".to_string(),
-+            context: "Testing context limits".to_string(),
-+            actions: (0..20).map(|i| format!("Action number {} with some text", i)).collect(),
-+        };
-+
-+        let embed = DiscordProvider::create_discord_embed(&notification);
-+        
-+        // Should handle many actions gracefully
-+        if let Some(description) = embed.description {
-+            assert!(description.len() <= DiscordProvider::MAX_EMBED_DESCRIPTION_LENGTH);
-+            // Should contain some actions but maybe not all
-+            assert!(description.contains("Action number"));
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_embed_color_consistency() {
-+        let notification = RichNotification {
-+            title: "Color Test".to_string(),
-+            summary: "Testing color consistency".to_string(),
-+            context: "Color context".to_string(),
-+            actions: vec![],
-+        };
-+
-+        let embed1 = DiscordProvider::create_discord_embed(&notification);
-+        let embed2 = DiscordProvider::create_discord_embed(&notification);
-+        
-+        // Color should be consistent
-+        assert_eq!(embed1.color, embed2.color);
-+        assert_eq!(embed1.color, Some(0x5865F2)); // Discord blurple
-+    }
-+
-+    #[tokio::test]
-+    async fn test_send_rich_error_handling() {
-+        let provider = create_test_discord_provider();
-+        let notification = RichNotification {
-+            title: "Error Test".to_string(),
-+            summary: "Testing error handling".to_string(),
-+            context: "Error context".to_string(),
-+            actions: vec![],
-+        };
-+
-+        // This should fail with authentication error since we're using test token
-+        let result = provider.send_rich(&notification).await;
-+        assert!(result.is_err());
-+        
-+        // Error should contain useful information
-+        let error_msg = result.unwrap_err().to_string();
-+        assert!(error_msg.contains("Failed to send Discord notification") ||
-+                error_msg.contains("authentication") ||
-+                error_msg.contains("token"));
-+    }
-+
-+    #[tokio::test]
-+    async fn test_start_listening_setup() {
-+        let provider = create_test_discord_provider();
-+        let (tx, mut rx) = mpsc::channel(10);
-+
-+        // This will fail due to invalid token, but we test the setup
-+        let result = provider.start_listening(tx).await;
-+        assert!(result.is_err());
-+        
-+        // Should not receive any messages since connection failed
-+        let receive_result = timeout(Duration::from_millis(100), rx.recv()).await;
-+        assert!(receive_result.is_err()); // Timeout expected
-+    }
-+
-+    #[tokio::test]
-+    async fn test_concurrent_operations() {
-+        let provider = Arc::new(create_test_discord_provider());
-+        let notification = Arc::new(RichNotification {
-+            title: "Concurrency Test".to_string(),
-+            summary: "Testing concurrent operations".to_string(),
-+            context: "Concurrent context".to_string(),
-+            actions: vec![],
-+        });
-+
-+        // Try concurrent operations
-+        let futures = (0..5).map(|_| {
-+            let provider = provider.clone();
-+            let notification = notification.clone();
-+            async move {
-+                provider.send_rich(&notification).await
-+            }
-+        });
-+
-+        let results: Vec<_> = futures::future::join_all(futures).await;
-+
-+        // All should fail with the same error (invalid token)
-+        for result in results {
-+            assert!(result.is_err());
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_memory_efficiency_large_embeds() {
-+        let provider = create_test_discord_provider();
-+        
-+        // Create notification with very large content
-+        let large_content = "ü¶Ü".repeat(10000); // Unicode to test memory usage
-+        let notification = RichNotification {
-+            title: large_content.clone(),
-+            summary: large_content.clone(),
-+            context: large_content.clone(),
-+            actions: (0..50).map(|i| format!("Action {} with {}", i, large_content)).collect(),
-+        };
-+
-+        // Should handle gracefully without excessive memory usage
-+        let embed = DiscordProvider::create_discord_embed(&notification);
-+        
-+        // Should be truncated appropriately
-+        assert!(embed.description.as_ref().unwrap().len() <= DiscordProvider::MAX_EMBED_DESCRIPTION_LENGTH);
-+        
-+        // Sending should fail gracefully
-+        let result = provider.send_rich(&notification).await;
-+        assert!(result.is_err());
-+    }
-+
-+    #[test]
-+    fn test_discord_constants() {
-+        // Verify our constants match Discord's actual limits
-+        assert_eq!(DiscordProvider::MAX_EMBED_TITLE_LENGTH, 256);
-+        assert_eq!(DiscordProvider::MAX_EMBED_DESCRIPTION_LENGTH, 4096);
-+        
-+        // Constants should be reasonable
-+        assert!(DiscordProvider::MAX_EMBED_TITLE_LENGTH > 0);
-+        assert!(DiscordProvider::MAX_EMBED_DESCRIPTION_LENGTH > 1000);
-+    }
-+
-+    #[tokio::test]
-+    async fn test_embed_structure_completeness() {
-+        let notification = RichNotification {
-+            title: "Structure Test".to_string(),
-+            summary: "Testing embed structure".to_string(),
-+            context: "Structure context".to_string(),
-+            actions: vec!["Test Action".to_string()],
-+        };
-+
-+        let embed = DiscordProvider::create_discord_embed(&notification);
-+        
-+        // Verify all expected fields are present
-+        assert!(embed.title.is_some(), "Embed should have title");
-+        assert!(embed.description.is_some(), "Embed should have description");
-+        assert!(embed.color.is_some(), "Embed should have color");
-+        assert!(embed.footer.is_some(), "Embed should have footer");
-+        
-+        // Verify footer content
-+        let footer = embed.footer.unwrap();
-+        assert!(!footer.text.is_empty(), "Footer text should not be empty");
-+        assert!(footer.text.contains("Reply"), "Footer should mention replying");
-+    }
-+
-+    #[tokio::test] 
-+    async fn test_edge_case_empty_fields() {
-+        let notification = RichNotification {
-+            title: "".to_string(),
-+            summary: "".to_string(),
-+            context: "".to_string(),
-+            actions: vec![],
-+        };
-+
-+        let embed = DiscordProvider::create_discord_embed(&notification);
-+        
-+        // Should handle empty fields gracefully
-+        assert!(embed.title.is_some());
-+        assert!(embed.description.is_some());
-+        
-+        // Even with empty input, should have some content
-+        let title = embed.title.unwrap();
-+        assert!(!title.is_empty(), "Title should not be completely empty");
-+        
-+        let description = embed.description.unwrap();
-+        assert!(!description.is_empty(), "Description should not be completely empty");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_action_formatting_edge_cases() {
-+        // Test with many actions
-+        let many_actions: Vec<String> = (0..100)
-+            .map(|i| format!("Action {}", i))
-+            .collect();
-+            
-+        let notification = RichNotification {
-+            title: "Many Actions".to_string(),
-+            summary: "Summary".to_string(),
-+            context: "Context".to_string(),
-+            actions: many_actions,
-+        };
-+
-+        let embed = DiscordProvider::create_discord_embed(&notification);
-+        
-+        // Should handle many actions without exceeding limits
-+        let description = embed.description.unwrap();
-+        assert!(description.len() <= DiscordProvider::MAX_EMBED_DESCRIPTION_LENGTH);
-+        assert!(description.contains("**Suggested responses:**"));
-+        
-+        // Test with empty actions
-+        let notification_no_actions = RichNotification {
-+            title: "No Actions".to_string(),
-+            summary: "Summary".to_string(),
-+            context: "Context".to_string(),
-+            actions: vec![],
-+        };
-+
-+        let embed_no_actions = DiscordProvider::create_discord_embed(&notification_no_actions);
-+        let description_no_actions = embed_no_actions.description.unwrap();
-+        assert!(!description_no_actions.contains("**Suggested responses:**"));
-+    }
-+
-+    #[tokio::test]
-+    async fn test_markdown_safety() {
-+        // Test potentially problematic markdown
-+        let notification = RichNotification {
-+            title: "Markdown Test".to_string(),
-+            summary: "Text with ``` unclosed code block".to_string(),
-+            context: "Text with **unclosed bold".to_string(),
-+            actions: vec!["Action with [incomplete link".to_string()],
-+        };
-+
-+        let embed = DiscordProvider::create_discord_embed(&notification);
-+        
-+        // Should not panic or cause issues
-+        assert!(embed.title.is_some());
-+        assert!(embed.description.is_some());
-+        
-+        // Discord handles markdown parsing, we just ensure no crashes
-+        let description = embed.description.unwrap();
-+        assert!(description.contains("unclosed"));
-+    }
-+
-+    #[tokio::test]
-+    async fn test_user_id_handling() {
-+        // Test various user ID formats
-+        let test_cases = vec![
-+            (123456789u64, true),  // Valid
-+            (0u64, false),         // Invalid (zero)
-+            (u64::MAX, true),      // Valid (max value)
-+            (1u64, true),          // Valid (minimum positive)
-+        ];
-+
-+        for (user_id, should_be_valid) in test_cases {
-+            let user_id_str = user_id.to_string();
-+            let validation_result = DiscordProvider::validate_user_id(&user_id_str);
-+            
-+            if should_be_valid {
-+                assert!(validation_result.is_ok(), "User ID {} should be valid", user_id);
-+            } else {
-+                assert!(validation_result.is_err(), "User ID {} should be invalid", user_id);
-+            }
-+        }
-+    }
-+} 
-\ No newline at end of file
-diff --git a/crates/goose-cli/src/notifier/providers/mod.rs b/crates/goose-cli/src/notifier/providers/mod.rs
-new file mode 100644
-index 0000000000..010402e399
---- /dev/null
-+++ b/crates/goose-cli/src/notifier/providers/mod.rs
-@@ -0,0 +1,7 @@
-+// Provider implementations for different notification services
-+
-+pub mod slack;
-+pub mod discord;
-+
-+pub use slack::SlackProvider;
-+pub use discord::DiscordProvider; 
-\ No newline at end of file
-diff --git a/crates/goose-cli/src/notifier/providers/slack.rs b/crates/goose-cli/src/notifier/providers/slack.rs
-new file mode 100644
-index 0000000000..f50c032c48
---- /dev/null
-+++ b/crates/goose-cli/src/notifier/providers/slack.rs
-@@ -0,0 +1,627 @@
-+//! Slack notification provider using Socket Mode for bidirectional communication
-+
-+use anyhow::{anyhow, Result};
-+use async_trait::async_trait;
-+use slack_morphism::prelude::*;
-+use tokio::sync::mpsc;
-+use tokio::time::Instant;
-+use std::sync::Arc;
-+use tokio::sync::Mutex;
-+
-+use crate::notifier::{NotificationProvider, NotificationReply, RichNotification};
-+
-+/// Slack provider using Socket Mode for bidirectional communication
-+pub struct SlackProvider {
-+    client: SlackHyperClient,
-+    app_token: String,
-+    bot_token: String,
-+    channel: Option<String>,
-+    /// Track socket connection for cleanup
-+    socket_handle: Arc<Mutex<Option<tokio::task::JoinHandle<()>>>>,
-+}
-+
-+impl SlackProvider {
-+    /// Create a new Slack provider
-+    pub async fn new(
-+        app_token: String, 
-+        bot_token: String, 
-+        channel: Option<String>
-+    ) -> Result<Self> {
-+        let client = SlackClient::new(SlackClientHyperConnector::new()?);
-+        
-+        Ok(Self {
-+            client,
-+            app_token,
-+            bot_token,
-+            channel,
-+            socket_handle: Arc::new(Mutex::new(None)),
-+        })
-+    }
-+
-+    /// Truncate text to fit Slack limits
-+    fn truncate_for_slack(text: &str, max_len: usize) -> String {
-+        if text.len() <= max_len {
-+            text.to_string()
-+        } else {
-+            format!("{}...\n\n[Message truncated]", &text[..max_len.saturating_sub(25)])
-+        }
-+    }
-+}
-+
-+#[async_trait]
-+impl NotificationProvider for SlackProvider {
-+    async fn send_rich(&self, notification: &RichNotification) -> Result<()> {
-+        let token = SlackApiToken::new(self.bot_token.as_str().into());
-+        let session = self.client.open_session(&token);
-+        
-+        let channel = self.channel.as_ref()
-+            .ok_or_else(|| anyhow!("Slack channel not configured"))?;
-+        
-+        // Slack has a 3000 character limit for block text
-+        let summary = Self::truncate_for_slack(&notification.summary, 2000);
-+        
-+        // Build rich message with blocks
-+        let mut blocks = vec![
-+            SlackBlock::Section(SlackSectionBlock::new(
-+                SlackText::new().with_type(SlackTextType::PlainText)
-+                    .with_text(format!("ü¶Ü Goose Notification")),
-+            ).with_text(
-+                SlackText::new().with_type(SlackTextType::MarkDown)
-+                    .with_text(summary),
-+            )),
-+        ];
-+        
-+        // Add fallback preview if available
-+        if let Some(preview) = &notification.fallback_preview {
-+            let truncated_preview = Self::truncate_for_slack(preview, 800);
-+            blocks.push(SlackBlock::Section(SlackSectionBlock::new(
-+                SlackText::new().with_type(SlackTextType::MarkDown)
-+                    .with_text(format!("*Suggested response:*\n```{}```", truncated_preview)),
-+            )));
-+        }
-+        
-+        // Add context about the wait type
-+        let context_text = match notification.wait_type {
-+            crate::notifier::intelligence::WaitType::NextTask => "‚è≥ Waiting for next task",
-+            crate::notifier::intelligence::WaitType::UserReply => "‚ùì Waiting for your reply",
-+            crate::notifier::intelligence::WaitType::ToolConfirmation => "üîß Tool confirmation",
-+        };
-+        
-+        blocks.push(SlackBlock::Context(SlackContextBlock::new(vec![
-+            SlackContextBlockElement::PlainText(
-+                SlackText::new().with_type(SlackTextType::PlainText)
-+                    .with_text(context_text.to_string())
-+            )
-+        ])));
-+        
-+        let post_message_req = SlackApiChatPostMessageRequest::new(
-+            channel.clone().into(),
-+            SlackMessageContent::new().with_blocks(blocks),
-+        );
-+        
-+        session.chat_post_message(&post_message_req).await
-+            .map_err(|e| anyhow!("Failed to send Slack message: {}", e))?;
-+        
-+        Ok(())
-+    }
-+    
-+    async fn start_listening(&self, reply_sender: mpsc::Sender<NotificationReply>) -> Result<()> {
-+        let app_token = SlackApiToken::new(self.app_token.as_str().into());
-+        let bot_token = SlackApiToken::new(self.bot_token.as_str().into());
-+        
-+        let socket_mode_listener = SlackSocketModeListener::new(
-+            &SlackSocketModeListenerConfig::new(),
-+            self.client.clone(),
-+            app_token,
-+        );
-+        
-+        let client = self.client.clone();
-+        let sender = reply_sender.clone();
-+        
-+        // Start the socket mode listener
-+        let handle = tokio::spawn(async move {
-+            let mut events_stream = socket_mode_listener.listen_for_events().await;
-+            
-+            while let Some(socket_event) = events_stream.recv().await {
-+                match socket_event {
-+                    SlackSocketModeEvent::Event(event_callback) => {
-+                        // Handle different types of events
-+                        if let Some(slack_event) = event_callback.event {
-+                            match slack_event {
-+                                SlackEventCallbackBody::Message(message_event) => {
-+                                    // Only process direct messages to our bot
-+                                    if let Some(channel_type) = message_event.channel_type {
-+                                        if channel_type == SlackChannelType::Im {
-+                                            // This is a DM - process it as a reply
-+                                            if let Some(text) = message_event.text {
-+                                                let reply = NotificationReply {
-+                                                    provider: "Slack".to_string(),
-+                                                    user_id: message_event.user.unwrap_or_default().to_string(),
-+                                                    message: text,
-+                                                    timestamp: Instant::now(),
-+                                                };
-+                                                
-+                                                if let Err(e) = sender.send(reply).await {
-+                                                    eprintln!("Failed to send Slack reply: {}", e);
-+                                                }
-+                                            }
-+                                        }
-+                                    }
-+                                }
-+                                _ => {
-+                                    // Handle other event types if needed
-+                                }
-+                            }
-+                        }
-+                        
-+                        // Acknowledge the event
-+                        if let Err(e) = socket_mode_listener.send_socket_mode_response(
-+                            SlackSocketModeResponse::new(event_callback.envelope_id),
-+                        ).await {
-+                            eprintln!("Failed to acknowledge Slack event: {}", e);
-+                        }
-+                    }
-+                    SlackSocketModeEvent::Hello => {
-+                        println!("üîó Slack Socket Mode connected");
-+                    }
-+                    SlackSocketModeEvent::Disconnect => {
-+                        println!("‚ùå Slack Socket Mode disconnected");
-+                        break;
-+                    }
-+                    SlackSocketModeEvent::EventsApiRateLimit(_) => {
-+                        println!("‚ö†Ô∏è Slack rate limited");
-+                    }
-+                }
-+            }
-+        });
-+        
-+        // Store the handle for cleanup
-+        {
-+            let mut socket_handle = self.socket_handle.lock().await;
-+            *socket_handle = Some(handle);
-+        }
-+        
-+        Ok(())
-+    }
-+    
-+    fn name(&self) -> &str {
-+        "Slack"
-+    }
-+}
-+
-+impl Drop for SlackProvider {
-+    fn drop(&mut self) {
-+        // Clean up the socket connection when the provider is dropped
-+        if let Ok(mut handle) = self.socket_handle.try_lock() {
-+            if let Some(h) = handle.take() {
-+                h.abort();
-+            }
-+        }
-+    }
-+} 
-+
-+#[cfg(test)]
-+mod tests {
-+    use super::*;
-+    use tokio::sync::mpsc;
-+    use tokio::time::{timeout, Duration};
-+    use serde_json::json;
-+
-+    fn create_test_slack_provider() -> SlackProvider {
-+        SlackProvider::new(
-+            "xoxb-test-token".to_string(),
-+            "xapp-test-token".to_string(),
-+        )
-+    }
-+
-+    #[test]
-+    fn test_slack_provider_creation() {
-+        let provider = create_test_slack_provider();
-+        assert_eq!(provider.name(), "Slack");
-+    }
-+
-+    #[test]
-+    fn test_validate_tokens() {
-+        // Valid tokens
-+        assert!(SlackProvider::validate_tokens("xoxb-123-456-789", "xapp-123-456-789").is_ok());
-+        
-+        // Invalid bot token
-+        assert!(SlackProvider::validate_tokens("invalid", "xapp-123-456-789").is_err());
-+        
-+        // Invalid app token  
-+        assert!(SlackProvider::validate_tokens("xoxb-123-456-789", "invalid").is_err());
-+        
-+        // Empty tokens
-+        assert!(SlackProvider::validate_tokens("", "").is_err());
-+    }
-+
-+    #[tokio::test]
-+    async fn test_format_slack_blocks_basic() {
-+        let notification = RichNotification {
-+            title: "Test Title".to_string(),
-+            summary: "Test summary message".to_string(),
-+            context: "Test context".to_string(),
-+            actions: vec![],
-+        };
-+
-+        let blocks = SlackProvider::format_slack_blocks(&notification);
-+        
-+        assert_eq!(blocks.len(), 2);
-+        
-+        // Check header block
-+        if let Some(header_value) = blocks[0].get("text").and_then(|t| t.get("text")) {
-+            assert_eq!(header_value, "ü¶Ü Test Title");
-+        } else {
-+            panic!("Header block not formatted correctly");
-+        }
-+        
-+        // Check content block
-+        if let Some(content_value) = blocks[1].get("text").and_then(|t| t.get("text")) {
-+            let content_str = content_value.as_str().unwrap();
-+            assert!(content_str.contains("Test summary message"));
-+            assert!(content_str.contains("Test context"));
-+        } else {
-+            panic!("Content block not formatted correctly");
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_format_slack_blocks_with_actions() {
-+        let notification = RichNotification {
-+            title: "Action Test".to_string(),
-+            summary: "Summary".to_string(),
-+            context: "Context".to_string(),
-+            actions: vec![
-+                "Continue with default settings".to_string(),
-+                "Ask for more details".to_string(),
-+            ],
-+        };
-+
-+        let blocks = SlackProvider::format_slack_blocks(&notification);
-+        
-+        // Should have header + content + actions
-+        assert_eq!(blocks.len(), 3);
-+        
-+        // Check actions block
-+        if let Some(elements) = blocks[2].get("elements").and_then(|e| e.as_array()) {
-+            assert_eq!(elements.len(), 2);
-+            
-+            // Check first action button
-+            if let Some(first_action) = elements[0].get("text").and_then(|t| t.get("text")) {
-+                assert_eq!(first_action, "Continue with default settings");
-+            } else {
-+                panic!("First action not formatted correctly");
-+            }
-+            
-+            // Check second action button
-+            if let Some(second_action) = elements[1].get("text").and_then(|t| t.get("text")) {
-+                assert_eq!(second_action, "Ask for more details");
-+            } else {
-+                panic!("Second action not formatted correctly");
-+            }
-+        } else {
-+            panic!("Actions block not formatted correctly");
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_format_slack_blocks_truncation() {
-+        // Create a very long summary that exceeds Slack's limits
-+        let long_summary = "x".repeat(5000);
-+        let long_context = "y".repeat(5000);
-+        
-+        let notification = RichNotification {
-+            title: "Truncation Test".to_string(),
-+            summary: long_summary.clone(),
-+            context: long_context.clone(),
-+            actions: vec![],
-+        };
-+
-+        let blocks = SlackProvider::format_slack_blocks(&notification);
-+        
-+        // Check that content is truncated properly
-+        if let Some(content_value) = blocks[1].get("text").and_then(|t| t.get("text")) {
-+            let content_str = content_value.as_str().unwrap();
-+            assert!(content_str.len() <= 3000, "Content should be truncated to 3000 chars");
-+            assert!(content_str.contains("..."), "Should indicate truncation");
-+        } else {
-+            panic!("Content block not found");
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_format_slack_blocks_special_characters() {
-+        let notification = RichNotification {
-+            title: "Special <>&\"' Test".to_string(),
-+            summary: "Summary with <script>alert('xss')</script>".to_string(),
-+            context: "Context with & symbols and \"quotes\"".to_string(),
-+            actions: vec!["Action with <>&\"'".to_string()],
-+        };
-+
-+        let blocks = SlackProvider::format_slack_blocks(&notification);
-+        
-+        // Slack handles escaping internally, but we should ensure no panics
-+        assert_eq!(blocks.len(), 3);
-+        
-+        // Check that all blocks are valid JSON
-+        for block in &blocks {
-+            let json_str = serde_json::to_string(block).expect("Should serialize to JSON");
-+            assert!(!json_str.is_empty());
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_truncate_for_slack() {
-+        // Test normal text (under limit)
-+        let short_text = "Short message";
-+        assert_eq!(SlackProvider::truncate_for_slack(short_text, 100), short_text);
-+        
-+        // Test exact limit
-+        let exact_text = "x".repeat(100);
-+        assert_eq!(SlackProvider::truncate_for_slack(&exact_text, 100), exact_text);
-+        
-+        // Test over limit
-+        let long_text = "x".repeat(150);
-+        let truncated = SlackProvider::truncate_for_slack(&long_text, 100);
-+        assert!(truncated.len() <= 100);
-+        assert!(truncated.ends_with("..."));
-+        
-+        // Test empty string
-+        assert_eq!(SlackProvider::truncate_for_slack("", 100), "");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_extract_message_from_slack_event() {
-+        // Valid DM event
-+        let dm_event = json!({
-+            "type": "message",
-+            "channel_type": "im",
-+            "user": "U123456",
-+            "text": "Hello from user",
-+            "ts": "1234567890.123"
-+        });
-+
-+        let result = SlackProvider::extract_message_from_event(&dm_event);
-+        assert!(result.is_some());
-+        let (user_id, message) = result.unwrap();
-+        assert_eq!(user_id, "U123456");
-+        assert_eq!(message, "Hello from user");
-+
-+        // Channel message (should be ignored)
-+        let channel_event = json!({
-+            "type": "message", 
-+            "channel": "C123456",
-+            "channel_type": "channel",
-+            "user": "U123456",
-+            "text": "Hello from channel"
-+        });
-+
-+        let result = SlackProvider::extract_message_from_event(&channel_event);
-+        assert!(result.is_none());
-+
-+        // Bot message (should be ignored)
-+        let bot_event = json!({
-+            "type": "message",
-+            "channel_type": "im",
-+            "bot_id": "B123456", 
-+            "text": "Hello from bot"
-+        });
-+
-+        let result = SlackProvider::extract_message_from_event(&bot_event);
-+        assert!(result.is_none());
-+
-+        // Missing required fields
-+        let invalid_event = json!({
-+            "type": "message"
-+        });
-+
-+        let result = SlackProvider::extract_message_from_event(&invalid_event);
-+        assert!(result.is_none());
-+    }
-+
-+    #[tokio::test]
-+    async fn test_extract_message_thread_replies() {
-+        // Thread reply (should be processed)
-+        let thread_event = json!({
-+            "type": "message",
-+            "channel_type": "im",
-+            "user": "U123456",
-+            "text": "Reply in thread",
-+            "thread_ts": "1234567890.123",
-+            "ts": "1234567890.124"
-+        });
-+
-+        let result = SlackProvider::extract_message_from_event(&thread_event);
-+        assert!(result.is_some());
-+        let (user_id, message) = result.unwrap();
-+        assert_eq!(user_id, "U123456");
-+        assert_eq!(message, "Reply in thread");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_extract_message_edge_cases() {
-+        // Empty text
-+        let empty_text_event = json!({
-+            "type": "message",
-+            "channel_type": "im", 
-+            "user": "U123456",
-+            "text": "",
-+            "ts": "1234567890.123"
-+        });
-+
-+        let result = SlackProvider::extract_message_from_event(&empty_text_event);
-+        assert!(result.is_some());
-+        let (_, message) = result.unwrap();
-+        assert_eq!(message, "");
-+
-+        // Very long text
-+        let long_text = "x".repeat(10000);
-+        let long_text_event = json!({
-+            "type": "message",
-+            "channel_type": "im",
-+            "user": "U123456", 
-+            "text": long_text,
-+            "ts": "1234567890.123"
-+        });
-+
-+        let result = SlackProvider::extract_message_from_event(&long_text_event);
-+        assert!(result.is_some());
-+        let (_, message) = result.unwrap();
-+        assert_eq!(message, long_text);
-+
-+        // Non-string user ID
-+        let invalid_user_event = json!({
-+            "type": "message",
-+            "channel_type": "im",
-+            "user": 123456,
-+            "text": "Hello",
-+            "ts": "1234567890.123"
-+        });
-+
-+        let result = SlackProvider::extract_message_from_event(&invalid_user_event);
-+        assert!(result.is_none());
-+    }
-+
-+    #[tokio::test]
-+    async fn test_slack_api_request_structure() {
-+        let notification = RichNotification {
-+            title: "API Test".to_string(),
-+            summary: "Testing API request format".to_string(),
-+            context: "Context for API".to_string(),
-+            actions: vec!["Test Action".to_string()],
-+        };
-+
-+        let blocks = SlackProvider::format_slack_blocks(&notification);
-+
-+        // Verify blocks can be serialized to JSON (simulates API request)
-+        let serialized = serde_json::to_string(&blocks).expect("Should serialize");
-+        assert!(!serialized.is_empty());
-+
-+        // Verify blocks can be deserialized back
-+        let deserialized: Vec<serde_json::Value> = serde_json::from_str(&serialized)
-+            .expect("Should deserialize");
-+        assert_eq!(deserialized.len(), blocks.len());
-+    }
-+
-+    #[tokio::test]
-+    async fn test_send_rich_error_handling() {
-+        let provider = create_test_slack_provider();
-+        let notification = RichNotification {
-+            title: "Error Test".to_string(),
-+            summary: "Testing error handling".to_string(),
-+            context: "Error context".to_string(),
-+            actions: vec![],
-+        };
-+
-+        // This should fail with network error since we're using test tokens
-+        let result = provider.send_rich(&notification).await;
-+        assert!(result.is_err());
-+        
-+        // Error should contain useful information
-+        let error_msg = result.unwrap_err().to_string();
-+        assert!(error_msg.contains("Failed to send Slack notification") ||
-+                error_msg.contains("network") ||
-+                error_msg.contains("connection"));
-+    }
-+
-+    #[tokio::test]
-+    async fn test_start_listening_channel_setup() {
-+        let provider = create_test_slack_provider();
-+        let (tx, mut rx) = mpsc::channel(10);
-+
-+        // This will fail due to invalid tokens, but we test the setup
-+        let result = provider.start_listening(tx).await;
-+        assert!(result.is_err());
-+        
-+        // Should not receive any messages since connection failed
-+        let receive_result = timeout(Duration::from_millis(100), rx.recv()).await;
-+        assert!(receive_result.is_err()); // Timeout expected
-+    }
-+
-+    #[tokio::test]
-+    async fn test_concurrent_send_operations() {
-+        let provider = Arc::new(create_test_slack_provider());
-+        let notification = Arc::new(RichNotification {
-+            title: "Concurrency Test".to_string(),
-+            summary: "Testing concurrent sends".to_string(),
-+            context: "Concurrent context".to_string(),
-+            actions: vec![],
-+        });
-+
-+        // Try to send multiple notifications concurrently
-+        let futures = (0..5).map(|i| {
-+            let provider = provider.clone();
-+            let notification = notification.clone();
-+            async move {
-+                provider.send_rich(&notification).await
-+            }
-+        });
-+
-+        let results: Vec<_> = futures::future::join_all(futures).await;
-+
-+        // All should fail with the same error (invalid tokens)
-+        for result in results {
-+            assert!(result.is_err());
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_memory_safety_large_notifications() {
-+        let provider = create_test_slack_provider();
-+        
-+        // Create notification with very large content
-+        let large_content = "ü¶Ü".repeat(50000); // Unicode to test encoding
-+        let notification = RichNotification {
-+            title: large_content.clone(),
-+            summary: large_content.clone(),
-+            context: large_content.clone(),
-+            actions: (0..100).map(|i| format!("Action {}", i)).collect(),
-+        };
-+
-+        // Should handle gracefully without panics
-+        let result = provider.send_rich(&notification).await;
-+        
-+        // Will fail due to test tokens, but shouldn't panic
-+        assert!(result.is_err());
-+    }
-+
-+    #[test]
-+    fn test_slack_constants() {
-+        // Verify our constants are reasonable
-+        assert!(SlackProvider::MAX_BLOCK_TEXT_LENGTH > 1000);
-+        assert!(SlackProvider::MAX_BLOCK_TEXT_LENGTH <= 3000);
-+    }
-+
-+    #[tokio::test]
-+    async fn test_block_structure_compliance() {
-+        let notification = RichNotification {
-+            title: "Compliance Test".to_string(),
-+            summary: "Testing Slack block structure compliance".to_string(),
-+            context: "Ensuring blocks follow Slack's Block Kit format".to_string(),
-+            actions: vec!["Test Action".to_string()],
-+        };
-+
-+        let blocks = SlackProvider::format_slack_blocks(&notification);
-+
-+        // Verify required fields are present
-+        for (i, block) in blocks.iter().enumerate() {
-+            // Every block should have a type
-+            assert!(block.contains_key("type"), "Block {} missing type", i);
-+            
-+            // Header and content blocks should have text
-+            if i < 2 {
-+                assert!(block.get("text").is_some(), "Block {} missing text", i);
-+                
-+                if let Some(text_obj) = block.get("text").and_then(|t| t.as_object()) {
-+                    assert!(text_obj.contains_key("type"), "Text object missing type");
-+                    assert!(text_obj.contains_key("text"), "Text object missing text");
-+                }
-+            }
-+            
-+            // Actions block should have elements
-+            if i == 2 {
-+                assert!(block.get("elements").is_some(), "Actions block missing elements");
-+            }
-+        }
-+    }
-+} 
-\ No newline at end of file
-diff --git a/crates/goose-cli/src/session/builder.rs b/crates/goose-cli/src/session/builder.rs
-index 9782dea333..1ed0110fcd 100644
---- a/crates/goose-cli/src/session/builder.rs
-+++ b/crates/goose-cli/src/session/builder.rs
-@@ -408,6 +408,9 @@ pub async fn build_session(session_config: SessionBuilderConfig) -> Session {
-         edit_mode,
-     );
- 
-+    // Initialize notifier if enabled
-+    session.init_notifier().await;
-+
-     // Add extensions if provided
-     for extension_str in session_config.extensions {
-         if let Err(e) = session.add_extension(extension_str.clone()).await {
-diff --git a/crates/goose-cli/src/session/completion.rs b/crates/goose-cli/src/session/completion.rs
-index 8468e944d8..16d4bb5dd0 100644
---- a/crates/goose-cli/src/session/completion.rs
-+++ b/crates/goose-cli/src/session/completion.rs
-@@ -130,6 +130,9 @@ impl GooseCompleter {
-             "/prompt",
-             "/mode",
-             "/recipe",
-+            "/summarize",
-+            #[cfg(feature = "notifications")]
-+            "/notifications",
-         ];
- 
-         // Find commands that match the prefix
-diff --git a/crates/goose-cli/src/session/input.rs b/crates/goose-cli/src/session/input.rs
-index 2adea80a75..e26d2f1956 100644
---- a/crates/goose-cli/src/session/input.rs
-+++ b/crates/goose-cli/src/session/input.rs
-@@ -21,6 +21,8 @@ pub enum InputResult {
-     Clear,
-     Recipe(Option<String>),
-     Summarize,
-+    #[cfg(feature = "notifications")]
-+    Notifications,
- }
- 
- #[derive(Debug)]
-@@ -96,6 +98,8 @@ fn handle_slash_command(input: &str) -> Option<InputResult> {
-     const CMD_CLEAR: &str = "/clear";
-     const CMD_RECIPE: &str = "/recipe";
-     const CMD_SUMMARIZE: &str = "/summarize";
-+    #[cfg(feature = "notifications")]
-+    const CMD_NOTIFICATIONS: &str = "/notifications";
- 
-     match input {
-         "/exit" | "/quit" => Some(InputResult::Exit),
-@@ -156,6 +160,8 @@ fn handle_slash_command(input: &str) -> Option<InputResult> {
-         s if s == CMD_CLEAR => Some(InputResult::Clear),
-         s if s.starts_with(CMD_RECIPE) => parse_recipe_command(s),
-         s if s == CMD_SUMMARIZE => Some(InputResult::Summarize),
-+        #[cfg(feature = "notifications")]
-+        s if s == CMD_NOTIFICATIONS => Some(InputResult::Notifications),
-         _ => None,
-     }
- }
-@@ -266,6 +272,7 @@ fn print_help() {
- /recipe [filepath] - Generate a recipe from the current conversation and save it to the specified filepath (must end with .yaml).
-                        If no filepath is provided, it will be saved to ./recipe.yaml.
- /summarize - Summarize the current conversation to reduce context length while preserving key information.
-+/notifications - Show notification system status (if notifications feature is enabled)
- /? or /help - Display this help message
- /clear - Clears the current chat history
- 
-@@ -511,4 +518,12 @@ mod tests {
-         let result = handle_slash_command("  /summarize  ");
-         assert!(matches!(result, Some(InputResult::Summarize)));
-     }
-+
-+    #[cfg(feature = "notifications")]
-+    #[test]
-+    fn test_notifications_command() {
-+        // Test the notifications command
-+        let result = handle_slash_command("/notifications");
-+        assert!(matches!(result, Some(InputResult::Notifications)));
-+    }
- }
-diff --git a/crates/goose-cli/src/session/mod.rs b/crates/goose-cli/src/session/mod.rs
-index 429ceaa94d..f697162a3e 100644
---- a/crates/goose-cli/src/session/mod.rs
-+++ b/crates/goose-cli/src/session/mod.rs
-@@ -33,6 +33,7 @@ use mcp_core::prompt::PromptMessage;
- use mcp_core::protocol::JsonRpcMessage;
- use mcp_core::protocol::JsonRpcNotification;
- 
-+use crate::notifier::{Notifier, NotificationConfig, MessageInjectionCallback};
- use rand::{distributions::Alphanumeric, Rng};
- use rustyline::EditMode;
- use serde_json::Value;
-@@ -58,6 +59,8 @@ pub struct Session {
-     scheduled_job_id: Option<String>, // ID of the scheduled job that triggered this session
-     max_turns: Option<u32>,
-     edit_mode: Option<EditMode>,
-+    notifier: Option<Arc<Notifier>>,
-+    pending_notification_messages: Option<Arc<Mutex<Vec<Message>>>>,
- }
- 
- // Cache structure for completion data
-@@ -145,9 +148,112 @@ impl Session {
-             scheduled_job_id,
-             max_turns,
-             edit_mode,
-+            notifier: None,
-+            pending_notification_messages: None,
-         }
-     }
- 
-+    /// Initialize the notifier from environment variables and configuration
-+    pub async fn init_notifier(&mut self) {
-+        // Check if notifications are enabled
-+        let enabled = std::env::var("GOOSE_NOTIFICATIONS_ENABLED")
-+            .ok()
-+            .and_then(|v| v.parse::<bool>().ok())
-+            .unwrap_or(false);
-+        
-+        if !enabled {
-+            return;
-+        }
-+        
-+        // Validate configuration before proceeding
-+        if let Err(e) = Notifier::validate_config() {
-+            eprintln!("‚ùå Notification configuration invalid:");
-+            eprintln!("{}", e);
-+            eprintln!("Notifications will be disabled.");
-+            return;
-+        }
-+
-+        // Parse timeout settings from environment
-+        let ping_timeout = std::env::var("GOOSE_PING_TIMEOUT")
-+            .ok()
-+            .and_then(|v| v.parse::<u64>().ok())
-+            .unwrap_or(300); // Default 5 minutes
-+        
-+        let fallback_timeout = std::env::var("GOOSE_FALLBACK_TIMEOUT")
-+            .ok()
-+            .and_then(|v| v.parse::<u64>().ok())
-+            .unwrap_or(300); // Default 5 minutes
-+        
-+        // Get prompts directory
-+        let prompts_dir = std::env::var("GOOSE_PROMPTS_DIR")
-+            .map(PathBuf::from)
-+            .unwrap_or_else(|_| PathBuf::from("crates/goose-cli/prompts"));
-+        
-+        // Create notifier configuration
-+        let config = NotificationConfig {
-+            ping_timeout,
-+            fallback_timeout,
-+            enabled,
-+            prompts_dir,
-+        };
-+        
-+        // Create and initialize notifier
-+        let mut notifier = Notifier::new(config);
-+        
-+        // Set the LLM provider from the agent
-+        match self.agent.provider().await {
-+            Ok(provider) => {
-+                notifier.set_llm_provider(provider);
-+            }
-+            Err(e) => {
-+                eprintln!("Failed to get LLM provider for notifications: {}", e);
-+                eprintln!("Notifications will be basic without summaries");
-+            }
-+        }
-+        
-+        // Create a weak reference to avoid circular dependency
-+        let session_file = self.session_file.clone();
-+        let scheduled_job_id = self.scheduled_job_id.clone();
-+        
-+        // Set up message injection callback
-+        let messages = Arc::new(Mutex::new(Vec::<Message>::new()));
-+        let pending_messages = messages.clone();
-+        
-+        let callback: MessageInjectionCallback = Arc::new(move |message| {
-+            let pending = pending_messages.clone();
-+            
-+            Box::pin(async move {
-+                // Add the message to a queue for processing
-+                let mut queue = pending.lock().await;
-+                queue.push(message);
-+                
-+                println!("üì± Notification reply received and queued for processing");
-+                Ok(())
-+            })
-+        });
-+        
-+        notifier.set_message_injection_callback(callback);
-+        
-+        // Store the pending messages queue for later processing
-+        self.pending_notification_messages = Some(messages);
-+        
-+        // Initialize providers from environment
-+        if let Err(e) = notifier.init_from_env().await {
-+            eprintln!("Failed to initialize notification providers: {}", e);
-+            return;
-+        }
-+        
-+        let notifier_arc = Arc::new(notifier);
-+        
-+        // Start monitoring task
-+        let _monitor_handle = notifier_arc.clone().start_monitoring();
-+        
-+        // Store the notifier
-+        self.notifier = Some(notifier_arc);
-+        
-+        println!("üîî Intelligent notifications enabled (ping: {}s, fallback: {}s)", ping_timeout, fallback_timeout);
-+    }
-+
-     /// Helper function to summarize context messages
-     async fn summarize_context_messages(
-         messages: &mut Vec<Message>,
-@@ -455,17 +561,68 @@ impl Session {
- 
-         output::display_greeting();
-         loop {
-+            // Process any pending notification messages first
-+            if let Some(pending_messages) = &self.pending_notification_messages {
-+                let mut queue = pending_messages.lock().await;
-+                if !queue.is_empty() {
-+                    // Process all pending messages
-+                    for message in queue.drain(..) {
-+                        println!("üì± Processing notification reply: {}", 
-+                            message.content.iter()
-+                                .filter_map(|c| match c {
-+                                    MessageContent::Text(text) => Some(text.text.as_str()),
-+                                    _ => None,
-+                                })
-+                                .collect::<Vec<_>>()
-+                                .join(" ")
-+                        );
-+                        
-+                        // Add to conversation and process
-+                        self.push_message(message);
-+                        
-+                        // Save session
-+                        if let Some(session_file) = &self.session_file {
-+                            session::persist_messages_with_schedule_id(
-+                                session_file,
-+                                &self.messages,
-+                                None,
-+                                self.scheduled_job_id.clone(),
-+                            ).await?;
-+                        }
-+                        
-+                        // Process the injected message
-+                        output::show_thinking();
-+                        self.process_agent_response(true).await?;
-+                        output::hide_thinking();
-+                    }
-+                    
-+                    // Continue to show prompt normally after processing
-+                    continue;
-+                }
-+            }
-+            
-+            // Update notifier with current messages and mark waiting
-+            if let Some(notifier) = &self.notifier {
-+                notifier.update_messages(&self.messages).await;
-+                notifier.mark_waiting_for_input().await;
-+            }
-+            
-             // Display context usage before each prompt
-             self.display_context_usage().await?;
- 
-             match input::get_input(&mut editor)? {
-                 input::InputResult::Message(content) => {
-+                    // Mark that user input was received
-+                    if let Some(notifier) = &self.notifier {
-+                        notifier.mark_user_input_received().await;
-+                    }
-+                    
-                     match self.run_mode {
-                         RunMode::Normal => {
-                             save_history(&mut editor);
- 
-                             self.push_message(Message::user().with_text(&content));
--
-+                            
-                             // Track the current directory and last instruction in projects.json
-                             let session_id = self
-                                 .session_file
-@@ -494,7 +651,7 @@ impl Session {
-                                 )
-                                 .await?;
-                             }
--
-+                            
-                             output::show_thinking();
-                             self.process_agent_response(true).await?;
-                             output::hide_thinking();
-@@ -725,6 +882,17 @@ impl Session {
- 
-                     continue;
-                 }
-+                #[cfg(feature = "notifications")]
-+                InputResult::Notifications => {
-+                    if let Some(notifier) = &self.notifier {
-+                        notifier.display_status().await;
-+                    } else {
-+                        println!("üîï Notifications are not enabled");
-+                        println!("   Set GOOSE_NOTIFICATIONS_ENABLED=true and configure providers");
-+                        println!("   Build with: cargo build --features notifications");
-+                    }
-+                    continue;
-+                }
-             }
-         }
- 
-@@ -849,25 +1017,49 @@ impl Session {
-                             if let Some(MessageContent::ToolConfirmationRequest(confirmation)) = message.content.first() {
-                                 output::hide_thinking();
- 
-+                                // For tool confirmations, don't send notifications
-+                                // Mark that we're waiting for user input (notifier will check wait type)
-+                                if let Some(notifier) = &self.notifier {
-+                                    notifier.update_messages(&self.messages).await;
-+                                    notifier.mark_waiting_for_input().await;
-+                                }
-+
-                                 // Format the confirmation prompt
-                                 let prompt = "Goose would like to call the above tool, do you allow?".to_string();
- 
--                                // Get confirmation from user
--                                let permission_result = cliclack::select(prompt)
--                                    .item(Permission::AllowOnce, "Allow", "Allow the tool call once")
--                                    .item(Permission::AlwaysAllow, "Always Allow", "Always allow the tool call")
--                                    .item(Permission::DenyOnce, "Deny", "Deny the tool call")
--                                    .item(Permission::Cancel, "Cancel", "Cancel the AI response and tool call")
--                                    .interact();
--
--                                let permission = match permission_result {
--                                    Ok(p) => p, // If Ok, use the selected permission
--                                    Err(e) => {
--                                        // Check if the error is an interruption (Ctrl+C/Cmd+C, Escape)
--                                        if e.kind() == std::io::ErrorKind::Interrupted {
--                                            Permission::Cancel // If interrupted, set permission to Cancel
--                                        } else {
--                                            return Err(e.into()); // Otherwise, convert and propagate the original error
-+                                // Check if we should auto-approve due to timeout
-+                                let should_auto_approve = if let Some(notifier) = &self.notifier {
-+                                    notifier.should_take_fallback_action().await
-+                                } else {
-+                                    false
-+                                };
-+
-+                                let permission = if should_auto_approve {
-+                                    output::render_text("Auto-approving tool call due to timeout...", Some(Color::Yellow), true);
-+                                    Permission::AllowOnce
-+                                } else {
-+                                    // Get confirmation from user
-+                                    let permission_result = cliclack::select(prompt)
-+                                        .item(Permission::AllowOnce, "Allow", "Allow the tool call once")
-+                                        .item(Permission::AlwaysAllow, "Always Allow", "Always allow the tool call")
-+                                        .item(Permission::DenyOnce, "Deny", "Deny the tool call")
-+                                        .item(Permission::Cancel, "Cancel", "Cancel the AI response and tool call")
-+                                        .interact();
-+
-+                                    // Mark that user input was received
-+                                    if let Some(notifier) = &self.notifier {
-+                                        notifier.mark_user_input_received().await;
-+                                    }
-+
-+                                    match permission_result {
-+                                        Ok(p) => p, // If Ok, use the selected permission
-+                                        Err(e) => {
-+                                            // Check if the error is an interruption (Ctrl+C/Cmd+C, Escape)
-+                                            if e.kind() == std::io::ErrorKind::Interrupted {
-+                                                Permission::Cancel // If interrupted, set permission to Cancel
-+                                            } else {
-+                                                return Err(e.into()); // Otherwise, convert and propagate the original error
-+                                            }
-                                         }
-                                     }
-                                 };
-@@ -993,6 +1185,16 @@ impl Session {
-                                 if interactive {output::hide_thinking()};
-                                 let _ = progress_bars.hide();
-                                 output::render_message(&message, self.debug);
-+                                
-+                                // Mark that an LLM response was received
-+                                if message.role == "assistant" {
-+                                    if let Some(notifier) = &self.notifier {
-+                                        notifier.mark_response_received().await;
-+                                        
-+                                        // Update the notifier with current messages
-+                                        notifier.update_messages(&self.messages).await;
-+                                    }
-+                                }
-                             }
-                         }
-                         Some(Ok(AgentEvent::McpNotification((_id, message)))) => {
-@@ -1498,6 +1700,8 @@ impl Session {
-     fn push_message(&mut self, message: Message) {
-         push_message(&mut self.messages, message);
-     }
-+
-+
- }
- 
- fn get_reasoner() -> Result<Arc<dyn Provider>, anyhow::Error> {
-diff --git a/crates/goose-cli/tests/intelligent_notifier_test.rs b/crates/goose-cli/tests/intelligent_notifier_test.rs
-new file mode 100644
-index 0000000000..5136b2a7ba
---- /dev/null
-+++ b/crates/goose-cli/tests/intelligent_notifier_test.rs
-@@ -0,0 +1,248 @@
-+#[cfg(feature = "notifications")]
-+mod intelligent_notifier_tests {
-+    use goose_cli::notifier::{
-+        Notifier, NotificationConfig, NotificationProvider, NotificationReply, RichNotification,
-+        intelligence::{NotificationContext, NotificationIntelligence, WaitType, determine_wait_type},
-+        history::NotificationHistory,
-+    };
-+    use goose::message::{Message, MessageContent, TextContent};
-+    use goose::providers::base::{Provider, CompletionResponse};
-+    use std::sync::Arc;
-+    use std::path::PathBuf;
-+    use tokio::sync::{Mutex, mpsc};
-+    use tokio::time::{Duration, Instant};
-+    use anyhow::Result;
-+    use async_trait::async_trait;
-+
-+    /// Mock LLM provider for testing
-+    struct MockProvider {
-+        responses: Arc<Mutex<Vec<String>>>,
-+    }
-+
-+    #[async_trait]
-+    impl Provider for MockProvider {
-+        async fn complete(&self, prompt: &str) -> Result<CompletionResponse> {
-+            let mut responses = self.responses.lock().await;
-+            let response = if responses.is_empty() {
-+                format!("Mock response for: {}", prompt)
-+            } else {
-+                responses.remove(0)
-+            };
-+            
-+            Ok(CompletionResponse {
-+                content: response,
-+                usage: None,
-+            })
-+        }
-+        
-+        fn get_model(&self) -> String {
-+            "mock-model".to_string()
-+        }
-+        
-+        fn as_any(&self) -> &dyn std::any::Any {
-+            self
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_wait_type_detection() {
-+        // Test tool confirmation detection
-+        let mut msg = Message::assistant();
-+        msg.content.push(MessageContent::ToolConfirmationRequest(
-+            goose::message::ToolConfirmationRequest {
-+                id: "test".to_string(),
-+                tool_name: "test_tool".to_string(),
-+                arguments: serde_json::Value::Null,
-+            },
-+        ));
-+        
-+        assert_eq!(determine_wait_type(&[msg]), WaitType::ToolConfirmation);
-+        
-+        // Test question detection
-+        let mut msg = Message::assistant();
-+        msg.content.push(MessageContent::Text(TextContent {
-+            text: "Which file would you like me to edit?".to_string(),
-+        }));
-+        
-+        assert_eq!(determine_wait_type(&[msg]), WaitType::UserReply);
-+        
-+        // Test next task detection
-+        let mut msg = Message::assistant();
-+        msg.content.push(MessageContent::Text(TextContent {
-+            text: "I've successfully updated the configuration file.".to_string(),
-+        }));
-+        
-+        assert_eq!(determine_wait_type(&[msg]), WaitType::NextTask);
-+    }
-+
-+    #[tokio::test]
-+    async fn test_notification_intelligence() {
-+        let provider = Arc::new(MockProvider {
-+            responses: Arc::new(Mutex::new(vec![
-+                "Goose needs to know which file to edit.".to_string(),
-+                "Please specify the file path you'd like me to edit.".to_string(),
-+            ])),
-+        });
-+        
-+        let intelligence = NotificationIntelligence::new(
-+            provider.clone(),
-+            PathBuf::from("crates/goose-cli/prompts"),
-+        );
-+        
-+        let messages = vec![
-+            Message::user().with_text("Can you help me edit a file?"),
-+            Message::assistant().with_text("Which file would you like me to edit?"),
-+        ];
-+        
-+        let context = intelligence.generate_context(&messages, WaitType::UserReply).await.unwrap();
-+        
-+        assert_eq!(context.wait_type, WaitType::UserReply);
-+        assert_eq!(context.summary, "Goose needs to know which file to edit.");
-+        assert_eq!(context.precomputed_response, Some("Please specify the file path you'd like me to edit.".to_string()));
-+    }
-+
-+    #[tokio::test]
-+    async fn test_adaptive_timeout() {
-+        let mut history = NotificationHistory::new();
-+        
-+        // First notification uses base timeout
-+        assert_eq!(history.calculate_timeout(300), 300);
-+        assert!(history.should_send_follow_up());
-+        
-+        // Add unanswered notification
-+        history.add_notification(WaitType::NextTask, "Test notification".to_string());
-+        
-+        // Second notification uses reduced timeout
-+        assert_eq!(history.calculate_timeout(300), 60);
-+        assert!(!history.should_send_follow_up());
-+        
-+        // Mark as answered
-+        history.mark_last_answered();
-+        
-+        // Back to normal
-+        assert_eq!(history.calculate_timeout(300), 300);
-+        assert!(history.should_send_follow_up());
-+    }
-+
-+    /// Mock notification provider
-+    struct MockNotificationProvider {
-+        name: String,
-+        sent_notifications: Arc<Mutex<Vec<RichNotification>>>,
-+    }
-+
-+    #[async_trait]
-+    impl NotificationProvider for MockNotificationProvider {
-+        async fn send_rich(&self, notification: &RichNotification) -> Result<()> {
-+            let mut sent = self.sent_notifications.lock().await;
-+            sent.push(notification.clone());
-+            Ok(())
-+        }
-+        
-+        async fn start_listening(&self, _reply_sender: mpsc::Sender<NotificationReply>) -> Result<()> {
-+            Ok(())
-+        }
-+        
-+        fn name(&self) -> &str {
-+            &self.name
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_intelligent_notifier_flow() {
-+        let config = NotificationConfig {
-+            ping_timeout: 1,
-+            fallback_timeout: 1,
-+            enabled: true,
-+            prompts_dir: PathBuf::from("crates/goose-cli/prompts"),
-+        };
-+        
-+        let mut notifier = Notifier::new(config);
-+        
-+        // Set up mock provider
-+        let provider = Arc::new(MockProvider {
-+            responses: Arc::new(Mutex::new(vec![
-+                "Goose completed the task and is waiting for next instructions.".to_string(),
-+                "Continue with running tests for the updated code.".to_string(),
-+            ])),
-+        });
-+        
-+        notifier.set_llm_provider(provider);
-+        
-+        // Add mock notification provider
-+        let sent_notifications = Arc::new(Mutex::new(Vec::new()));
-+        notifier.add_provider(Box::new(MockNotificationProvider {
-+            name: "Mock".to_string(),
-+            sent_notifications: sent_notifications.clone(),
-+        }));
-+        
-+        // Update with test messages
-+        let messages = vec![
-+            Message::user().with_text("Update the authentication module"),
-+            Message::assistant().with_text("I've successfully updated the authentication module with the new security features."),
-+        ];
-+        
-+        notifier.update_messages(&messages).await;
-+        
-+        // Start monitoring
-+        let notifier_arc = Arc::new(notifier);
-+        let _handle = notifier_arc.clone().start_monitoring();
-+        
-+        // Mark response received and waiting
-+        notifier_arc.mark_response_received().await;
-+        notifier_arc.mark_waiting_for_input().await;
-+        
-+        // Wait for first notification
-+        tokio::time::sleep(Duration::from_secs(2)).await;
-+        
-+        let sent = sent_notifications.lock().await;
-+        assert_eq!(sent.len(), 1);
-+        assert!(sent[0].summary.contains("waiting for next instructions"));
-+        assert!(sent[0].fallback_preview.is_some());
-+        assert_eq!(sent[0].wait_type, WaitType::NextTask);
-+    }
-+
-+    #[tokio::test]
-+    async fn test_tool_confirmation_skip() {
-+        let config = NotificationConfig {
-+            ping_timeout: 1,
-+            fallback_timeout: 1,
-+            enabled: true,
-+            prompts_dir: PathBuf::from("crates/goose-cli/prompts"),
-+        };
-+        
-+        let mut notifier = Notifier::new(config);
-+        
-+        // Add mock notification provider
-+        let sent_notifications = Arc::new(Mutex::new(Vec::new()));
-+        notifier.add_provider(Box::new(MockNotificationProvider {
-+            name: "Mock".to_string(),
-+            sent_notifications: sent_notifications.clone(),
-+        }));
-+        
-+        // Update with tool confirmation message
-+        let mut msg = Message::assistant();
-+        msg.content.push(MessageContent::ToolConfirmationRequest(
-+            goose::message::ToolConfirmationRequest {
-+                id: "test".to_string(),
-+                tool_name: "test_tool".to_string(),
-+                arguments: serde_json::Value::Null,
-+            },
-+        ));
-+        
-+        notifier.update_messages(&[msg]).await;
-+        
-+        // Start monitoring
-+        let notifier_arc = Arc::new(notifier);
-+        let _handle = notifier_arc.clone().start_monitoring();
-+        
-+        // Mark response received and waiting
-+        notifier_arc.mark_response_received().await;
-+        notifier_arc.mark_waiting_for_input().await;
-+        
-+        // Wait to ensure no notification is sent
-+        tokio::time::sleep(Duration::from_secs(2)).await;
-+        
-+        let sent = sent_notifications.lock().await;
-+        assert_eq!(sent.len(), 0); // No notifications for tool confirmations
-+    }
-+} 
-\ No newline at end of file
-diff --git a/crates/goose-cli/tests/notification_comprehensive_test.rs b/crates/goose-cli/tests/notification_comprehensive_test.rs
-new file mode 100644
-index 0000000000..b5b2ac5f8a
---- /dev/null
-+++ b/crates/goose-cli/tests/notification_comprehensive_test.rs
-@@ -0,0 +1,715 @@
-+#[cfg(feature = "notifications")]
-+mod comprehensive_notification_tests {
-+    use goose_cli::notifier::{
-+        Notifier, NotificationConfig, NotificationProvider, NotificationReply, RichNotification,
-+        intelligence::{NotificationContext, NotificationIntelligence, WaitType},
-+        history::NotificationHistory,
-+    };
-+    use goose::message::{Message, MessageContent};
-+    use goose::providers::base::{Provider, CompletionResponse};
-+    use std::sync::Arc;
-+    use std::path::PathBuf;
-+    use std::collections::HashMap;
-+    use std::sync::atomic::{AtomicUsize, AtomicBool, Ordering};
-+    use tokio::sync::{Mutex, mpsc, RwLock};
-+    use tokio::time::{Duration, Instant, timeout, sleep};
-+    use anyhow::Result;
-+    use async_trait::async_trait;
-+    use tempfile::TempDir;
-+    use tokio::fs;
-+
-+    /// Comprehensive mock provider that simulates realistic behavior
-+    struct RealisticMockProvider {
-+        name: String,
-+        sent_notifications: Arc<RwLock<Vec<(Instant, RichNotification)>>>,
-+        failure_rate: Arc<AtomicUsize>, // 0-100 percentage
-+        response_delay: Duration,
-+        should_reply: Arc<AtomicBool>,
-+        reply_message: String,
-+        reply_delay: Duration,
-+        max_concurrent_sends: usize,
-+        current_sends: Arc<AtomicUsize>,
-+    }
-+
-+    impl RealisticMockProvider {
-+        fn new(name: String) -> Self {
-+            Self {
-+                name,
-+                sent_notifications: Arc::new(RwLock::new(Vec::new())),
-+                failure_rate: Arc::new(AtomicUsize::new(0)),
-+                response_delay: Duration::from_millis(50),
-+                should_reply: Arc::new(AtomicBool::new(false)),
-+                reply_message: "Got it, continuing...".to_string(),
-+                reply_delay: Duration::from_secs(2),
-+                max_concurrent_sends: 5,
-+                current_sends: Arc::new(AtomicUsize::new(0)),
-+            }
-+        }
-+
-+        fn with_failure_rate(mut self, rate: usize) -> Self {
-+            self.failure_rate.store(rate.min(100), Ordering::SeqCst);
-+            self
-+        }
-+
-+        fn with_auto_reply(mut self, delay: Duration, message: String) -> Self {
-+            self.should_reply.store(true, Ordering::SeqCst);
-+            self.reply_delay = delay;
-+            self.reply_message = message;
-+            self
-+        }
-+
-+        fn with_response_delay(mut self, delay: Duration) -> Self {
-+            self.response_delay = delay;
-+            self
-+        }
-+
-+        async fn get_sent_count(&self) -> usize {
-+            self.sent_notifications.read().await.len()
-+        }
-+
-+        async fn get_sent_notifications(&self) -> Vec<(Instant, RichNotification)> {
-+            self.sent_notifications.read().await.clone()
-+        }
-+
-+        fn simulate_network_failure(&self) -> bool {
-+            let failure_rate = self.failure_rate.load(Ordering::SeqCst);
-+            if failure_rate == 0 {
-+                return false;
-+            }
-+            
-+            // Simple deterministic failure based on current sends
-+            let current = self.current_sends.load(Ordering::SeqCst);
-+            (current * 17) % 100 < failure_rate // Pseudo-random based on sends
-+        }
-+    }
-+
-+    #[async_trait]
-+    impl NotificationProvider for RealisticMockProvider {
-+        async fn send_rich(&self, notification: &RichNotification) -> Result<()> {
-+            // Check concurrent send limit
-+            let current_sends = self.current_sends.fetch_add(1, Ordering::SeqCst);
-+            if current_sends >= self.max_concurrent_sends {
-+                self.current_sends.fetch_sub(1, Ordering::SeqCst);
-+                return Err(anyhow::anyhow!("Too many concurrent requests"));
-+            }
-+
-+            // Simulate network delay
-+            sleep(self.response_delay).await;
-+
-+            // Simulate random failures
-+            if self.simulate_network_failure() {
-+                self.current_sends.fetch_sub(1, Ordering::SeqCst);
-+                return Err(anyhow::anyhow!("Simulated network failure for {}", self.name));
-+            }
-+
-+            // Store the notification with timestamp
-+            {
-+                let mut notifications = self.sent_notifications.write().await;
-+                notifications.push((Instant::now(), notification.clone()));
-+            }
-+
-+            self.current_sends.fetch_sub(1, Ordering::SeqCst);
-+            Ok(())
-+        }
-+
-+        async fn start_listening(&self, reply_sender: mpsc::Sender<NotificationReply>) -> Result<()> {
-+            if self.should_reply.load(Ordering::SeqCst) {
-+                let reply_delay = self.reply_delay;
-+                let reply_message = self.reply_message.clone();
-+                let provider_name = self.name.clone();
-+                let should_reply = self.should_reply.clone();
-+                
-+                tokio::spawn(async move {
-+                    sleep(reply_delay).await;
-+                    
-+                    if should_reply.load(Ordering::SeqCst) {
-+                        let reply = NotificationReply {
-+                            provider: provider_name,
-+                            user_id: "test_user_123".to_string(),
-+                            message: reply_message,
-+                            timestamp: Instant::now(),
-+                        };
-+                        
-+                        let _ = reply_sender.send(reply).await;
-+                    }
-+                });
-+            }
-+            
-+            Ok(())
-+        }
-+
-+        fn name(&self) -> &str {
-+            &self.name
-+        }
-+    }
-+
-+    /// Comprehensive mock LLM provider with realistic behaviors
-+    struct RealisticLLMProvider {
-+        response_templates: Arc<RwLock<HashMap<String, Vec<String>>>>,
-+        call_count: Arc<AtomicUsize>,
-+        failure_rate: Arc<AtomicUsize>,
-+        response_delay: Duration,
-+        max_concurrent_calls: usize,
-+        current_calls: Arc<AtomicUsize>,
-+    }
-+
-+    impl RealisticLLMProvider {
-+        fn new() -> Self {
-+            let mut templates = HashMap::new();
-+            
-+            // Add realistic response templates
-+            templates.insert("summarize".to_string(), vec![
-+                "Goose is waiting for you to specify which authentication method to implement.".to_string(),
-+                "Goose needs to know the file path to continue editing.".to_string(),
-+                "Goose is asking for confirmation before making database changes.".to_string(),
-+                "Goose completed the task and is ready for your next instruction.".to_string(),
-+            ]);
-+            
-+            templates.insert("response".to_string(), vec![
-+                "Please let me know which authentication method you'd like to use (OAuth, JWT, or basic auth).".to_string(),
-+                "Provide the full path to the file you'd like me to edit.".to_string(),
-+                "Type 'yes' to confirm the database changes or 'no' to cancel.".to_string(),
-+                "I'll continue with implementing the user registration system.".to_string(),
-+            ]);
-+
-+            Self {
-+                response_templates: Arc::new(RwLock::new(templates)),
-+                call_count: Arc::new(AtomicUsize::new(0)),
-+                failure_rate: Arc::new(AtomicUsize::new(5)), // 5% failure rate
-+                response_delay: Duration::from_millis(200),
-+                max_concurrent_calls: 3,
-+                current_calls: Arc::new(AtomicUsize::new(0)),
-+            }
-+        }
-+
-+        fn set_failure_rate(self, rate: usize) -> Self {
-+            self.failure_rate.store(rate.min(100), Ordering::SeqCst);
-+            self
-+        }
-+
-+        fn get_call_count(&self) -> usize {
-+            self.call_count.load(Ordering::SeqCst)
-+        }
-+    }
-+
-+    #[async_trait]
-+    impl Provider for RealisticLLMProvider {
-+        async fn complete(&self, prompt: &str) -> Result<CompletionResponse> {
-+            let call_number = self.call_count.fetch_add(1, Ordering::SeqCst);
-+            
-+            // Check concurrent call limit
-+            let current_calls = self.current_calls.fetch_add(1, Ordering::SeqCst);
-+            if current_calls >= self.max_concurrent_calls {
-+                self.current_calls.fetch_sub(1, Ordering::SeqCst);
-+                return Err(anyhow::anyhow!("LLM provider overloaded"));
-+            }
-+
-+            // Simulate processing delay
-+            sleep(self.response_delay).await;
-+
-+            // Simulate failures
-+            let failure_rate = self.failure_rate.load(Ordering::SeqCst);
-+            if (call_number * 23) % 100 < failure_rate {
-+                self.current_calls.fetch_sub(1, Ordering::SeqCst);
-+                return Err(anyhow::anyhow!("LLM provider temporary failure"));
-+            }
-+
-+            // Determine response type based on prompt content
-+            let response_type = if prompt.to_lowercase().contains("summarize") || 
-+                               prompt.to_lowercase().contains("summary") {
-+                "summarize"
-+            } else {
-+                "response"
-+            };
-+
-+            // Get response from templates
-+            let response_content = {
-+                let templates = self.response_templates.read().await;
-+                if let Some(responses) = templates.get(response_type) {
-+                    let index = call_number % responses.len();
-+                    responses[index].clone()
-+                } else {
-+                    format!("Generic response for: {}", prompt.chars().take(100).collect::<String>())
-+                }
-+            };
-+
-+            self.current_calls.fetch_sub(1, Ordering::SeqCst);
-+
-+            Ok(CompletionResponse {
-+                content: response_content,
-+                usage: None,
-+            })
-+        }
-+
-+        fn get_model(&self) -> String {
-+            "mock-claude-3.5-sonnet".to_string()
-+        }
-+
-+        fn as_any(&self) -> &dyn std::any::Any {
-+            self
-+        }
-+    }
-+
-+    async fn setup_comprehensive_test_environment() -> (TempDir, Notifier, Arc<RealisticLLMProvider>) {
-+        let temp_dir = TempDir::new().unwrap();
-+        let prompts_dir = temp_dir.path().join("prompts");
-+        fs::create_dir(&prompts_dir).await.unwrap();
-+
-+        // Create realistic prompt templates
-+        let summary_template = r#"
-+You are helping summarize what Goose (an AI coding assistant) is waiting for.
-+
-+Recent conversation:
-+{{ messages }}
-+
-+Current wait type: {{ wait_type }}
-+
-+Provide a clear, concise summary (1-2 sentences) of what Goose needs from the user.
-+Focus on being helpful and specific.
-+"#;
-+
-+        let response_template = r#"
-+You are generating a helpful fallback response for a user who is away.
-+
-+Conversation context:
-+{{ messages }}
-+
-+Summary of what Goose is waiting for: {{ summary }}
-+Wait type: {{ wait_type }}
-+
-+Generate a reasonable response that would help Goose continue productively.
-+Be specific and actionable.
-+"#;
-+
-+        fs::write(prompts_dir.join("notification_summary.md"), summary_template).await.unwrap();
-+        fs::write(prompts_dir.join("notification_response.md"), response_template).await.unwrap();
-+
-+        // Create notification config
-+        let config = NotificationConfig {
-+            ping_timeout: 1,     // Fast for testing
-+            fallback_timeout: 2, // Fast for testing
-+            enabled: true,
-+            prompts_dir,
-+        };
-+
-+        let mut notifier = Notifier::new(config);
-+        let llm_provider = Arc::new(RealisticLLMProvider::new());
-+        notifier.set_llm_provider(llm_provider.clone());
-+
-+        (temp_dir, notifier, llm_provider)
-+    }
-+
-+    #[tokio::test]
-+    async fn test_complete_notification_workflow_with_reply() {
-+        let (_temp_dir, mut notifier, llm_provider) = setup_comprehensive_test_environment().await;
-+
-+        // Add provider that will auto-reply
-+        let provider = RealisticMockProvider::new("TestSlack".to_string())
-+            .with_auto_reply(Duration::from_secs(1), "Edit the main.rs file".to_string());
-+        let provider_notifications = provider.sent_notifications.clone();
-+        
-+        notifier.add_provider(Box::new(provider));
-+
-+        // Set up message injection tracking
-+        let injected_messages = Arc::new(Mutex::new(Vec::new()));
-+        let injection_tracker = injected_messages.clone();
-+        
-+        let callback = Arc::new(move |message: Message| {
-+            let tracker = injection_tracker.clone();
-+            Box::pin(async move {
-+                let mut messages = tracker.lock().await;
-+                messages.push(message);
-+                Ok(())
-+            })
-+        });
-+        
-+        notifier.set_message_injection_callback(callback);
-+
-+        // Create realistic conversation
-+        let messages = vec![
-+            Message::user().with_text("Help me refactor the authentication code"),
-+            Message::assistant().with_text("I can help with that. Which file contains the authentication code you'd like to refactor?"),
-+        ];
-+
-+        let notifier_arc = Arc::new(notifier);
-+
-+        // Start monitoring
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+
-+        // Simulate the workflow
-+        notifier_arc.update_messages(&messages).await;
-+        notifier_arc.mark_waiting_for_input().await;
-+
-+        // Wait for notification and reply processing
-+        sleep(Duration::from_secs(3)).await;
-+
-+        // Verify notification was sent
-+        let sent_notifications = provider_notifications.read().await;
-+        assert!(!sent_notifications.is_empty(), "Should have sent notification");
-+        
-+        let (timestamp, notification) = &sent_notifications[0];
-+        assert!(notification.summary.contains("file") || notification.summary.contains("authentication"), 
-+                "Summary should be relevant: {}", notification.summary);
-+
-+        // Verify message was injected
-+        let injected = injected_messages.lock().await;
-+        assert!(!injected.is_empty(), "Should have injected reply message");
-+        
-+        // Verify LLM was called for summarization
-+        assert!(llm_provider.get_call_count() > 0, "Should have called LLM for summarization");
-+
-+        monitor_handle.abort();
-+    }
-+
-+    #[tokio::test]
-+    async fn test_multiple_providers_with_different_behaviors() {
-+        let (_temp_dir, mut notifier, _llm_provider) = setup_comprehensive_test_environment().await;
-+
-+        // Add providers with different behaviors
-+        let slack_provider = RealisticMockProvider::new("Slack".to_string())
-+            .with_failure_rate(20) // 20% failure rate
-+            .with_response_delay(Duration::from_millis(100));
-+        let slack_notifications = slack_provider.sent_notifications.clone();
-+        
-+        let discord_provider = RealisticMockProvider::new("Discord".to_string())
-+            .with_failure_rate(5)  // 5% failure rate
-+            .with_response_delay(Duration::from_millis(200))
-+            .with_auto_reply(Duration::from_millis(500), "Continue with OAuth implementation".to_string());
-+        let discord_notifications = discord_provider.sent_notifications.clone();
-+
-+        notifier.add_provider(Box::new(slack_provider));
-+        notifier.add_provider(Box::new(discord_provider));
-+
-+        let messages = vec![
-+            Message::user().with_text("Implement user authentication"),
-+            Message::assistant().with_text("Which authentication method would you prefer?"),
-+        ];
-+
-+        let notifier_arc = Arc::new(notifier);
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+
-+        notifier_arc.update_messages(&messages).await;
-+        notifier_arc.mark_waiting_for_input().await;
-+
-+        // Wait for processing
-+        sleep(Duration::from_secs(2)).await;
-+
-+        // At least one provider should have succeeded
-+        let slack_count = slack_notifications.read().await.len();
-+        let discord_count = discord_notifications.read().await.len();
-+        
-+        assert!(slack_count > 0 || discord_count > 0, 
-+                "At least one provider should have sent notification (Slack: {}, Discord: {})", 
-+                slack_count, discord_count);
-+
-+        monitor_handle.abort();
-+    }
-+
-+    #[tokio::test]
-+    async fn test_adaptive_timeout_behavior() {
-+        let (_temp_dir, mut notifier, _llm_provider) = setup_comprehensive_test_environment().await;
-+
-+        let provider = RealisticMockProvider::new("AdaptiveTest".to_string());
-+        let provider_notifications = provider.sent_notifications.clone();
-+        notifier.add_provider(Box::new(provider));
-+
-+        let notifier_arc = Arc::new(notifier);
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+
-+        let messages = vec![
-+            Message::user().with_text("Create a new API endpoint"),
-+            Message::assistant().with_text("What should the endpoint do?"),
-+        ];
-+
-+        // First notification cycle (should use base timeout)
-+        notifier_arc.update_messages(&messages).await;
-+        notifier_arc.mark_waiting_for_input().await;
-+
-+        sleep(Duration::from_secs(1)).await; // Wait for first ping
-+        let first_count = provider_notifications.read().await.len();
-+        assert!(first_count > 0, "Should send first notification");
-+
-+        sleep(Duration::from_secs(2)).await; // Wait for fallback
-+        let second_count = provider_notifications.read().await.len();
-+        assert!(second_count > first_count, "Should send fallback notification");
-+
-+        // Mark as received and start new cycle
-+        notifier_arc.mark_user_input_received().await;
-+        
-+        // Second notification cycle (should use adaptive timeout)
-+        notifier_arc.mark_waiting_for_input().await;
-+        
-+        sleep(Duration::from_secs(3)).await;
-+        let final_count = provider_notifications.read().await.len();
-+        
-+        // Verify adaptive behavior (reduced frequency)
-+        assert!(final_count > second_count, "Should continue sending notifications");
-+
-+        monitor_handle.abort();
-+    }
-+
-+    #[tokio::test]
-+    async fn test_error_resilience_and_recovery() {
-+        let (_temp_dir, mut notifier, llm_provider) = setup_comprehensive_test_environment().await;
-+
-+        // Add provider with high failure rate initially
-+        let provider = RealisticMockProvider::new("FlakyProvider".to_string())
-+            .with_failure_rate(80); // 80% failure rate
-+        notifier.add_provider(Box::new(provider));
-+
-+        // Also make LLM fail frequently
-+        let llm_provider = llm_provider.set_failure_rate(60); // 60% failure rate
-+
-+        let messages = vec![
-+            Message::user().with_text("Debug the memory leak issue"),
-+            Message::assistant().with_text("I need more details about when the leak occurs."),
-+        ];
-+
-+        let notifier_arc = Arc::new(notifier);
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+
-+        notifier_arc.update_messages(&messages).await;
-+        notifier_arc.mark_waiting_for_input().await;
-+
-+        // Wait for multiple retry attempts
-+        sleep(Duration::from_secs(4)).await;
-+
-+        // System should continue operating despite failures
-+        // (This test primarily ensures no panics or hanging)
-+        
-+        // At least some LLM calls should have been attempted
-+        assert!(llm_provider.get_call_count() > 0, "Should have attempted LLM calls");
-+
-+        monitor_handle.abort();
-+    }
-+
-+    #[tokio::test]
-+    async fn test_concurrent_notification_scenarios() {
-+        let (_temp_dir, mut notifier, _llm_provider) = setup_comprehensive_test_environment().await;
-+
-+        let provider = RealisticMockProvider::new("ConcurrencyTest".to_string())
-+            .with_response_delay(Duration::from_millis(300));
-+        let provider_notifications = provider.sent_notifications.clone();
-+        notifier.add_provider(Box::new(provider));
-+
-+        let notifier_arc = Arc::new(notifier);
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+
-+        // Simulate rapid state changes
-+        let state_changes = vec![
-+            vec![Message::user().with_text("Task 1"), Message::assistant().with_text("Working on task 1...")],
-+            vec![Message::user().with_text("Task 2"), Message::assistant().with_text("Switching to task 2...")],
-+            vec![Message::user().with_text("Task 3"), Message::assistant().with_text("Now handling task 3...")],
-+        ];
-+
-+        // Rapid fire state changes
-+        for (i, messages) in state_changes.iter().enumerate() {
-+            notifier_arc.update_messages(messages).await;
-+            notifier_arc.mark_waiting_for_input().await;
-+            
-+            if i < state_changes.len() - 1 {
-+                sleep(Duration::from_millis(200)).await;
-+                notifier_arc.mark_user_input_received().await;
-+            }
-+        }
-+
-+        // Wait for processing
-+        sleep(Duration::from_secs(3)).await;
-+
-+        // Should handle concurrent operations gracefully
-+        let sent_count = provider_notifications.read().await.len();
-+        assert!(sent_count > 0, "Should have sent some notifications despite rapid changes");
-+
-+        monitor_handle.abort();
-+    }
-+
-+    #[tokio::test]
-+    async fn test_memory_and_resource_management() {
-+        let (_temp_dir, mut notifier, _llm_provider) = setup_comprehensive_test_environment().await;
-+
-+        let provider = RealisticMockProvider::new("ResourceTest".to_string());
-+        notifier.add_provider(Box::new(provider));
-+
-+        let notifier_arc = Arc::new(notifier);
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+
-+        // Create many large messages to test memory handling
-+        let large_text = "x".repeat(10000);
-+        let messages: Vec<Message> = (0..100)
-+            .map(|i| {
-+                if i % 2 == 0 {
-+                    Message::user().with_text(&format!("User message {}: {}", i, large_text))
-+                } else {
-+                    Message::assistant().with_text(&format!("Assistant message {}: {}", i, large_text))
-+                }
-+            })
-+            .collect();
-+
-+        // Process large message history
-+        notifier_arc.update_messages(&messages).await;
-+        notifier_arc.mark_waiting_for_input().await;
-+
-+        // Wait for processing
-+        sleep(Duration::from_secs(2)).await;
-+
-+        // Should handle large messages without issues
-+        // (This test primarily ensures no memory leaks or excessive usage)
-+
-+        monitor_handle.abort();
-+    }
-+
-+    #[tokio::test]
-+    async fn test_configuration_edge_cases() {
-+        let temp_dir = TempDir::new().unwrap();
-+        
-+        // Test with minimal timeouts
-+        let config = NotificationConfig {
-+            ping_timeout: 0,     // Edge case: no ping timeout
-+            fallback_timeout: 1, // Minimal fallback
-+            enabled: true,
-+            prompts_dir: temp_dir.path().to_path_buf(),
-+        };
-+
-+        let notifier = Notifier::new(config);
-+        
-+        // Should handle edge case configurations gracefully
-+        // (This primarily tests that construction doesn't panic)
-+        assert_eq!(notifier.providers.len(), 0);
-+    }
-+
-+    #[tokio::test]
-+    async fn test_provider_isolation_and_independence() {
-+        let (_temp_dir, mut notifier, _llm_provider) = setup_comprehensive_test_environment().await;
-+
-+        // Add multiple providers with different characteristics
-+        let fast_provider = RealisticMockProvider::new("FastProvider".to_string())
-+            .with_response_delay(Duration::from_millis(10));
-+        let fast_notifications = fast_provider.sent_notifications.clone();
-+
-+        let slow_provider = RealisticMockProvider::new("SlowProvider".to_string())
-+            .with_response_delay(Duration::from_millis(1000));
-+        let slow_notifications = slow_provider.sent_notifications.clone();
-+
-+        let failing_provider = RealisticMockProvider::new("FailingProvider".to_string())
-+            .with_failure_rate(100); // Always fails
-+        let failing_notifications = failing_provider.sent_notifications.clone();
-+
-+        notifier.add_provider(Box::new(fast_provider));
-+        notifier.add_provider(Box::new(slow_provider));
-+        notifier.add_provider(Box::new(failing_provider));
-+
-+        let messages = vec![
-+            Message::user().with_text("Optimize database queries"),
-+            Message::assistant().with_text("Which queries are performing poorly?"),
-+        ];
-+
-+        let notifier_arc = Arc::new(notifier);
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+
-+        notifier_arc.update_messages(&messages).await;
-+        notifier_arc.mark_waiting_for_input().await;
-+
-+        // Fast provider should complete quickly
-+        sleep(Duration::from_millis(100)).await;
-+        let fast_count = fast_notifications.read().await.len();
-+        assert_eq!(fast_count, 1, "Fast provider should have completed");
-+
-+        // Slow provider should still be processing
-+        let slow_count = slow_notifications.read().await.len();
-+        // (May or may not have completed yet, depending on timing)
-+
-+        // Failing provider should have attempted but failed
-+        let failing_count = failing_notifications.read().await.len();
-+        assert_eq!(failing_count, 0, "Failing provider should not have succeeded");
-+
-+        // Wait for slow provider to complete
-+        sleep(Duration::from_secs(2)).await;
-+        let final_slow_count = slow_notifications.read().await.len();
-+        assert_eq!(final_slow_count, 1, "Slow provider should eventually complete");
-+
-+        monitor_handle.abort();
-+    }
-+
-+    #[tokio::test]
-+    async fn test_realistic_user_interaction_patterns() {
-+        let (_temp_dir, mut notifier, _llm_provider) = setup_comprehensive_test_environment().await;
-+
-+        let provider = RealisticMockProvider::new("UserPatternTest".to_string())
-+            .with_auto_reply(Duration::from_millis(800), "Use JWT authentication".to_string());
-+        let provider_notifications = provider.sent_notifications.clone();
-+        
-+        notifier.add_provider(Box::new(provider));
-+
-+        let injected_messages = Arc::new(Mutex::new(Vec::new()));
-+        let injection_tracker = injected_messages.clone();
-+        
-+        let callback = Arc::new(move |message: Message| {
-+            let tracker = injection_tracker.clone();
-+            Box::pin(async move {
-+                let mut messages = tracker.lock().await;
-+                messages.push(message);
-+                Ok(())
-+            })
-+        });
-+        
-+        notifier.set_message_injection_callback(callback);
-+
-+        let notifier_arc = Arc::new(notifier);
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+
-+        // Simulate realistic interaction pattern:
-+        // 1. User gives task
-+        // 2. Assistant asks for clarification
-+        // 3. User steps away (notification sent)
-+        // 4. User replies via notification
-+        // 5. Conversation continues
-+
-+        let phase1_messages = vec![
-+            Message::user().with_text("I need to add authentication to my web app"),
-+            Message::assistant().with_text("What type of authentication would you like to implement? OAuth, JWT, or something else?"),
-+        ];
-+
-+        notifier_arc.update_messages(&phase1_messages).await;
-+        notifier_arc.mark_waiting_for_input().await;
-+
-+        // Wait for notification and auto-reply
-+        sleep(Duration::from_secs(2)).await;
-+
-+        // Verify notification was sent
-+        let notifications = provider_notifications.read().await;
-+        assert!(!notifications.is_empty(), "Should have sent notification asking about auth type");
-+
-+        // Verify reply was injected
-+        let injected = injected_messages.lock().await;
-+        assert!(!injected.is_empty(), "Should have injected user reply");
-+        
-+        // Verify reply content
-+        let reply_content = if let MessageContent::Text(text) = &injected[0].content {
-+            text.clone()
-+        } else {
-+            panic!("Expected text message");
-+        };
-+        assert!(reply_content.contains("JWT"), "Reply should specify JWT");
-+
-+        // Simulate assistant processing the reply
-+        let mut phase2_messages = phase1_messages.clone();
-+        phase2_messages.push(Message::user().with_text(&reply_content));
-+        phase2_messages.push(Message::assistant().with_text("Great! I'll help you implement JWT authentication. Let me start by creating the auth middleware..."));
-+
-+        notifier_arc.update_messages(&phase2_messages).await;
-+        notifier_arc.mark_user_input_received().await; // Mark that we got input
-+
-+        // Simulate assistant completing work and waiting again
-+        sleep(Duration::from_millis(100)).await;
-+        notifier_arc.mark_waiting_for_input().await;
-+
-+        // Should adapt behavior based on previous interaction
-+        sleep(Duration::from_secs(2)).await;
-+        let final_notification_count = provider_notifications.read().await.len();
-+        
-+        // Should have sent at least one more notification
-+        assert!(final_notification_count > 1, "Should continue notification pattern");
-+
-+        monitor_handle.abort();
-+    }
-+} 
-\ No newline at end of file
-diff --git a/crates/goose-cli/tests/notification_integration_test.rs b/crates/goose-cli/tests/notification_integration_test.rs
-new file mode 100644
-index 0000000000..02caa83898
---- /dev/null
-+++ b/crates/goose-cli/tests/notification_integration_test.rs
-@@ -0,0 +1,230 @@
-+#[cfg(feature = "notifications")]
-+mod notification_integration_tests {
-+    use goose_cli::notifier::{
-+        Notifier, NotificationConfig, NotificationProvider, NotificationReply, RichNotification,
-+        intelligence::WaitType,
-+    };
-+    use goose::message::{Message, MessageContent, TextContent};
-+    use std::sync::Arc;
-+    use std::path::PathBuf;
-+    use tokio::sync::{Mutex, mpsc};
-+    use tokio::time::{Duration, Instant};
-+    use anyhow::Result;
-+    use async_trait::async_trait;
-+
-+    /// Mock provider that simulates real provider behavior
-+    struct IntegrationTestProvider {
-+        name: String,
-+        sent_notifications: Arc<Mutex<Vec<RichNotification>>>,
-+        should_reply_after: Option<Duration>,
-+        reply_message: String,
-+    }
-+
-+    impl IntegrationTestProvider {
-+        fn new(name: String, should_reply_after: Option<Duration>, reply_message: String) -> Self {
-+            Self {
-+                name,
-+                sent_notifications: Arc::new(Mutex::new(Vec::new())),
-+                should_reply_after,
-+                reply_message,
-+            }
-+        }
-+        
-+        async fn get_sent_notifications(&self) -> Vec<RichNotification> {
-+            self.sent_notifications.lock().await.clone()
-+        }
-+    }
-+
-+    #[async_trait]
-+    impl NotificationProvider for IntegrationTestProvider {
-+        async fn send_rich(&self, notification: &RichNotification) -> Result<()> {
-+            let mut sent = self.sent_notifications.lock().await;
-+            sent.push(notification.clone());
-+            println!("üì± [{}] Notification sent: {}", self.name, notification.summary);
-+            Ok(())
-+        }
-+        
-+        async fn start_listening(&self, reply_sender: mpsc::Sender<NotificationReply>) -> Result<()> {
-+            if let Some(delay) = self.should_reply_after {
-+                let reply_message = self.reply_message.clone();
-+                let provider_name = self.name.clone();
-+                
-+                tokio::spawn(async move {
-+                    tokio::time::sleep(delay).await;
-+                    
-+                    let reply = NotificationReply {
-+                        provider: provider_name.clone(),
-+                        user_id: "test_user".to_string(),
-+                        message: reply_message,
-+                        timestamp: Instant::now(),
-+                    };
-+                    
-+                    println!("üí¨ [{}] Sending reply: {}", provider_name, reply.message);
-+                    if let Err(e) = reply_sender.send(reply).await {
-+                        eprintln!("Failed to send test reply: {}", e);
-+                    }
-+                });
-+            }
-+            
-+            Ok(())
-+        }
-+        
-+        fn name(&self) -> &str {
-+            &self.name
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_complete_notification_flow() {
-+        // Create a notifier with fast timeouts for testing
-+        let config = NotificationConfig {
-+            ping_timeout: 1,     // 1 second
-+            fallback_timeout: 1, // 1 second
-+            enabled: true,
-+            prompts_dir: PathBuf::from("crates/goose-cli/prompts"),
-+        };
-+        
-+        let mut notifier = Notifier::new(config);
-+        
-+        // Add test provider that will reply after 2 seconds
-+        let provider = IntegrationTestProvider::new(
-+            "TestProvider".to_string(),
-+            Some(Duration::from_secs(2)),
-+            "Edit the main.rs file with error handling".to_string(),
-+        );
-+        let provider_notifications = provider.sent_notifications.clone();
-+        
-+        notifier.add_provider(Box::new(provider));
-+        
-+        // Set up message injection tracking
-+        let injected_messages = Arc::new(Mutex::new(Vec::<Message>::new()));
-+        let injection_tracker = injected_messages.clone();
-+        
-+        let callback = Arc::new(move |message: Message| {
-+            let tracker = injection_tracker.clone();
-+            Box::pin(async move {
-+                let mut messages = tracker.lock().await;
-+                messages.push(message);
-+                println!("‚úÖ Message injected successfully");
-+                Ok(())
-+            })
-+        });
-+        
-+        notifier.set_message_injection_callback(callback);
-+        
-+        // Create test conversation
-+        let messages = vec![
-+            Message::user().with_text("Help me add error handling to the code"),
-+            Message::assistant().with_text("I can help you add error handling. Which file would you like me to work on?"),
-+        ];
-+        
-+        let notifier_arc = Arc::new(notifier);
-+        
-+        // Start monitoring
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+        
-+        // Simulate the flow
-+        notifier_arc.update_messages(&messages).await;
-+        notifier_arc.mark_response_received().await;
-+        notifier_arc.mark_waiting_for_input().await;
-+        
-+        // Wait for notification to be sent and reply to be processed
-+        tokio::time::sleep(Duration::from_secs(4)).await;
-+        
-+        // Verify notification was sent
-+        let sent_notifications = provider_notifications.lock().await;
-+        assert!(!sent_notifications.is_empty(), "No notifications were sent");
-+        assert!(sent_notifications[0].summary.contains("specify") || 
-+                sent_notifications[0].summary.contains("which file") ||
-+                sent_notifications[0].summary.contains("waiting"), 
-+                "Notification summary doesn't look right: {}", sent_notifications[0].summary);
-+        
-+        // Verify message was injected
-+        tokio::time::sleep(Duration::from_millis(100)).await;
-+        let injected = injected_messages.lock().await;
-+        assert!(!injected.is_empty(), "No messages were injected");
-+        
-+        // Check the injected message content
-+        let injected_text = injected[0].content.iter()
-+            .filter_map(|c| match c {
-+                MessageContent::Text(text) => Some(text.text.as_str()),
-+                _ => None,
-+            })
-+            .collect::<Vec<_>>()
-+            .join(" ");
-+        
-+        assert!(injected_text.contains("main.rs"), 
-+                "Injected message doesn't contain expected content: {}", injected_text);
-+        
-+        // Clean up
-+        monitor_handle.abort();
-+        
-+        println!("üéâ Integration test completed successfully!");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_fallback_behavior() {
-+        let config = NotificationConfig {
-+            ping_timeout: 1,
-+            fallback_timeout: 1,
-+            enabled: true,
-+            prompts_dir: PathBuf::from("crates/goose-cli/prompts"),
-+        };
-+        
-+        let mut notifier = Notifier::new(config);
-+        
-+        // Provider that doesn't reply (simulates user being away)
-+        let provider = IntegrationTestProvider::new(
-+            "NoReplyProvider".to_string(),
-+            None, // No automatic reply
-+            "".to_string(),
-+        );
-+        let provider_notifications = provider.sent_notifications.clone();
-+        
-+        notifier.add_provider(Box::new(provider));
-+        
-+        // Track fallback messages
-+        let fallback_messages = Arc::new(Mutex::new(Vec::<Message>::new()));
-+        let fallback_tracker = fallback_messages.clone();
-+        
-+        let callback = Arc::new(move |message: Message| {
-+            let tracker = fallback_tracker.clone();
-+            Box::pin(async move {
-+                let mut messages = tracker.lock().await;
-+                messages.push(message);
-+                println!("üîÑ Fallback message received");
-+                Ok(())
-+            })
-+        });
-+        
-+        notifier.set_message_injection_callback(callback);
-+        
-+        let messages = vec![
-+            Message::user().with_text("Create a new API endpoint"),
-+            Message::assistant().with_text("I'll create the API endpoint. Should I use REST or GraphQL?"),
-+        ];
-+        
-+        let notifier_arc = Arc::new(notifier);
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+        
-+        // Simulate the flow
-+        notifier_arc.update_messages(&messages).await;
-+        notifier_arc.mark_response_received().await;
-+        notifier_arc.mark_waiting_for_input().await;
-+        
-+        // Wait for timeout and fallback
-+        tokio::time::sleep(Duration::from_secs(3)).await;
-+        
-+        // Verify notification was sent
-+        let sent_notifications = provider_notifications.lock().await;
-+        assert!(!sent_notifications.is_empty(), "No notifications were sent");
-+        
-+        // Verify fallback was executed
-+        let fallbacks = fallback_messages.lock().await;
-+        assert!(!fallbacks.is_empty(), "No fallback action was taken");
-+        
-+        monitor_handle.abort();
-+        
-+        println!("üéâ Fallback test completed successfully!");
-+    }
-+} 
-\ No newline at end of file
-diff --git a/crates/goose-cli/tests/notification_resilience_test.rs b/crates/goose-cli/tests/notification_resilience_test.rs
-new file mode 100644
-index 0000000000..3954750f98
---- /dev/null
-+++ b/crates/goose-cli/tests/notification_resilience_test.rs
-@@ -0,0 +1,646 @@
-+#[cfg(feature = "notifications")]
-+mod notification_resilience_tests {
-+    use goose_cli::notifier::{
-+        Notifier, NotificationConfig, NotificationProvider, NotificationReply, RichNotification,
-+    };
-+    use goose::message::{Message, MessageContent};
-+    use goose::providers::base::{Provider, CompletionResponse};
-+    use std::sync::Arc;
-+    use std::path::PathBuf;
-+    use std::sync::atomic::{AtomicUsize, AtomicBool, Ordering};
-+    use std::time::Duration;
-+    use tokio::sync::{Mutex, mpsc, Semaphore};
-+    use tokio::time::{Instant, sleep, timeout};
-+    use anyhow::{Result, anyhow};
-+    use async_trait::async_trait;
-+    use tempfile::TempDir;
-+    use tokio::fs;
-+
-+    /// Provider that simulates various failure modes
-+    struct ChaosProvider {
-+        name: String,
-+        failure_modes: Arc<Mutex<Vec<FailureMode>>>,
-+        call_count: Arc<AtomicUsize>,
-+        sent_notifications: Arc<Mutex<Vec<RichNotification>>>,
-+    }
-+
-+    #[derive(Clone, Debug)]
-+    enum FailureMode {
-+        NetworkTimeout,
-+        ServerError,
-+        RateLimited,
-+        PartialFailure,
-+        MemoryPressure,
-+        Disconnect,
-+        Success,
-+    }
-+
-+    impl ChaosProvider {
-+        fn new(name: String) -> Self {
-+            Self {
-+                name,
-+                failure_modes: Arc::new(Mutex::new(vec![FailureMode::Success])),
-+                call_count: Arc::new(AtomicUsize::new(0)),
-+                sent_notifications: Arc::new(Mutex::new(Vec::new())),
-+            }
-+        }
-+
-+        async fn set_failure_sequence(&self, modes: Vec<FailureMode>) {
-+            *self.failure_modes.lock().await = modes;
-+        }
-+
-+        async fn get_next_failure_mode(&self) -> FailureMode {
-+            let mut modes = self.failure_modes.lock().await;
-+            if modes.is_empty() {
-+                FailureMode::Success
-+            } else {
-+                modes.remove(0)
-+            }
-+        }
-+
-+        async fn get_sent_count(&self) -> usize {
-+            self.sent_notifications.lock().await.len()
-+        }
-+    }
-+
-+    #[async_trait]
-+    impl NotificationProvider for ChaosProvider {
-+        async fn send_rich(&self, notification: &RichNotification) -> Result<()> {
-+            let call_number = self.call_count.fetch_add(1, Ordering::SeqCst);
-+            let failure_mode = self.get_next_failure_mode().await;
-+
-+            match failure_mode {
-+                FailureMode::NetworkTimeout => {
-+                    sleep(Duration::from_secs(60)).await; // Simulate hang
-+                    Err(anyhow!("Network timeout"))
-+                }
-+                FailureMode::ServerError => {
-+                    sleep(Duration::from_millis(100)).await;
-+                    Err(anyhow!("Server returned 500 Internal Server Error"))
-+                }
-+                FailureMode::RateLimited => {
-+                    Err(anyhow!("Rate limited: retry after 60 seconds"))
-+                }
-+                FailureMode::PartialFailure => {
-+                    if call_number % 2 == 0 {
-+                        Err(anyhow!("Intermittent failure"))
-+                    } else {
-+                        self.sent_notifications.lock().await.push(notification.clone());
-+                        Ok(())
-+                    }
-+                }
-+                FailureMode::MemoryPressure => {
-+                    // Simulate low memory by allocating and immediately dropping
-+                    let _large_vec: Vec<u8> = vec![0; 1024 * 1024]; // 1MB
-+                    Err(anyhow!("Out of memory"))
-+                }
-+                FailureMode::Disconnect => {
-+                    Err(anyhow!("Connection lost"))
-+                }
-+                FailureMode::Success => {
-+                    sleep(Duration::from_millis(10)).await;
-+                    self.sent_notifications.lock().await.push(notification.clone());
-+                    Ok(())
-+                }
-+            }
-+        }
-+
-+        async fn start_listening(&self, _reply_sender: mpsc::Sender<NotificationReply>) -> Result<()> {
-+            // Simulate connection that might fail
-+            let failure_mode = self.get_next_failure_mode().await;
-+            match failure_mode {
-+                FailureMode::Disconnect => Err(anyhow!("Failed to establish listening connection")),
-+                _ => Ok(())
-+            }
-+        }
-+
-+        fn name(&self) -> &str {
-+            &self.name
-+        }
-+    }
-+
-+    /// LLM provider that simulates various AI service failure modes
-+    struct ChaosLLMProvider {
-+        failure_sequence: Arc<Mutex<Vec<LLMFailureMode>>>,
-+        call_count: Arc<AtomicUsize>,
-+        response_times: Arc<Mutex<Vec<Duration>>>,
-+    }
-+
-+    #[derive(Clone, Debug)]
-+    enum LLMFailureMode {
-+        Timeout,
-+        InvalidResponse,
-+        TokenLimitExceeded,
-+        ServiceUnavailable,
-+        ModelOverloaded,
-+        Success(String),
-+    }
-+
-+    impl ChaosLLMProvider {
-+        fn new() -> Self {
-+            Self {
-+                failure_sequence: Arc::new(Mutex::new(vec![
-+                    LLMFailureMode::Success("Test LLM response".to_string())
-+                ])),
-+                call_count: Arc::new(AtomicUsize::new(0)),
-+                response_times: Arc::new(Mutex::new(Vec::new())),
-+            }
-+        }
-+
-+        async fn set_failure_sequence(&self, sequence: Vec<LLMFailureMode>) {
-+            *self.failure_sequence.lock().await = sequence;
-+        }
-+
-+        async fn get_average_response_time(&self) -> Option<Duration> {
-+            let times = self.response_times.lock().await;
-+            if times.is_empty() {
-+                None
-+            } else {
-+                let total: Duration = times.iter().sum();
-+                Some(total / times.len() as u32)
-+            }
-+        }
-+
-+        fn get_call_count(&self) -> usize {
-+            self.call_count.load(Ordering::SeqCst)
-+        }
-+    }
-+
-+    #[async_trait]
-+    impl Provider for ChaosLLMProvider {
-+        async fn complete(&self, _prompt: &str) -> Result<CompletionResponse> {
-+            let start_time = Instant::now();
-+            self.call_count.fetch_add(1, Ordering::SeqCst);
-+
-+            let mut sequence = self.failure_sequence.lock().await;
-+            let failure_mode = if sequence.is_empty() {
-+                LLMFailureMode::Success("Fallback response".to_string())
-+            } else {
-+                sequence.remove(0)
-+            };
-+            drop(sequence);
-+
-+            let result = match failure_mode {
-+                LLMFailureMode::Timeout => {
-+                    sleep(Duration::from_secs(30)).await;
-+                    Err(anyhow!("LLM request timed out"))
-+                }
-+                LLMFailureMode::InvalidResponse => {
-+                    sleep(Duration::from_millis(200)).await;
-+                    Err(anyhow!("Invalid response format from LLM"))
-+                }
-+                LLMFailureMode::TokenLimitExceeded => {
-+                    Err(anyhow!("Token limit exceeded"))
-+                }
-+                LLMFailureMode::ServiceUnavailable => {
-+                    Err(anyhow!("LLM service temporarily unavailable"))
-+                }
-+                LLMFailureMode::ModelOverloaded => {
-+                    sleep(Duration::from_secs(5)).await;
-+                    Err(anyhow!("Model is overloaded, please retry"))
-+                }
-+                LLMFailureMode::Success(response) => {
-+                    sleep(Duration::from_millis(100)).await;
-+                    Ok(CompletionResponse {
-+                        content: response,
-+                        usage: None,
-+                    })
-+                }
-+            };
-+
-+            // Track response time
-+            let elapsed = start_time.elapsed();
-+            self.response_times.lock().await.push(elapsed);
-+
-+            result
-+        }
-+
-+        fn get_model(&self) -> String {
-+            "chaos-model-v1".to_string()
-+        }
-+
-+        fn as_any(&self) -> &dyn std::any::Any {
-+            self
-+        }
-+    }
-+
-+    async fn setup_chaos_test_environment() -> (TempDir, Notifier, Arc<ChaosLLMProvider>) {
-+        let temp_dir = TempDir::new().unwrap();
-+        let prompts_dir = temp_dir.path().join("prompts");
-+        fs::create_dir(&prompts_dir).await.unwrap();
-+
-+        // Create prompt templates that will work even with chaos
-+        let summary_template = "Summary: {{ messages }} - {{ wait_type }}";
-+        let response_template = "Response: {{ summary }} - {{ wait_type }}";
-+
-+        fs::write(prompts_dir.join("notification_summary.md"), summary_template).await.unwrap();
-+        fs::write(prompts_dir.join("notification_response.md"), response_template).await.unwrap();
-+
-+        let config = NotificationConfig {
-+            ping_timeout: 1,
-+            fallback_timeout: 2,
-+            enabled: true,
-+            prompts_dir,
-+        };
-+
-+        let mut notifier = Notifier::new(config);
-+        let llm_provider = Arc::new(ChaosLLMProvider::new());
-+        notifier.set_llm_provider(llm_provider.clone());
-+
-+        (temp_dir, notifier, llm_provider)
-+    }
-+
-+    #[tokio::test]
-+    async fn test_cascading_provider_failures() {
-+        let (_temp_dir, mut notifier, _llm_provider) = setup_chaos_test_environment().await;
-+
-+        // Add multiple providers with different failure patterns
-+        let provider1 = ChaosProvider::new("Provider1".to_string());
-+        provider1.set_failure_sequence(vec![
-+            FailureMode::NetworkTimeout,
-+            FailureMode::ServerError,
-+            FailureMode::Success,
-+        ]).await;
-+
-+        let provider2 = ChaosProvider::new("Provider2".to_string());
-+        provider2.set_failure_sequence(vec![
-+            FailureMode::RateLimited,
-+            FailureMode::Success,
-+        ]).await;
-+
-+        let provider3 = ChaosProvider::new("Provider3".to_string());
-+        provider3.set_failure_sequence(vec![
-+            FailureMode::Success,
-+        ]).await;
-+
-+        let success_provider = provider3.clone();
-+        
-+        notifier.add_provider(Box::new(provider1));
-+        notifier.add_provider(Box::new(provider2));
-+        notifier.add_provider(Box::new(provider3));
-+
-+        let messages = vec![
-+            Message::assistant().with_text("System is experiencing multiple failures"),
-+        ];
-+
-+        let notifier_arc = Arc::new(notifier);
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+
-+        notifier_arc.update_messages(&messages).await;
-+        notifier_arc.mark_waiting_for_input().await;
-+
-+        // Wait for multiple retry attempts
-+        sleep(Duration::from_secs(4)).await;
-+
-+        // At least one provider should have succeeded eventually
-+        let success_count = success_provider.get_sent_count().await;
-+        assert!(success_count > 0, "At least one provider should have succeeded despite failures");
-+
-+        monitor_handle.abort();
-+    }
-+
-+    #[tokio::test]
-+    async fn test_llm_failure_resilience() {
-+        let (_temp_dir, mut notifier, llm_provider) = setup_chaos_test_environment().await;
-+
-+        // Set up LLM to fail in multiple ways
-+        llm_provider.set_failure_sequence(vec![
-+            LLMFailureMode::Timeout,
-+            LLMFailureMode::ServiceUnavailable,
-+            LLMFailureMode::TokenLimitExceeded,
-+            LLMFailureMode::Success("Finally working!".to_string()),
-+        ]).await;
-+
-+        let provider = ChaosProvider::new("ResilientProvider".to_string());
-+        let provider_ref = provider.clone();
-+        notifier.add_provider(Box::new(provider));
-+
-+        let messages = vec![
-+            Message::assistant().with_text("Testing LLM failure resilience"),
-+        ];
-+
-+        let notifier_arc = Arc::new(notifier);
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+
-+        notifier_arc.update_messages(&messages).await;
-+        notifier_arc.mark_waiting_for_input().await;
-+
-+        // Wait for multiple LLM call attempts
-+        sleep(Duration::from_secs(3)).await;
-+
-+        // Should eventually succeed or fall back gracefully
-+        let sent_count = provider_ref.get_sent_count().await;
-+        let llm_calls = llm_provider.get_call_count();
-+
-+        // System should have attempted multiple LLM calls
-+        assert!(llm_calls > 1, "Should have retried LLM calls: {}", llm_calls);
-+        
-+        // Should have sent notification even if LLM failed (using fallbacks)
-+        assert!(sent_count > 0, "Should have sent notification despite LLM failures");
-+
-+        monitor_handle.abort();
-+    }
-+
-+    #[tokio::test]
-+    async fn test_memory_pressure_handling() {
-+        let (_temp_dir, mut notifier, _llm_provider) = setup_chaos_test_environment().await;
-+
-+        let provider = ChaosProvider::new("MemoryProvider".to_string());
-+        provider.set_failure_sequence(vec![
-+            FailureMode::MemoryPressure,
-+            FailureMode::MemoryPressure,
-+            FailureMode::Success,
-+        ]).await;
-+
-+        let provider_ref = provider.clone();
-+        notifier.add_provider(Box::new(provider));
-+
-+        // Create large message history to add memory pressure
-+        let large_text = "x".repeat(50000);
-+        let messages: Vec<Message> = (0..200)
-+            .map(|i| Message::user().with_text(&format!("{}: {}", i, large_text)))
-+            .collect();
-+
-+        let notifier_arc = Arc::new(notifier);
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+
-+        notifier_arc.update_messages(&messages).await;
-+        notifier_arc.mark_waiting_for_input().await;
-+
-+        // Wait for memory-constrained operations
-+        sleep(Duration::from_secs(3)).await;
-+
-+        // Should handle memory pressure gracefully
-+        let sent_count = provider_ref.get_sent_count().await;
-+        assert!(sent_count > 0, "Should eventually succeed despite memory pressure");
-+
-+        monitor_handle.abort();
-+    }
-+
-+    #[tokio::test]
-+    async fn test_network_partition_recovery() {
-+        let (_temp_dir, mut notifier, _llm_provider) = setup_chaos_test_environment().await;
-+
-+        let provider = ChaosProvider::new("NetworkProvider".to_string());
-+        provider.set_failure_sequence(vec![
-+            FailureMode::Disconnect,
-+            FailureMode::NetworkTimeout,
-+            FailureMode::Disconnect,
-+            FailureMode::Success,
-+            FailureMode::Success,
-+        ]).await;
-+
-+        let provider_ref = provider.clone();
-+        notifier.add_provider(Box::new(provider));
-+
-+        let messages = vec![
-+            Message::assistant().with_text("Testing network partition recovery"),
-+        ];
-+
-+        let notifier_arc = Arc::new(notifier);
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+
-+        notifier_arc.update_messages(&messages).await;
-+        notifier_arc.mark_waiting_for_input().await;
-+
-+        // Simulate network recovery after partition
-+        sleep(Duration::from_secs(4)).await;
-+
-+        // Should recover from network issues
-+        let sent_count = provider_ref.get_sent_count().await;
-+        assert!(sent_count > 0, "Should recover from network partition");
-+
-+        monitor_handle.abort();
-+    }
-+
-+    #[tokio::test] 
-+    async fn test_concurrent_failure_isolation() {
-+        let (_temp_dir, mut notifier, _llm_provider) = setup_chaos_test_environment().await;
-+
-+        // Add providers with different failure characteristics
-+        let fast_failing_provider = ChaosProvider::new("FastFail".to_string());
-+        fast_failing_provider.set_failure_sequence(vec![
-+            FailureMode::ServerError; 10 // Fail 10 times quickly
-+        ]).await;
-+
-+        let slow_failing_provider = ChaosProvider::new("SlowFail".to_string());
-+        slow_failing_provider.set_failure_sequence(vec![
-+            FailureMode::NetworkTimeout,
-+        ]).await;
-+
-+        let reliable_provider = ChaosProvider::new("Reliable".to_string());
-+        reliable_provider.set_failure_sequence(vec![
-+            FailureMode::Success; 10 // Always succeed
-+        ]).await;
-+
-+        let reliable_ref = reliable_provider.clone();
-+
-+        notifier.add_provider(Box::new(fast_failing_provider));
-+        notifier.add_provider(Box::new(slow_failing_provider)); 
-+        notifier.add_provider(Box::new(reliable_provider));
-+
-+        let notifier_arc = Arc::new(notifier);
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+
-+        // Send multiple concurrent requests
-+        let futures = (0..5).map(|i| {
-+            let notifier = notifier_arc.clone();
-+            async move {
-+                let messages = vec![
-+                    Message::assistant().with_text(&format!("Concurrent test {}", i)),
-+                ];
-+                notifier.update_messages(&messages).await;
-+                notifier.mark_waiting_for_input().await;
-+                sleep(Duration::from_millis(200)).await;
-+                notifier.mark_user_input_received().await;
-+            }
-+        });
-+
-+        futures::future::join_all(futures).await;
-+
-+        // Wait for all operations to complete
-+        sleep(Duration::from_secs(3)).await;
-+
-+        // Reliable provider should have succeeded despite other failures
-+        let reliable_count = reliable_ref.get_sent_count().await;
-+        assert!(reliable_count > 0, "Reliable provider should have succeeded");
-+
-+        monitor_handle.abort();
-+    }
-+
-+    #[tokio::test]
-+    async fn test_resource_exhaustion_recovery() {
-+        let (_temp_dir, mut notifier, llm_provider) = setup_chaos_test_environment().await;
-+
-+        // Simulate resource exhaustion in LLM
-+        llm_provider.set_failure_sequence(vec![
-+            LLMFailureMode::ModelOverloaded,
-+            LLMFailureMode::ServiceUnavailable,
-+            LLMFailureMode::Success("Recovered!".to_string()),
-+        ]).await;
-+
-+        let provider = ChaosProvider::new("ResourceProvider".to_string());
-+        provider.set_failure_sequence(vec![
-+            FailureMode::RateLimited,
-+            FailureMode::Success,
-+        ]).await;
-+
-+        let provider_ref = provider.clone();
-+        notifier.add_provider(Box::new(provider));
-+
-+        let messages = vec![
-+            Message::assistant().with_text("Testing resource exhaustion recovery"),
-+        ];
-+
-+        let notifier_arc = Arc::new(notifier);
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+
-+        notifier_arc.update_messages(&messages).await;
-+        notifier_arc.mark_waiting_for_input().await;
-+
-+        // Wait for recovery from resource exhaustion
-+        sleep(Duration::from_secs(6)).await;
-+
-+        // Should recover from resource exhaustion
-+        let sent_count = provider_ref.get_sent_count().await;
-+        assert!(sent_count > 0, "Should recover from resource exhaustion");
-+
-+        monitor_handle.abort();
-+    }
-+
-+    #[tokio::test]
-+    async fn test_graceful_degradation_under_load() {
-+        let (_temp_dir, mut notifier, llm_provider) = setup_chaos_test_environment().await;
-+
-+        // Set up partial LLM failures
-+        llm_provider.set_failure_sequence(vec![
-+            LLMFailureMode::Timeout,
-+            LLMFailureMode::Success("Partial success".to_string()),
-+            LLMFailureMode::TokenLimitExceeded,
-+        ]).await;
-+
-+        // Add multiple providers with varying reliability
-+        let providers: Vec<_> = (0..5).map(|i| {
-+            let provider = ChaosProvider::new(format!("Provider{}", i));
-+            let failure_rate = i; // Increasing failure rate
-+            
-+            let sequence = (0..10).map(|j| {
-+                if j % (failure_rate + 1) == 0 {
-+                    FailureMode::Success
-+                } else {
-+                    FailureMode::ServerError
-+                }
-+            }).collect();
-+            
-+            provider.set_failure_sequence(sequence);
-+            provider
-+        }).collect();
-+
-+        let provider_refs: Vec<_> = providers.iter().cloned().collect();
-+        
-+        for provider in providers {
-+            notifier.add_provider(Box::new(provider));
-+        }
-+
-+        let notifier_arc = Arc::new(notifier);
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+
-+        // Generate high load
-+        let messages = vec![
-+            Message::assistant().with_text("High load degradation test"),
-+        ];
-+
-+        notifier_arc.update_messages(&messages).await;
-+        
-+        // Rapid fire requests
-+        for _ in 0..10 {
-+            notifier_arc.mark_waiting_for_input().await;
-+            sleep(Duration::from_millis(50)).await;
-+            notifier_arc.mark_user_input_received().await;
-+            sleep(Duration::from_millis(50)).await;
-+        }
-+
-+        // Wait for load to process
-+        sleep(Duration::from_secs(5)).await;
-+
-+        // At least some providers should have succeeded
-+        let total_sent: usize = futures::future::join_all(
-+            provider_refs.iter().map(|p| p.get_sent_count())
-+        ).await.iter().sum();
-+
-+        assert!(total_sent > 0, "Should handle load gracefully with some successes: {}", total_sent);
-+
-+        monitor_handle.abort();
-+    }
-+
-+    #[tokio::test]
-+    async fn test_timeout_and_cancellation_handling() {
-+        let (_temp_dir, mut notifier, _llm_provider) = setup_chaos_test_environment().await;
-+
-+        let provider = ChaosProvider::new("TimeoutProvider".to_string());
-+        provider.set_failure_sequence(vec![
-+            FailureMode::NetworkTimeout,
-+        ]).await;
-+
-+        notifier.add_provider(Box::new(provider));
-+
-+        let messages = vec![
-+            Message::assistant().with_text("Testing timeout handling"),
-+        ];
-+
-+        let notifier_arc = Arc::new(notifier);
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+
-+        notifier_arc.update_messages(&messages).await;
-+        notifier_arc.mark_waiting_for_input().await;
-+
-+        // Let it run briefly then cancel
-+        sleep(Duration::from_millis(500)).await;
-+        monitor_handle.abort();
-+
-+        // Should handle cancellation gracefully without panics
-+        // (This is primarily a "no panic" test)
-+    }
-+
-+    #[tokio::test]
-+    async fn test_error_correlation_and_circuit_breaking() {
-+        let (_temp_dir, mut notifier, _llm_provider) = setup_chaos_test_environment().await;
-+
-+        // Create provider that fails consistently then recovers
-+        let provider = ChaosProvider::new("CircuitProvider".to_string());
-+        
-+        // Pattern: many failures, then success to test circuit-breaking behavior
-+        let mut sequence = vec![FailureMode::ServerError; 20];
-+        sequence.extend(vec![FailureMode::Success; 5]);
-+        
-+        provider.set_failure_sequence(sequence).await;
-+        let provider_ref = provider.clone();
-+        notifier.add_provider(Box::new(provider));
-+
-+        let messages = vec![
-+            Message::assistant().with_text("Testing circuit breaking patterns"),
-+        ];
-+
-+        let notifier_arc = Arc::new(notifier);
-+        let monitor_handle = notifier_arc.clone().start_monitoring();
-+
-+        // Generate consistent load to trigger circuit breaking
-+        for i in 0..25 {
-+            notifier_arc.update_messages(&messages).await;
-+            notifier_arc.mark_waiting_for_input().await;
-+            sleep(Duration::from_millis(100)).await;
-+            notifier_arc.mark_user_input_received().await;
-+        }
-+
-+        sleep(Duration::from_secs(2)).await;
-+
-+        // Should eventually succeed when failures stop
-+        let sent_count = provider_ref.get_sent_count().await;
-+        
-+        // The system should be resilient to consistent failures
-+        // and recover when the service becomes available
-+        assert!(sent_count >= 0, "Should handle consistent failures gracefully");
-+
-+        monitor_handle.abort();
-+    }
-+} 
-\ No newline at end of file
-diff --git a/crates/goose-cli/tests/notifier_test.rs b/crates/goose-cli/tests/notifier_test.rs
-new file mode 100644
-index 0000000000..392011151a
---- /dev/null
-+++ b/crates/goose-cli/tests/notifier_test.rs
-@@ -0,0 +1,208 @@
-+#[cfg(feature = "notifications")]
-+mod notifier_tests {
-+    use goose_cli::notifier::{Notifier, NotificationConfig, NotificationProvider, NotificationReply};
-+    use std::sync::Arc;
-+    use tokio::sync::{Mutex, mpsc};
-+    use tokio::time::{Duration, Instant};
-+    use anyhow::Result;
-+    use async_trait::async_trait;
-+
-+    /// Mock provider for testing
-+    struct MockProvider {
-+        name: String,
-+        calls: Arc<Mutex<Vec<String>>>,
-+        should_fail: bool,
-+    }
-+
-+    #[async_trait]
-+    impl NotificationProvider for MockProvider {
-+        async fn send(&self, message: &str) -> Result<()> {
-+            if self.should_fail {
-+                return Err(anyhow::anyhow!("Mock failure"));
-+            }
-+            
-+            let mut calls = self.calls.lock().await;
-+            calls.push(message.to_string());
-+            Ok(())
-+        }
-+        
-+        async fn start_listening(&self, reply_sender: mpsc::Sender<NotificationReply>) -> Result<()> {
-+            // Simulate sending a reply after a delay
-+            let reply_sender = reply_sender.clone();
-+            let name = self.name.clone();
-+            
-+            tokio::spawn(async move {
-+                tokio::time::sleep(Duration::from_millis(500)).await;
-+                let _ = reply_sender.send(NotificationReply {
-+                    provider: name,
-+                    user_id: "test_user".to_string(),
-+                    message: "Test reply".to_string(),
-+                    timestamp: Instant::now(),
-+                }).await;
-+            });
-+            
-+            Ok(())
-+        }
-+        
-+        fn name(&self) -> &str {
-+            &self.name
-+        }
-+    }
-+
-+    #[tokio::test]
-+    async fn test_notifier_basic_send() {
-+        let config = NotificationConfig {
-+            ping_timeout: 1,
-+            fallback_timeout: 1,
-+            enabled: true,
-+        };
-+        
-+        let mut notifier = Notifier::new(config);
-+        let calls = Arc::new(Mutex::new(Vec::new()));
-+        
-+        notifier.add_provider(Box::new(MockProvider {
-+            name: "Mock".to_string(),
-+            calls: calls.clone(),
-+            should_fail: false,
-+        }));
-+        
-+        // Test sending notification
-+        notifier.send_notification("Test message").await.unwrap();
-+        
-+        let calls_vec = calls.lock().await;
-+        assert_eq!(calls_vec.len(), 1);
-+        assert_eq!(calls_vec[0], "Test message");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_notifier_disabled() {
-+        let config = NotificationConfig {
-+            ping_timeout: 1,
-+            fallback_timeout: 1,
-+            enabled: false, // Disabled
-+        };
-+        
-+        let notifier = Arc::new(Notifier::new(config));
-+        
-+        // Mark waiting for input
-+        notifier.mark_waiting_for_input().await;
-+        
-+        // Should not take fallback action when disabled
-+        assert!(!notifier.should_take_fallback_action().await);
-+    }
-+
-+    #[tokio::test]
-+    async fn test_notifier_fallback_timing() {
-+        let config = NotificationConfig {
-+            ping_timeout: 0, // Immediate
-+            fallback_timeout: 0, // Immediate
-+            enabled: true,
-+        };
-+        
-+        let notifier = Arc::new(Notifier::new(config));
-+        
-+        // Mark response received and waiting
-+        notifier.mark_response_received().await;
-+        notifier.mark_waiting_for_input().await;
-+        
-+        // Should immediately trigger fallback
-+        tokio::time::sleep(Duration::from_millis(10)).await;
-+        assert!(notifier.should_take_fallback_action().await);
-+        
-+        // Mark user input received
-+        notifier.mark_user_input_received().await;
-+        
-+        // Should no longer trigger fallback
-+        assert!(!notifier.should_take_fallback_action().await);
-+    }
-+
-+    #[tokio::test]
-+    async fn test_notifier_reply_handling() {
-+        let config = NotificationConfig {
-+            ping_timeout: 300,
-+            fallback_timeout: 300,
-+            enabled: true,
-+        };
-+        
-+        let mut notifier = Notifier::new(config);
-+        let calls = Arc::new(Mutex::new(Vec::new()));
-+        
-+        let mut provider = MockProvider {
-+            name: "TestProvider".to_string(),
-+            calls: calls.clone(),
-+            should_fail: false,
-+        };
-+        
-+        // Start listening for replies
-+        let (tx, mut rx) = mpsc::channel(10);
-+        provider.start_listening(tx).await.unwrap();
-+        
-+        // Wait for the reply
-+        let reply = tokio::time::timeout(Duration::from_secs(1), rx.recv())
-+            .await
-+            .unwrap()
-+            .unwrap();
-+        
-+        assert_eq!(reply.provider, "TestProvider");
-+        assert_eq!(reply.user_id, "test_user");
-+        assert_eq!(reply.message, "Test reply");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_notifier_multiple_providers() {
-+        let config = NotificationConfig {
-+            ping_timeout: 1,
-+            fallback_timeout: 1,
-+            enabled: true,
-+        };
-+        
-+        let mut notifier = Notifier::new(config);
-+        let calls1 = Arc::new(Mutex::new(Vec::new()));
-+        let calls2 = Arc::new(Mutex::new(Vec::new()));
-+        
-+        notifier.add_provider(Box::new(MockProvider {
-+            name: "Provider1".to_string(),
-+            calls: calls1.clone(),
-+            should_fail: false,
-+        }));
-+        
-+        notifier.add_provider(Box::new(MockProvider {
-+            name: "Provider2".to_string(),
-+            calls: calls2.clone(),
-+            should_fail: false,
-+        }));
-+        
-+        // Send notification to all providers
-+        notifier.send_notification("Broadcast message").await.unwrap();
-+        
-+        let calls1_vec = calls1.lock().await;
-+        let calls2_vec = calls2.lock().await;
-+        
-+        assert_eq!(calls1_vec.len(), 1);
-+        assert_eq!(calls1_vec[0], "Broadcast message");
-+        assert_eq!(calls2_vec.len(), 1);
-+        assert_eq!(calls2_vec[0], "Broadcast message");
-+    }
-+
-+    #[tokio::test]
-+    async fn test_notifier_provider_failure() {
-+        let config = NotificationConfig {
-+            ping_timeout: 1,
-+            fallback_timeout: 1,
-+            enabled: true,
-+        };
-+        
-+        let mut notifier = Notifier::new(config);
-+        
-+        notifier.add_provider(Box::new(MockProvider {
-+            name: "FailingProvider".to_string(),
-+            calls: Arc::new(Mutex::new(Vec::new())),
-+            should_fail: true,
-+        }));
-+        
-+        // Should return error when provider fails
-+        let result = notifier.send_notification("Test message").await;
-+        assert!(result.is_err());
-+        assert!(result.unwrap_err().to_string().contains("Mock failure"));
-+    }
-+} 
-\ No newline at end of file
-diff --git a/examples/test_notifications.sh b/examples/test_notifications.sh
-new file mode 100755
-index 0000000000..63f34829f6
---- /dev/null
-+++ b/examples/test_notifications.sh
-@@ -0,0 +1,111 @@
-+#!/bin/bash
-+
-+# Test configuration for intelligent Goose notifications
-+# Source this file to set up your environment for testing
-+
-+echo "ü¶Ü Setting up Goose intelligent notifications test environment..."
-+
-+# Basic settings
-+export GOOSE_NOTIFICATIONS_ENABLED=true
-+export GOOSE_PING_TIMEOUT=60        # 1 minute for testing
-+export GOOSE_FALLBACK_TIMEOUT=60    # Additional 1 minute
-+
-+echo "‚úÖ Basic notification settings configured"
-+
-+# Check for Slack configuration
-+if [[ -n "$GOOSE_SLACK_APP_TOKEN" && -n "$GOOSE_SLACK_BOT_TOKEN" ]]; then
-+    echo "‚úÖ Slack provider configured"
-+    echo "   App Token: ${GOOSE_SLACK_APP_TOKEN:0:12}..."
-+    echo "   Bot Token: ${GOOSE_SLACK_BOT_TOKEN:0:12}..."
-+    if [[ -n "$GOOSE_SLACK_CHANNEL" ]]; then
-+        echo "   Channel: $GOOSE_SLACK_CHANNEL"
-+    else
-+        echo "   Channel: DMs (default)"
-+    fi
-+else
-+    echo "‚ö†Ô∏è  Slack not configured. Set:"
-+    echo "   export GOOSE_SLACK_APP_TOKEN=\"xapp-your-token\""
-+    echo "   export GOOSE_SLACK_BOT_TOKEN=\"xoxb-your-token\""
-+    echo "   export GOOSE_SLACK_CHANNEL=\"#channel\"  # Optional"
-+fi
-+
-+# Check for Discord configuration  
-+if [[ -n "$GOOSE_DISCORD_BOT_TOKEN" ]]; then
-+    echo "‚úÖ Discord provider configured"
-+    echo "   Bot Token: ${GOOSE_DISCORD_BOT_TOKEN:0:12}..."
-+    if [[ -n "$GOOSE_DISCORD_USER_ID" ]]; then
-+        echo "   Target User: $GOOSE_DISCORD_USER_ID"
-+    else
-+        echo "   Target User: Any DM (default)"
-+    fi
-+else
-+    echo "‚ö†Ô∏è  Discord not configured. Set:"
-+    echo "   export GOOSE_DISCORD_BOT_TOKEN=\"your-bot-token\""
-+    echo "   export GOOSE_DISCORD_USER_ID=\"your-user-id\"  # Optional"
-+fi
-+
-+# Prompt templates
-+export GOOSE_PROMPTS_DIR="crates/goose-cli/prompts"
-+if [[ -d "$GOOSE_PROMPTS_DIR" ]]; then
-+    echo "‚úÖ Prompt templates found at $GOOSE_PROMPTS_DIR"
-+else
-+    echo "‚ö†Ô∏è  Prompt templates not found at $GOOSE_PROMPTS_DIR"
-+    echo "   Make sure you're running from the goose root directory"
-+fi
-+
-+# Test function
-+test_notifications() {
-+    echo ""
-+    echo "üß™ Testing notification configuration..."
-+    
-+    # Test Slack connection
-+    if [[ -n "$GOOSE_SLACK_BOT_TOKEN" ]]; then
-+        echo "Testing Slack connection..."
-+        response=$(curl -s -H "Authorization: Bearer $GOOSE_SLACK_BOT_TOKEN" \
-+                        -H "Content-Type: application/json" \
-+                        -X POST https://slack.com/api/auth.test)
-+        
-+        if echo "$response" | grep -q '"ok":true'; then
-+            echo "‚úÖ Slack connection successful"
-+        else
-+            echo "‚ùå Slack connection failed:"
-+            echo "$response" | jq '.error // "Unknown error"' 2>/dev/null || echo "$response"
-+        fi
-+    fi
-+    
-+    # Test Discord connection
-+    if [[ -n "$GOOSE_DISCORD_BOT_TOKEN" ]]; then
-+        echo "Testing Discord connection..."
-+        response=$(curl -s -H "Authorization: Bot $GOOSE_DISCORD_BOT_TOKEN" \
-+                        -X GET https://discord.com/api/users/@me)
-+        
-+        if echo "$response" | grep -q '"id"'; then
-+            bot_name=$(echo "$response" | jq -r '.username // "Unknown"' 2>/dev/null || echo "Unknown")
-+            echo "‚úÖ Discord connection successful (Bot: $bot_name)"
-+        else
-+            echo "‚ùå Discord connection failed:"
-+            echo "$response" | jq '.message // "Unknown error"' 2>/dev/null || echo "$response"
-+        fi
-+    fi
-+    
-+    echo ""
-+    echo "Now you can test with:"
-+    echo "  cargo run --features notifications"
-+    echo ""
-+    echo "The system will:"
-+    echo "  1. Wait 1 minute after Goose's last response"
-+    echo "  2. Send an intelligent notification with summary & fallback"
-+    echo "  3. Listen for your replies via DM"
-+    echo "  4. Execute fallback after another 1 minute if no response"
-+}
-+
-+# Make test function available
-+alias test-notifications='test_notifications'
-+
-+echo ""
-+echo "üöÄ Environment configured! Run 'test-notifications' to verify connections."
-+echo ""
-+echo "Example usage:"
-+echo "  cargo run --features notifications -- run -i 'Help me add error handling to main.rs'"
-+echo ""
-+echo "Then step away and wait for the intelligent notification! üì±" 
-\ No newline at end of file
-diff --git a/test_notifications_unit.sh b/test_notifications_unit.sh
-new file mode 100755
-index 0000000000..2d7a2797ed
---- /dev/null
-+++ b/test_notifications_unit.sh
-@@ -0,0 +1,6 @@
-+#!/bin/bash
-+# Run notifier tests with the notifications feature
-+echo "Running Goose CLI notifier tests..."
-+echo ""
-+./bin/cargo test -p goose-cli --features notifications notifier_test -- --nocapture
-+
diff --git a/package-lock.json b/package-lock.json
index 6deca24a71..44b3ae77cd 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -2,5 +2,28 @@
   "name": "goose",
   "lockfileVersion": 3,
   "requires": true,
-  "packages": {}
+  "packages": {
+    "": {
+      "devDependencies": {
+        "@types/node": "^24.0.15"
+      }
+    },
+    "node_modules/@types/node": {
+      "version": "24.0.15",
+      "resolved": "https://registry.npmjs.org/@types/node/-/node-24.0.15.tgz",
+      "integrity": "sha512-oaeTSbCef7U/z7rDeJA138xpG3NuKc64/rZ2qmUFkFJmnMsAPaluIifqyWd8hSSMxyP9oie3dLAqYPblag9KgA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "undici-types": "~7.8.0"
+      }
+    },
+    "node_modules/undici-types": {
+      "version": "7.8.0",
+      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-7.8.0.tgz",
+      "integrity": "sha512-9UJ2xGDvQ43tYyVMpuHlsgApydB8ZKfVYTsLDhXkFL/6gfkp+U8xTGdh8pMJv1SpZna0zxG1DwsKZsreLbXBxw==",
+      "dev": true,
+      "license": "MIT"
+    }
+  }
 }
diff --git a/ui/desktop/package-lock.json b/ui/desktop/package-lock.json
index 37b80b4b88..18b76817c1 100644
--- a/ui/desktop/package-lock.json
+++ b/ui/desktop/package-lock.json
@@ -24,12 +24,13 @@
         "@radix-ui/react-tabs": "^1.1.1",
         "@radix-ui/themes": "^3.1.5",
         "@types/react-router-dom": "^5.3.3",
+        "@types/yaml": "^1.9.6",
         "ai": "^3.4.33",
         "class-variance-authority": "^0.7.0",
         "clsx": "^2.1.1",
         "compare-versions": "^6.1.1",
         "cors": "^2.8.5",
-        "cronstrue": "^2.48.0",
+        "cronstrue": "^2.59.0",
         "date-fns": "^4.1.0",
         "dotenv": "^16.4.5",
         "electron-log": "^5.2.2",
@@ -55,7 +56,8 @@
         "tailwindcss-animate": "^1.0.7",
         "tw-animate-css": "^1.3.4",
         "unist-util-visit": "^5.0.0",
-        "uuid": "^11.1.0"
+        "uuid": "^11.1.0",
+        "yaml": "^2.8.0"
       },
       "devDependencies": {
         "@electron-forge/cli": "^7.5.0",
@@ -81,7 +83,7 @@
         "@types/electron-window-state": "^2.0.34",
         "@types/express": "^5.0.0",
         "@types/lodash": "^4.17.16",
-        "@types/react": "^18.3.12",
+        "@types/react": "^18.3.23",
         "@types/react-dom": "^18.3.1",
         "@types/react-syntax-highlighter": "^15.5.13",
         "@types/yauzl": "^2.10.3",
@@ -5519,6 +5521,15 @@
       "integrity": "sha512-ko/gIFJRv177XgZsZcBwnqJN5x/Gien8qNOn0D5bQU/zAzVf9Zt3BlcUiLqhV9y4ARk0GbT3tnUiPNgnTXzc/Q==",
       "license": "MIT"
     },
+    "node_modules/@types/yaml": {
+      "version": "1.9.6",
+      "resolved": "https://registry.npmjs.org/@types/yaml/-/yaml-1.9.6.tgz",
+      "integrity": "sha512-VKOCuDN57wngmyQnRqcn4vuGWCXViISHv+UCCjrKcf1yt4zyfMmOGlZDI2ucTHK72V8ki+sd7h21OZL6O5S52A==",
+      "license": "MIT",
+      "dependencies": {
+        "yaml": "*"
+      }
+    },
     "node_modules/@types/yauzl": {
       "version": "2.10.3",
       "resolved": "https://registry.npmjs.org/@types/yauzl/-/yauzl-2.10.3.tgz",
@@ -19236,7 +19247,6 @@
       "version": "2.8.0",
       "resolved": "https://registry.npmjs.org/yaml/-/yaml-2.8.0.tgz",
       "integrity": "sha512-4lLa/EcQCB0cJkyts+FpIRx5G/llPxfP6VQU5KByHEhLxY3IJCH0f0Hy1MHI8sClTvsIb8qwRJ6R/ZdlDJ/leQ==",
-      "dev": true,
       "license": "ISC",
       "bin": {
         "yaml": "bin.mjs"
diff --git a/ui/desktop/package.json b/ui/desktop/package.json
index 1586111425..aabb49bda5 100644
--- a/ui/desktop/package.json
+++ b/ui/desktop/package.json
@@ -49,12 +49,13 @@
     "@radix-ui/react-tabs": "^1.1.1",
     "@radix-ui/themes": "^3.1.5",
     "@types/react-router-dom": "^5.3.3",
+    "@types/yaml": "^1.9.6",
     "ai": "^3.4.33",
     "class-variance-authority": "^0.7.0",
     "clsx": "^2.1.1",
     "compare-versions": "^6.1.1",
     "cors": "^2.8.5",
-    "cronstrue": "^2.48.0",
+    "cronstrue": "^2.59.0",
     "date-fns": "^4.1.0",
     "dotenv": "^16.4.5",
     "electron-log": "^5.2.2",
@@ -80,7 +81,8 @@
     "tailwindcss-animate": "^1.0.7",
     "tw-animate-css": "^1.3.4",
     "unist-util-visit": "^5.0.0",
-    "uuid": "^11.1.0"
+    "uuid": "^11.1.0",
+    "yaml": "^2.8.0"
   },
   "devDependencies": {
     "@electron-forge/cli": "^7.5.0",
@@ -106,7 +108,7 @@
     "@types/electron-window-state": "^2.0.34",
     "@types/express": "^5.0.0",
     "@types/lodash": "^4.17.16",
-    "@types/react": "^18.3.12",
+    "@types/react": "^18.3.23",
     "@types/react-dom": "^18.3.1",
     "@types/react-syntax-highlighter": "^15.5.13",
     "@types/yauzl": "^2.10.3",
diff --git a/ui/desktop/src/components/schedule/CreateScheduleModal.tsx b/ui/desktop/src/components/schedule/CreateScheduleModal.tsx
index e73d9dd21a..37c5f876ec 100644
--- a/ui/desktop/src/components/schedule/CreateScheduleModal.tsx
+++ b/ui/desktop/src/components/schedule/CreateScheduleModal.tsx
@@ -3,10 +3,12 @@ import { Card } from '../ui/card';
 import { Button } from '../ui/button';
 import { Input } from '../ui/input';
 import { Select } from '../ui/Select';
-import cronstrue from 'cronstrue';
+import * as cronstrue from 'cronstrue';
 import * as yaml from 'yaml';
-import { Recipe, decodeRecipe } from '../../recipe';
+import type { Recipe } from '../../api/types.gen';
 import ClockIcon from '../../assets/clock-icon.svg';
+/// <reference types="node" />
+declare var Buffer: any;
 
 type FrequencyValue = 'once' | 'every' | 'daily' | 'weekly' | 'monthly';
 
@@ -32,46 +34,29 @@ interface CreateScheduleModalProps {
   apiErrorExternally: string | null;
 }
 
-// Interface for clean extension in YAML
-interface CleanExtension {
-  name: string;
-  type: 'stdio' | 'sse' | 'builtin' | 'frontend' | 'streamable_http';
-  cmd?: string;
-  args?: string[];
-  uri?: string;
-  display_name?: string;
-  tools?: unknown[];
-  instructions?: string;
-  env_keys?: string[];
-  timeout?: number;
-  description?: string;
-  bundled?: boolean;
-}
-
-// TODO: This 'Recipe' interface should be converted to match the OpenAPI spec for Recipe
-// once we have separated the recipe from the schedule in the frontend.
-// Interface for clean recipe in YAML
-interface CleanRecipe {
-  title: string;
-  description: string;
-  instructions?: string;
-  prompt?: string;
-  activities?: string[];
-  extensions?: CleanExtension[];
-  goosehints?: string;
-  context?: string[];
-  profile?: string;
-  author?: {
-    contact?: string;
-    metadata?: string;
-  };
-  schedule?: {
-    foreground: boolean;
-    fallback_to_background: boolean;
-    window_title?: string;
-    working_directory?: string;
-  };
-}
+// Remove unused CleanExtension type
+// Remove the old CleanRecipe interface and use the OpenAPI Recipe type
+// interface CleanRecipe {
+//   title: string;
+//   description: string;
+//   instructions?: string;
+//   prompt?: string;
+//   activities?: string[];
+//   extensions?: CleanExtension[];
+//   goosehints?: string;
+//   context?: string[];
+//   profile?: string;
+//   author?: {
+//     contact?: string;
+//     metadata?: string;
+//   };
+//   schedule?: {
+//     foreground: boolean;
+//     fallback_to_background: boolean;
+//     window_title?: string;
+//     working_directory?: string;
+//   };
+// }
 
 const frequencies: FrequencyOption[] = [
   { value: 'once', label: 'Once' },
@@ -107,6 +92,21 @@ const checkboxInputClassName =
 type SourceType = 'file' | 'deeplink';
 type ExecutionMode = 'background' | 'foreground';
 
+function base64Decode(str: string): string {
+  if (typeof window !== 'undefined' && typeof window.atob === 'function') {
+    // Browser environment
+    return decodeURIComponent(escape(window.atob(str)));
+  } else {
+    // Node.js/Electron environment
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    const BufferAny = (typeof Buffer !== 'undefined' ? Buffer : undefined) as any;
+    if (BufferAny) {
+      return BufferAny.from(str, 'base64').toString('utf-8');
+    }
+    throw new Error('No base64 decode method available');
+  }
+}
+
 // Function to parse deep link and extract recipe config
 async function parseDeepLink(deepLink: string): Promise<Recipe | null> {
   try {
@@ -114,13 +114,14 @@ async function parseDeepLink(deepLink: string): Promise<Recipe | null> {
     if (url.protocol !== 'goose:' || (url.hostname !== 'bot' && url.hostname !== 'recipe')) {
       return null;
     }
-
     const recipeParam = url.searchParams.get('config');
     if (!recipeParam) {
       return null;
     }
-
-    return await decodeRecipe(recipeParam);
+    // Use helper for base64 decoding
+    const yamlContent = base64Decode(recipeParam);
+    const recipe = yaml.parse(yamlContent as string) as Record<string, unknown>;
+    return recipe as Recipe;
   } catch (error) {
     console.error('Failed to parse deep link:', error);
     return null;
@@ -129,142 +130,19 @@ async function parseDeepLink(deepLink: string): Promise<Recipe | null> {
 
 // Function to convert recipe to YAML with schedule configuration
 function recipeToYaml(recipe: Recipe, executionMode: ExecutionMode): string {
-  // Create a clean recipe object for YAML conversion
-  const cleanRecipe: CleanRecipe = {
-    title: recipe.title,
-    description: recipe.description,
+  // Copy the Recipe fields
+  const cleanRecipe: Record<string, unknown> = {
+    ...recipe,
   };
-
-  if (recipe.instructions) {
-    cleanRecipe.instructions = recipe.instructions;
-  }
-
-  if (recipe.prompt) {
-    cleanRecipe.prompt = recipe.prompt;
-  }
-
-  if (recipe.activities && recipe.activities.length > 0) {
-    cleanRecipe.activities = recipe.activities;
-  }
-
-  if (recipe.extensions && recipe.extensions.length > 0) {
-    cleanRecipe.extensions = recipe.extensions.map((ext) => {
-      const cleanExt: CleanExtension = {
-        name: ext.name,
-        type: 'builtin', // Default type, will be overridden below
-      };
-
-      // Handle different extension types using type assertions
-      if ('type' in ext && ext.type) {
-        cleanExt.type = ext.type as CleanExtension['type'];
-
-        // Use type assertions to access properties safely
-        const extAny = ext as Record<string, unknown>;
-
-        if (ext.type === 'sse' && extAny.uri) {
-          cleanExt.uri = extAny.uri as string;
-        } else if (ext.type === 'streamable_http' && extAny.uri) {
-          cleanExt.uri = extAny.uri as string;
-        } else if (ext.type === 'stdio') {
-          if (extAny.cmd) {
-            cleanExt.cmd = extAny.cmd as string;
-          }
-          if (extAny.args) {
-            cleanExt.args = extAny.args as string[];
-          }
-        } else if (ext.type === 'builtin' && extAny.display_name) {
-          cleanExt.display_name = extAny.display_name as string;
-        }
-
-        // Handle frontend type separately to avoid TypeScript narrowing issues
-        if ((ext.type as string) === 'frontend') {
-          if (extAny.tools) {
-            cleanExt.tools = extAny.tools as unknown[];
-          }
-          if (extAny.instructions) {
-            cleanExt.instructions = extAny.instructions as string;
-          }
-        }
-      } else {
-        // Fallback: try to infer type from available fields
-        const extAny = ext as Record<string, unknown>;
-
-        if (extAny.cmd) {
-          cleanExt.type = 'stdio';
-          cleanExt.cmd = extAny.cmd as string;
-          if (extAny.args) {
-            cleanExt.args = extAny.args as string[];
-          }
-        } else if (extAny.command) {
-          // Handle legacy 'command' field by converting to 'cmd'
-          cleanExt.type = 'stdio';
-          cleanExt.cmd = extAny.command as string;
-        } else if (extAny.uri) {
-          // Default to streamable_http for URI-based extensions for forward compatibility
-          cleanExt.type = 'streamable_http';
-          cleanExt.uri = extAny.uri as string;
-        } else if (extAny.tools) {
-          cleanExt.type = 'frontend';
-          cleanExt.tools = extAny.tools as unknown[];
-          if (extAny.instructions) {
-            cleanExt.instructions = extAny.instructions as string;
-          }
-        } else {
-          // Default to builtin if we can't determine type
-          cleanExt.type = 'builtin';
-        }
-      }
-
-      // Add common optional fields
-      if ('env_keys' in ext && ext.env_keys && ext.env_keys.length > 0) {
-        cleanExt.env_keys = ext.env_keys;
-      }
-
-      if ('timeout' in ext && ext.timeout) {
-        cleanExt.timeout = ext.timeout as number;
-      }
-
-      if ('description' in ext && ext.description) {
-        cleanExt.description = ext.description as string;
-      }
-
-      if ('bundled' in ext && ext.bundled !== undefined) {
-        cleanExt.bundled = ext.bundled as boolean;
-      }
-
-      return cleanExt;
-    });
-  }
-
-  if (recipe.goosehints) {
-    cleanRecipe.goosehints = recipe.goosehints;
-  }
-
-  if (recipe.context && recipe.context.length > 0) {
-    cleanRecipe.context = recipe.context;
-  }
-
-  if (recipe.profile) {
-    cleanRecipe.profile = recipe.profile;
-  }
-
-  if (recipe.author) {
-    cleanRecipe.author = {
-      contact: recipe.author.contact || undefined,
-      metadata: recipe.author.metadata || undefined,
-    };
-  }
-
-  // Add schedule configuration based on execution mode
+  // Add schedule configuration as a separate field (not part of Recipe type)
   cleanRecipe.schedule = {
     foreground: executionMode === 'foreground',
-    fallback_to_background: true, // Always allow fallback
-    window_title: executionMode === 'foreground' ? `${recipe.title} - Scheduled` : undefined,
+    fallback_to_background: true,
   };
-
   return yaml.stringify(cleanRecipe);
 }
 
+// Add type annotations for CreateScheduleModal props
 export const CreateScheduleModal: React.FC<CreateScheduleModalProps> = ({
   isOpen,
   onClose,
diff --git a/ui/desktop/src/recipe/index.ts b/ui/desktop/src/recipe/index.ts
index 1a51c95d90..de4a5c029c 100644
--- a/ui/desktop/src/recipe/index.ts
+++ b/ui/desktop/src/recipe/index.ts
@@ -3,18 +3,18 @@ import {
   encodeRecipe as apiEncodeRecipe,
   decodeRecipe as apiDecodeRecipe,
 } from '../api';
-import type {
+import {
   CreateRecipeRequest as ApiCreateRecipeRequest,
-  CreateRecipeResponse as ApiCreateRecipeResponse,
-  RecipeParameter,
+  CreateRecipeRequest,
   Message as ApiMessage,
-  Role,
   MessageContent,
-} from '../api';
+  Role,
+} from '../api/types.gen';
+import type { CreateRecipeResponse as ApiCreateRecipeResponse } from '../api';
 import type { Message as FrontendMessage } from '../types/message';
 
 // Re-export OpenAPI types with frontend-specific additions
-export type Parameter = RecipeParameter;
+export type Parameter = import('../api').RecipeParameter;
 export type Recipe = import('../api').Recipe & {
   // TODO: Separate these from the raw recipe type
   // Properties added for scheduled execution
@@ -28,17 +28,17 @@ export type Recipe = import('../api').Recipe & {
 };
 
 // Create frontend-compatible type that accepts frontend Message until we can refactor.
-export interface CreateRecipeRequest {
-  // TODO: Fix this type to match Message OpenAPI spec
-  messages: FrontendMessage[];
-  title: string;
-  description: string;
-  activities?: string[];
-  author?: {
-    contact?: string;
-    metadata?: string;
-  };
-}
+// Remove the old CreateRecipeRequest interface and use the generated one
+// export interface CreateRecipeRequest {
+//   messages: FrontendMessage[];
+//   title: string;
+//   description: string;
+//   activities?: string[];
+//   author?: {
+//     contact?: string;
+//     metadata?: string;
+//   };
+// }
 
 export type CreateRecipeResponse = ApiCreateRecipeResponse;
 
@@ -64,21 +64,9 @@ export async function createRecipe(request: CreateRecipeRequest): Promise<Create
   console.log('Creating recipe with request:', JSON.stringify(request, null, 2));
 
   try {
-    const apiRequest: ApiCreateRecipeRequest = {
-      messages: request.messages.map(convertFrontendMessageToApiMessage),
-      title: request.title,
-      description: request.description,
-      activities: request.activities || undefined,
-      author: request.author
-        ? {
-            contact: request.author.contact || undefined,
-            metadata: request.author.metadata || undefined,
-          }
-        : undefined,
-    };
-
+    // No need to map to ApiCreateRecipeRequest, just use request directly
     const response = await apiCreateRecipe({
-      body: apiRequest,
+      body: request,
     });
 
     if (!response.data) {
